[{"content":"Markdown here\n","description":"test post","id":0,"section":"updates","tags":null,"title":"May 2019","uri":"http://www.shaochenfeng.com/updates/2019_may/"},{"content":"Markdown here\n","description":"test post","id":1,"section":"docs","tags":null,"title":"Basic Usage","uri":"http://www.shaochenfeng.com/docs/gettingstarted/basicusage/"},{"content":"Markdown here\n","description":"test post","id":2,"section":"updates","tags":null,"title":"April 2019","uri":"http://www.shaochenfeng.com/updates/2019_april/"},{"content":"Markdown here\n","description":"test post","id":3,"section":"docs","tags":null,"title":"Configuration","uri":"http://www.shaochenfeng.com/docs/gettingstarted/configuration/"},{"content":"Markdown here\n","description":"test post","id":4,"section":"updates","tags":null,"title":"March 2019","uri":"http://www.shaochenfeng.com/updates/2019_march/"},{"content":"Markdown here\n","description":"test post","id":5,"section":"docs","tags":null,"title":"Installation","uri":"http://www.shaochenfeng.com/docs/gettingstarted/installation/"},{"content":"Markdown here\n","description":"test post","id":6,"section":"updates","tags":null,"title":"February 2019","uri":"http://www.shaochenfeng.com/updates/2019_february/"},{"content":"Markdown here\n","description":"test post","id":7,"section":"docs","tags":null,"title":"Quick Start","uri":"http://www.shaochenfeng.com/docs/gettingstarted/quickstart/"},{"content":"Markdown here\n","description":"test post","id":8,"section":"updates","tags":null,"title":"January 2019","uri":"http://www.shaochenfeng.com/updates/2019_january/"},{"content":" 检查你的项目 如果你的项目根目录下有 pom.xml 文件，可以认为是Maven项目，参照下面Maven项目执行\n如果你的项目根目录下有 build.gradle 文件，可以认为是Gradle项目，参照下面Gradle项目执行\nMaven项目 1.安装Maven 如果已经安装过maven，可以跳过这步\nMaven可作为zip文件从https://maven.apache.org/download.cgi下载。\n安装Maven只需要二进制文件，下载下图两个压缩包中一个\n下载完压缩文件后，将其解压缩到计算机上。然后将bin文件夹添加到环境变量path中。\n打开Maven目录下的 conf/settings.xml 文件 注释掉官方仓库，换位阿里源以提高依赖下载速度\n\u0026lt;mirrors\u0026gt; \u0026lt;!-- \u0026lt;mirror\u0026gt; \u0026lt;id\u0026gt;mirrorId\u0026lt;/id\u0026gt; \u0026lt;mirrorOf\u0026gt;repositoryId\u0026lt;/mirrorOf\u0026gt; \u0026lt;name\u0026gt;Human Readable Name for this Mirror.\u0026lt;/name\u0026gt; \u0026lt;url\u0026gt;http://my.repository.com/repo/path\u0026lt;/url\u0026gt; \u0026lt;/mirror\u0026gt; --\u0026gt; \u0026lt;mirror\u0026gt; \u0026lt;id\u0026gt;nexus-aliyun\u0026lt;/id\u0026gt; \u0026lt;mirrorOf\u0026gt;*\u0026lt;/mirrorOf\u0026gt; \u0026lt;name\u0026gt;Nexus aliyun\u0026lt;/name\u0026gt; \u0026lt;url\u0026gt;http://maven.aliyun.com/nexus/content/groups/public\u0026lt;/url\u0026gt; \u0026lt;/mirror\u0026gt; \u0026lt;/mirrors\u0026gt;  测试Maven安装是否成功，从命令行运行mvn：\nmvn -v  如果看到版本信息，说明安装成功\n2.编译并运行 编译项目为jar包\nmvn package  可以打包为jar或war，取决于packaging值，通常都是jar\njar包可以直接运行\njava -jar target/gs-maven-0.1.0.jar  至此，项目运行成功\n如果有依赖问题，用这条语句安装依赖\nmvn install  依赖都会在pom.xml中声明\n这条语句进行测试\nmvn test  Gradle项目 1.安装Gradle 如果已经安装过Gradle，可以跳过这步\nGradle可从https://maven.apache.org/download.cgi下载。\n安装Gradle请下载下图命名格式的压缩包\n下载完压缩文件后，将其解压缩到计算机上。然后将bin文件夹添加到环境变量path中。\n测试Gradle安装是否成功，从命令行运行gradle：\ngradle -v  如果看到版本信息，说明安装成功\n2.编译执行 编译项目为jar包\ngradle build  jar包可以直接运行\njava -jar build/libs/XXXX.jar  至此，项目运行成功\n如果遇到依赖下载缓慢，可以打开项目目录下的build.gradle文件，找到 repositories，注释掉mavenCentral(),使用阿里云的仓库地址\nrepositories { //mavenCentral() maven { url 'http://maven.aliyun.com/nexus/content/groups/public/' } }  ","description":"","id":9,"section":"blog","tags":["Maven","Gradle"],"title":"用命令行构建和运行springboot项目","uri":"http://www.shaochenfeng.com/blog/%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%9E%84%E5%BB%BA%E8%BF%90%E8%A1%8Cspringboot%E9%A1%B9%E7%9B%AE/"},{"content":" 全部案例 配置git用户名邮件\n单纯的下载一个仓库\n将远程仓库的更新拉到本地仓库（不影响本地已有的提交）\n将本地修改上传到远程仓库\n将本地更改上传到远程仓库，并使本地远程一致\n新建一个仓库并用本地代码初始化\n我不想同步某些文件/文件夹\n从master创建临时分支作修改，然后合并到主分支\n删除仓库所有历史记录，仅保留当前文件\n修改前n次commit的提交信息\n配置git用户名邮件 git config --global user.name \u0026quot;Your Name\u0026quot; git config --global user.email \u0026quot;email@example.com\u0026quot;  单纯的下载一个仓库 最常用的方法\ngit clone https://github.com/xxx/xxx.git  项目太大，想快点下载，不需要历史记录\ngit clone --depth 1 https://github.com/xxx/xxx.git  想快速下载非master分支\ngit clone --depth 1 https://github.com/xxx/xxx.git cd xxx git remote set-branches origin 'remote_branch_name' git fetch --depth 1 origin remote_branch_name git checkout remote_branch_name  将远程仓库的更新拉到本地仓库（不影响本地已有的提交） git pull origin master  将本地修改上传到远程仓库 git add . git commit -m \u0026quot;提交说明\u0026quot; git push origin master  将本地更改上传到远程仓库，并使本地远程一致 git add . git commit -m \u0026quot;提交说明\u0026quot; git pull origin master git push origin master  新建一个仓库并用本地代码初始化 首先到github或其他git网站上创建一个新仓库，获得新仓库地址，类似于 https://github.com/xxx/xxx.git\ngit init git add -A git commit -m \u0026quot;初始化代码\u0026quot; git remote add origin https://github.com/xxx/xxx.git git push -u origin master  我不想同步某些文件/文件夹 在仓库的根目录下新建 .gitignore 文件 其中写上要忽略的内容，支持文件、文件夹、通配符\ntarget/ .idea/ *.log somefile.txt  从master创建临时分支作修改，然后合并到主分支  创建临时分支\ngit checkout master git pull origin master git checkout -b tmp git push origin tmp # 在远程也创建临时分支 git branch --set-upstream-to=origin/tmp git pull origin tmp  用你喜欢的方式作修改代码，在此过程中可以提交代码\ngit add . git commit -m \u0026quot;提交说明\u0026quot; git push origin tmp  最后合并分支tmp到master，然后删除tmp\ngit checkout master git merge tmp git push origin master git branch -d tmp git push origin --delete tmp   删除仓库所有历史记录，仅保留当前文件 git checkout --orphan lastest # 从0新建分支 git add -A # 添加所有当前文件到分支 git commit -m \u0026quot;init信息\u0026quot; git branch -D master # 删除master分支 git branch -m master # 重命名当前分支为master git push -f origin master # 强制提交到远程  修改前n次commit的提交信息 git rebase -i HEAD~n # 这里查看最近n次commit提交信息 # 然后进入编辑模式，将需要修改的commit那一行的pick修改为edit，保存退出 git commit --amend # 这会进入上面修改对应的commit提交信息 git rebase --continue # 回到正常状态  ","description":"","id":10,"section":"blog","tags":["git"],"title":"写给大忙人看的Git案例总结","uri":"http://www.shaochenfeng.com/blog/%E5%86%99%E7%BB%99%E5%A4%A7%E5%BF%99%E4%BA%BA%E7%9C%8B%E7%9A%84git%E6%A1%88%E4%BE%8B%E6%80%BB%E7%BB%93/"},{"content":" 安装中文支持 不然安装以后web界面不能设置为中文\ndnf install langpacks-zh_CN # 在centos7中是 yum install kde-l10n-Chinese  下载源码 浏览器打开 https://www.zabbix.com/download_sources\n下载最新的长期支持版，上传到服务器\n在服务器解压\ntar -zxvf zabbix-4.4.4.tar.gz cd zabbix-4.4.4/ # 增加zabbix使用的组和用户 groupadd --system zabbix useradd --system -g zabbix -d /usr/lib/zabbix -s /sbin/nologin -c \u0026quot;Zabbix Monitoring System\u0026quot; zabbix  配置数据库 需要先安装数据库，mysql5.7及以上，没有安装的可以看这篇文章 yum安装mysql8\n然后配置zabbix的数据库和用户权限\nmysql -uroot -p # 输入登陆密码 mysql\u0026gt; create database zabbix character set utf8 collate utf8_bin; mysql\u0026gt; grant all privileges on zabbix.* to zabbix@localhost identified by '123'; mysql\u0026gt; quit;  导入zabbix数据库\nmysql -uzabbix -p123 zabbix \u0026lt; database/mysql/schema.sql mysql -uzabbix -p123 zabbix \u0026lt; database/mysql/images.sql mysql -uzabbix -p123 zabbix \u0026lt; database/mysql/data.sql  编译zabbix 首先安装编译要用到的工具，除了下面标出的还需要常规编译经常用到的 gcc 等，报错的时候缺啥补啥即可\ndnf -y install net-snmp-devel libevent-devel libxml2-devel libcurl-devel pcre-devel  编译安装\n./configure --enable-server --enable-agent --with-mysql=/usr/local/mysql/bin/mysql_config --enable-ipv6 --with-net-snmp --with-libcurl --with-libxml2 --prefix=/opt/zabbix4.0 # 最后一个选项，我安装到了 /opt/zabbix4.0 目录下，你可以选择自己喜欢的目录 make install  配置 修改 agentd 端和 server 端的配置，主要配置数据库账号密码和连接方式，顺便配置日志位置 cd /opt/zabbix4.0 vim etc/zabbix_agentd.conf\n# 这些配置找到对应的行修改即可 Server=127.0.0.1 LogFile=/opt/zabbix4.0/zabbix_agentd.log PidFile=/opt/zabbix4.0/zabbix_agentd.pid  vim etc/zabbix_server.conf\nLogFile=/opt/zabbix4.4/zabbix_server.log PidFile=/opt/zabbix4.4/zabbix_server.pid DBPassword=123 DBSocket=/tmp/mysql.sock  nginx虚拟主机配置 为了不影响当前的网站，我们使用虚拟主机的来配置zabbix web界面\n首先参照网上的教程安装nginx并配置php\n将 zabbix web 文件复制到 nginx目录 cd /usr/share/nginx mkdir zabbix cp ~/zabbix-4.0/frontends/php/* zabbix/ -r chown nginx:nginx zabbix -R\n配置虚拟主机 vim /etc/nginx/nginx.conf\n#增加 server { listen 80; listen [::]:80; access_log log/zabbix.你的域名.com; error_log log/zabbix.你的域名.com.err error; server_name zabbix.你的域名.com; root /usr/share/nginx/zabbix location / { } }  最后 访问 http://zabbix.你的域名.com/ 皆可安装\n默认的账户密码是 Admin/zabbix\n官方安装教程【英文】 https://www.zabbix.com/documentation/4.0/manual/installation/install\n","description":"","id":11,"section":"blog","tags":["CentOS8","zabbix"],"title":"Centos8安装zabbix监控，源码方式","uri":"http://www.shaochenfeng.com/blog/cento8%E5%AE%89%E8%A3%85szabbix%E7%9B%91%E6%8E%A7/"},{"content":" 第一次接触RPM包的概念，初学者可能会不知所措，因为它给人留下了学习曲线陡峭的的印象。在本文中，我将演示用最少的知识和经验来构建RPM。请注意，本文只是作为入门，而不是RPM的完整指南。\n基于ASCII的俄罗斯方块游戏 在我的演示中，我选择了一个简单的基于ASCII的终端游戏，用C编写。过程中做了一些细微的调整以确保可以相对简单的进行RPM构建。我将以一个名为Vitetris的游戏为例。您可以下载该游戏。\n为确保创建RPM软件包时没有错误，我删除了Makefile中将文件权限更改为root的参数，以允许非root用户构建RPM。修改如下：\n$ cat Makefile |grep 'INSTALL ' INSTALL = install #INSTALL = install -oroot -groot # non-root users building the rpm won't be able to set this and the RPM build will fail.  进行此更改后，请创建一个新的压缩tarball，重命名为：vitetris-0.57.tar.gz。\n准备环境 安装开发环境在红帽企业Linux（RHEL）7系统上，你需要以下存储库构建RPM：rhel-7-server-rpms，rhel-7-server-extras-rpms和rhel-7-server-optional-rpms。\n您需要安装以下软件包：\n# yum install -y rpm* gcc gpg* rng-tools  我使用rpm*，gpg*因为它使安装时要记住的事情变得更少更加易于管理。\n手动编译软件 RPM打包成功的很大一步是了解您正在使用的软件。首先，最好以非root用户身份进行手动编译软件。我使用rpmbuilder用户。\n首先提取压缩的tarball（vitetris-0.57.tar.gz），然后检查README文件。在这种情况下，自述文件不包含有关从源代码编译游戏的信息。一般的，用C语言编写的开源软件编译可分为三个步骤：configure，make，和make install。这次我们单独运行make以查看软件是否可以构建。\n作为非root用户，请测试运行make是否成功：\n[rpmbuilder@rpm vitetris-0.57]$ make generating src/src-conf.mk ./src-conf.sh 'cc' '' '' ... Done. Now run ./tetris (or make install)  要测试游戏，只需运行./tetris以查看游戏是否可以正常游玩：\n创建GPG密钥 对您的RPM软件包进行签名会让您的软件包更可信。因此，要以rpmbuilder用户身份创建GPG密钥。您需要一个具有root权限的会话来运行rngd（以加快生成过程），并需要一个具有X11转发功能的会话作为rpmbuilder用户。\n以root身份运行：\n# rngd -r /dev/urandom  如果出现以下错误：\nFailed to init entropy source 2: Intel RDRAND Instruction RNG  尝试：\n# rngd -r /dev/urandom -o /dev/random -f  您必须以具有X11转发功能的rpmbuilder用户会话登录到主机（否则，密钥生成将失败）：\n$ gpg --gen-key ... Please select what kind of key you want: (1) RSA and RSA (default) (2) DSA and Elgamal (3) DSA (sign only) (4) RSA (sign only) Your selection? 1 RSA keys may be between 1024 and 4096 bits long. What keysize do you want? (2048) Requested keysize is 2048 bits Please specify how long the key should be valid. 0 = key does not expire \u0026lt;n\u0026gt; = key expires in n days \u0026lt;n\u0026gt;w = key expires in n weeks \u0026lt;n\u0026gt;m = key expires in n months \u0026lt;n\u0026gt;y = key expires in n years Key is valid for? (0) Key does not expire at all Is this correct? (y/N) y GnuPG needs to construct a user ID to identify your key. Real name: RPM Build User Email address: rpmbuilder@rpm Comment: RPM Builder GPG Signing Key You selected this USER-ID: \u0026quot;RPM Build User (RPM Builder GPG Signing Key) \u0026lt;rpmbuilder@rpm\u0026gt;\u0026quot; Change (N)ame, (C)omment, (E)mail or (O)kay/(Q)uit? O You need a Passphrase to protect your secret key.   仅当您打开X11转发时，才会出现此提示。\n ... gpg: depth: 0 valid: 1 signed: 0 trust: 0-, 0q, 0n, 0m, 0f, 1u pub 2048R/EEF6D9AD 2019-03-02 Key fingerprint = 6ED1 2456 B7ED EEC6 D0DF B870 444A 40A7 EEF6 D9AD uid RPM Build User (RPM Builder GPG Signing Key) \u0026lt;rpmbuilder@rpm\u0026gt; sub 2048R/D498F883 2019-03-02  如果您需要在自定义软件或在yum仓库配置中使用的此密钥时，可以使用以下命令导出密钥：\n$ gpg --armor --export -----BEGIN PGP PUBLIC KEY BLOCK----- Version: GnuPG v2.0.22 (GNU/Linux)  为Vitetris游戏创建RPM包 要构建RPM，首先创建构建目录树和spec文件，然后将源代码放在正确的位置：\n$ rpmdev-setuptree $ rpmdev-newspec rpmbuild/SPECS/vitetris.spec rpmbuild/SPECS/vitetris.spec created; type minimal, rpm version \u0026gt;= 4.11. $ cp vitetris-0.57.tar.gz rpmbuild/SOURCES/  将初始详细信息添加到spec文件中 提供初始详细信息：\nName: vitetris Version: 0.57 Release: 1%{?dist} Summary: ASCII based tetris game License: BSD URL: https://www.victornils.net/tetris/ Source0: vitetris-0.57.tar.gz BuildRequires: gcc  删除不必要的部分  删除该Requires部分，因为此软件没有任何依赖性。 删除此%configure部分，因为无需构建此软件configure（如果需要configure，请保留此部分，然后再运行make）。\n添加描述信息 您可以在这里添加任何您喜欢的东西，这是一个例子：\n%description vitetris is a multiplayer ASCII-based Tetris game  测试初始版本 使用刚刚提供的信息测试构建，查看出现了哪些错误：\n$ rpmbuild -ba rpmbuild/SPECS/vitetris.spec ... RPM build errors: Installed (but unpackaged) file(s) found: /usr/local/bin/tetris /usr/local/share/applications/vitetris.desktop /usr/local/share/doc/vitetris/README /usr/local/share/doc/vitetris/licence.txt /usr/local/share/pixmaps/vitetris.xpm  将上一步中的文件列表添加到规范文件 您需要将上一步中的文件列表添加到spec文件的%files节中，如下所示：\n%files /usr/local/bin/tetris /usr/local/share/applications/vitetris.desktop %doc /usr/local/share/doc/vitetris/README /usr/local/share/doc/vitetris/licence.txt /usr/local/share/pixmaps/vitetris.xpm  请注意，在自述文件的前面需要放上%doc，以将其标识为参考文件。没有这个，RPM仍然会成功构建。\n  重新运行构建 $ rpmbuild -ba rpmbuild/SPECS/vitetris.spec Wrote: /home/rpmbuilder/rpmbuild/SRPMS/vitetris-0.57-1.el7.src.rpm Wrote: /home/rpmbuilder/rpmbuild/RPMS/x86_64/vitetris-0.57-1.el7.x86_64.rpm Wrote: /home/rpmbuilder/rpmbuild/RPMS/x86_64/vitetris-debuginfo-0.57-1.el7.x86_64.rpm Executing(%clean): /bin/sh -e /var/tmp/rpm-tmp.AqR4Aq + umask 022 + cd /home/rpmbuilder/rpmbuild/BUILD + cd vitetris-0.57 + /usr/bin/rm -rf /home/rpmbuilder/rpmbuild/BUILDROOT/vitetris-0.57-1.el7.x86_64 + exit 0  给RPM包签名 给RPM包签名很简单：\n$ rpmsign --addsign /home/rpmbuilder/rpmbuild/RPMS/x86_64/vitetris-0.57-1.el7.x86_64.rpm Enter pass phrase: Pass phrase is good. /home/rpmbuilder/rpmbuild/RPMS/x86_64/vitetris-0.57-1.el7.x86_64.rpm:  如果出现此错误：\nYou must set \u0026quot;%_gpg_name\u0026quot; in your macro file  则需要在你的公钥值中设置%_gpg_name：\n$ gpg --list-keys /home/rpmbuilder/.gnupg/pubring.gpg ----------------------------------- pub 2048R/EEF6D9AD 2019-03-02 uid RPM Build User (RPM Builder GPG Signing Key) \u0026lt;rpmbuilder@rpm\u0026gt; sub 2048R/D498F883 2019-03-02 $ echo \u0026quot;%_gpg_name EEF6D9AD\u0026quot; \u0026gt;\u0026gt; .rpmmacros  再试一次：\n$ rpmsign --addsign /home/rpmbuilder/rpmbuild/RPMS/x86_64/vitetris-0.57-1.el7.x86_64.rpm Enter pass phrase: Pass phrase is good. /home/rpmbuilder/rpmbuild/RPMS/x86_64/vitetris-0.57-1.el7.x86_64.rpm:  以root用户身份测试RPM包的安装/卸载 # rpm -i /home/rpmbuilder/rpmbuild/RPMS/x86_64/vitetris-0.57-1.el7.x86_64.rpm warning: /home/rpmbuilder/rpmbuild/RPMS/x86_64/vitetris-0.57-1.el7.x86_64.rpm: Header V4 RSA/SHA1 Signature, key ID eef6d9ad: NOKEY # /usr/local/bin/tetris  卸载RPM：\n# rpm -qa |grep tetris vitetris-0.57-1.el7.x86_64 =# rpm -e vitetris-0.57-1.el7.x86_64 # /usr/local/bin/tetris -bash: /usr/local/bin/tetris: No such file or directory  结论 根据需求打包自定义RPM包通常可能会很困难。在本文中，我旨在说明，很少的配置也足以构建RPM。\n要了解更多信息，请参阅Red Hat的RPM包装指南。\n原文链接：https://developers.redhat.com/blog/2019/03/18/rpm-packaging-guide-creating-rpm/\n作者：Mohammad Ahmad\n译者：邵晨峰\n","description":"","id":12,"section":"blog","tags":["RPM","翻译"],"title":"RPM封装：创建一个RPM包的简化指南","uri":"http://www.shaochenfeng.com/blog/rpm%E5%B0%81%E8%A3%85%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AArpm%E5%8C%85%E7%9A%84%E7%AE%80%E5%8C%96%E6%8C%87%E5%8D%97/"},{"content":" 一. 设置firewall规则 例1：对外暴露8080端口\nfirewall-cmd --permanent --add-port=8080/tcp  例2：使mysql服务的3306端口只允许192.168.1.1/24网段的服务器能访问\n#添加规则 firewall-cmd --permanent --add-rich-rule=\u0026quot;rule family=\u0026quot;ipv4\u0026quot; source address=\u0026quot;192.168.1.1/24\u0026quot; port protocol=\u0026quot;tcp\u0026quot; port=\u0026quot;3306\u0026quot; accept\u0026quot; #reload使生效 firewall-cmd --reload  例3：端口转发，将到本机的3306端口的访问转发到192.168.1.1服务器的3306端口\n# 开启伪装IP firewall-cmd --permanent --add-masquerade # 配置端口转发 firewall-cmd --permanent --add-forward-port=port=3306:proto=tcp:toaddr=192.168.1.2:toport=13306  注意：如果不开启伪装IP，端口转发会失败；其次，要确保源服务器上的端口（3306）和目标服务器上的端口（13306）是开启的。\n二. firewall命令 1.启动, 停止, 重启firewalld  停止\nsystemctl stop firewalld.service  启动\nsystemctl start firewalld.service  重启\nsystemctl restart firewalld.service  查看状态\nsystemctl status firewalld  禁止firewall开机启动\nsystemctl disable firewalld  设置开机启用防火墙 systemctl enable firewalld.service\n  2.查看firewall规则与状态  查看默认防火墙状态（关闭后显示notrunning，开启后显示running）\nfirewall-cmd --state  查看防火墙规则（只显示/etc/firewalld/zones/public.xml中防火墙策略）\nfirewall-cmd --list-all  查看所有的防火墙策略（即显示/etc/firewalld/zones/下的所有策略）\nfirewall-cmd --list-all-zones  重新加载配置文件\nfirewall-cmd --reload  配置firewalld-cmd\n查看版本： firewall-cmd --version 查看帮助： firewall-cmd --help 显示状态： firewall-cmd --state 查看所有打开的端口： firewall-cmd --zone=public --list-ports 更新防火墙规则： firewall-cmd --reload 查看区域信息: firewall-cmd --get-active-zones 查看指定接口所属区域： firewall-cmd --get-zone-of-interface=eth0 拒绝所有包：firewall-cmd --panic-on 取消拒绝状态： firewall-cmd --panic-off 查看是否拒绝： firewall-cmd --query-panic   4. 开启一个端口  添加（\u0026ndash;permanent永久生效，没有此参数重启后失效）\nfirewall-cmd --zone=public --add-port=80/tcp --permanent  重新载入(修改规则后使其生效)\nfirewall-cmd --reload  查看\nfirewall-cmd --zone=public --query-port=80/tcp  删除\nfirewall-cmd --zone=public --remove-port=80/tcp --permanent  因为在/usr/lib/firewalld/services/中事先定义了ssh.xml等相应的规则，所以可以直接运用规则\nfirewall-com --zone=public --add-server=ssh --permanent  systemctl是CentOS7的服务管理工具中主要的工具，它融合之前service和chkconfig的功能于一体。\n启动一个服务：systemctl start firewalld.service 关闭一个服务：systemctl stop firewalld.service 重启一个服务：systemctl restart firewalld.service 显示一个服务的状态：systemctl status firewalld.service 在开机时启用一个服务：systemctl enable firewalld.service 在开机时禁用一个服务：systemctl disable firewalld.service 查看服务是否开机启动：systemctl is-enabled firewalld.service 查看已启动的服务列表：systemctl list-unit-files|grep enabled 查看启动失败的服务列表：systemctl --failed  原文链接：https://www.jianshu.com/p/4a9958d2e859\n  ","description":"","id":13,"section":"blog","tags":["Firewall","centos8"],"title":"Firewall常用规则设置【转发】","uri":"http://www.shaochenfeng.com/blog/firewall%E5%B8%B8%E7%94%A8%E8%A7%84%E5%88%99%E8%AE%BE%E7%BD%AE/"},{"content":"从可配置性到安全性，从Web应用程序到大数据开发，无论您的应用程序需要什么样的基础框架，都有一个 Spring项目 可以帮助您构建它。从小着手并按需使用，因为Spring是为模块化设计的。\n——来自官网\n文章主要翻译自spring官方的项目介绍 https://spring.io/projects\n其中没翻译的就是我不知道怎么翻译比较好，看英文吧\n积极开发的项目 Spring Boot 以最通用的配置，以最快的速度让应用尽快可以运行\nSpring Framework 为依赖注入、事务管理、web应用、数据访问、消息传递等功能提供核心支持\nSpring Data 提供一致的接口去访问数据库——关系型、非关系型、map-reduce等\nSpring Cloud 提供一组用于分布式系统的常用工具，对于构建和部署微服务很有用\nSpring Cloud Data Flow An orchestration service for composable data microservice applications on modern runtimes.\nSpring Security 通过全面且可扩展的身份验证和授权支持保护您的应用程序\nSpring Session 提供了用于管理用户会话信息的API和实现。\nSpring Integration 通过轻量级消息传递和声明性适配器支持了著名的企业集成模式\nSpring HATEOAS 轻松创建遵循HATEOAS规则的REST\nSpring REST Docs 将手写文档与Spring MVC Test、REST Assured生成的自动文档结合起来，生成RESTful服务文档。\nSpring Batch 简化和优化处理批量生产的工作。\nSpring AMQP 将Spring核心理念应用于基于AMQP的消息传递应用的开发中\nSpring for Android 提供用于开发Android应用程序的关键Spring组件\nSpring Cloud Skipper 一个软件包管理器，可在多个云平台上安装，升级和回滚Spring Boot应用程序\nSpring CredHub 为Spring应用程序提供了CredHub上安全存储，生成，检索和删除各种类型凭据的API\nSpring Flo 一个JavaScript库， A JavaScript library that offers a basic embeddable HTML5 visual builder for pipelines and simple graphs.\nSpring for Apache Kafka Provides Familiar Spring Abstractions for Apache Kafka.\nSpring LDAP 使用Spring基于模板的方法简化使用LDAP的应用程序开发。\nSpring Mobile 通过设备检测和渐进式渲染简化移动Web应用程序的开发。\nSpring Roo 使您可以在几分钟内快速轻松地构建完整的Java应用程序\nSpring Shell 通过CLI交互，使编写和测试RESTful应用程序更加容易。\nSpring Statemachine 应用程序开发人员可以在Spring应用程序中使用状态机概念的框架\nSpring Vault Provides familiar Spring abstractions for HashiCorp Vault\nSpring Web Flow 用于构建有可控导航功能的web应用程序，如办理登机手续、申请贷款等\nSpring Web Services 用于创建文档驱动的SOAP服务\n束之高阁的项目 下面是已经推出但不再被官方维护的项目，就不翻译了\nSpring IO Platform Provides a cohesive, versioned platform for building modern applications. It is a modular, enterprise-grade distribution that delivers a curated set of dependencies.\nSpring Flex A project to make it easier to build Spring-powered Rich Internet Applications using Adobe Flex as the front-end client.\nSpring Integration Groovy DSL A Groovy based DSL for developing Spring Integration applications.\nSpring Integration Scala DSL A Scala based DSL for developing Spring Integration applications.\nSpring Scala A community run project that provides support for Spring framework development in Scala\nSpring Social Easily connects your applications with third-party APIs such as Facebook, Twitter, LinkedIn, and more.\nSpring XD Simplifies the development of big data applications by addressing ingestion, analytics, batch jobs and data export.\n","description":"","id":14,"section":"blog","tags":["java","web开发"],"title":"2020年Spring所有官方项目介绍","uri":"http://www.shaochenfeng.com/blog/2020%E5%B9%B4spring%E6%89%80%E6%9C%89%E5%AE%98%E6%96%B9%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D/"},{"content":" nginx Rtmp Module 是一个nginx插件，需要在在编译时和nginx一起编译安装，就可以利用nginx的转发能力进行直播了\n下载源码 首先准备好源码和常用编译工具（gcc之类的）\nmkdir /opt/git # 这里我偷懒直接把源码下载到这了，大家自行找地方 cd /opt/git git clone https://github.com/arut/nginx-rtmp-module.git # 下载 nginx-rtmp-module wget http://nginx.org/download/nginx-1.17.7.tar.gz # 下载nginx，这里用的最新测试版，推荐大家用稳定版 tar -zxvf nginx-1.17.7.tar.gz cd nginx-1.17.7/ ./configure --prefix=/opt/nginx1.17 --add-module=/opt/git/nginx-rtmp-module # 这里是重点，添加了一个mod make \u0026amp;\u0026amp; make install # 编译安装 cd /opt/nginx1.17/ vim /opt/nginx1.17/conf/nginx.conf # 开始配置 # 全部注释或删除 /opt/nginx1.17/conf/nginx.conf 中的配置  # 在配置的最高层，可以是开头或结尾，添加下面的包含 include rtmp.conf  编辑rtmp配置文件 vim /opt/nginx1.17/conf/rtmp.conf  添加如下配置\nrtmp { server { listen 8883; # 我使用的自定义端口，而不是标准的1935 application vod { play /opt/nginx1.17/video; } application live{ #第一处添加的直播字段，添加了一个live应用，里面可以有很多直播间 live on; } } } http { #include mime.types; #default_type application/octet-stream; #sendfile on; #keepalive_timeout 65; server { listen 8884; #用于查看直播状态和观看直播的web页面 server_name localhost; location /stat { # 状态查看页面实例 rtmp_stat all; rtmp_stat_stylesheet stat.xsl; } location /stat.xsl { root /opt/git/nginx-rtmp-module/; } location /control { rtmp_control all; } location /rtmp-publisher { root /opt/git/nginx-rtmp-module/test; } location / { # 直播观看页面实例 root /opt/git/nginx-rtmp-module/test/www; } error_page 500 502 503 504 /50x.html; location = /50x.html { root html; } } }  开启防火墙 firewall-cmd --add-port=8883/tcp firewall-cmd --add-port=8883/udp firewall-cmd --add-port=8884/tcp firewall-cmd --add-port=8884/udp  至此服务器搭建完成\n使用 obs推流到 rtmp://【ip地址】:8883/live\n在网页上查看推流情况 http://【ip地址】:8884/stat\n点播视频放在服务器的 /opt/nginx1.17/video 中\nvnc查看流，打开网络URL rtmp://【ip地址】:8883/live\n网页查看推流和点播视频，但是不会用 http://【ip地址】:8884\n","description":"","id":15,"section":"blog","tags":["nginx","直播"],"title":"初探用nginx Rtmp Module自建直播服务器","uri":"http://www.shaochenfeng.com/blog/%E5%88%9D%E6%8E%A2%E7%94%A8nginx-rtmp-module%E8%87%AA%E5%BB%BA%E7%9B%B4%E6%92%AD%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"content":"前言 手头上的服务器程序1.0版本终于要进入线上测试阶段了😮。兴致冲冲的分了一台公司的系统为CentOS7.+的服务器。1、部署上环境。2、打开终端开始跑程序 \u0026ldquo;nohup dotnet XXX.dll \u0026amp;\u0026ldquo;。3、关闭终端。。。4、卧槽😮,我的后台运行的程序呢!? 本人Linux小白,又尝试了几种后台运行程序的方案，全部以失败告终😭😭😭。 然后在搜索解决方案的过程中发现了很多守护进程工具的东西,最终找到了一个最简单的工具并学习使用了它, Supervisor 。\n进程管理工具(Supervisor) 简介 Supervisor是用Python开发的一个client/server服务，是Linux/Unix系统下的一个进程管理工具，不支持Windows系统。它可以很方便的监听、启动、停止、重启一个或多个进程。用Supervisor管理的进程，当一个进程意外被杀死，supervisort监听到进程死后，会自动将它重新拉起，很方便的做到进程自动恢复的功能，不再需要自己写shell脚本来控制。\n不使用守护进程会出现的三个问题：\n ASP.NET Core应用程序运行在shell之中，如果关闭shell则会发现 ASP.NET Core程序被关闭，从而导致应用无法访问，这种情况当然是我们不想遇到的，而且生产环境对这种情况是零容忍的。 如果 ASP.NET Core进程意外终止那么需要人为连进shell进行再次启动，往往这种操作都不够及时。 如果服务器宕机或需要重启，我们则还是需要连入shell进行启动。  为了解决这些问题，我们需要有一个程序来监听 ASP.NET Core 应用程序的状况。并在应用程序停止运行的时候立即重新启动。\nSupervisor安装与配置 1、安装Python包管理工具(easy_install) yum install python-setuptools 2、安装Supervisor easy_install supervisor 3、配置Supervisor应用守护 a) 通过运行echo_supervisord_conf程序生成supervisor的初始化配置文件，如下所示：\nmkdir /etc/supervisor echo_supervisord_conf \u0026gt; /etc/supervisor/supervisord.conf 然后查看路径下的supervisord.conf。在文件尾部添加如下配置。\n;conf.d 为配置表目录的文件夹，需要手动创建 [include] files = conf.d/*.conf  b) 为你的程序创建一个.conf文件，放在目录\u0026rdquo;/etc/supervisor/conf.d/\u0026ldquo;下。\n[program:MGToastServer] ;程序名称，终端控制时需要的标识 command=dotnet MGToastServer.dll ; 运行程序的命令 directory=/root/文档/toastServer/ ; 命令执行的目录 autorestart=true ; 程序意外退出是否自动重启 stderr_logfile=/var/log/MGToastServer.err.log ; 错误日志文件 stdout_logfile=/var/log/MGToastServer.out.log ; 输出日志文件 environment=ASPNETCORE_ENVIRONMENT=Production ; 进程环境变量 user=root ; 进程执行的用户身份 stopsignal=INT  c) 运行supervisord，查看是否生效\nsupervisord -c /etc/supervisor/supervisord.conf ps -ef | grep MGToastServer   ps: 如果服务已启动，修改配置文件可用“supervisorctl reload”命令来使其生效\n 4、配置Supervisor开机启动 a) 新建一个“supervisord.service”文件\n# dservice for systemd (CentOS 7.0+) # by ET-CS (https://github.com/ET-CS) [Unit] Description=Supervisor daemon [Service] Type=forking ExecStart=/usr/bin/supervisord -c /etc/supervisor/supervisord.conf ExecStop=/usr/bin/supervisorctl shutdown ExecReload=/usr/bin/supervisorctl reload KillMode=process Restart=on-failure RestartSec=42s [Install] WantedBy=multi-user.target  b) 将文件拷贝至\u0026rdquo;/usr/lib/systemd/system/supervisord.service\u0026rdquo;\nc) 执行命令\nsystemctl enable supervisord  d) 执行命令来验证是否为开机启动\nsystemctl is-enabled supervisord  配置完成啦. 常用的相关管理命令\nsupervisorctl restart \u0026lt;application name\u0026gt; ;重启指定应用 supervisorctl stop \u0026lt;application name\u0026gt; ;停止指定应用 supervisorctl start \u0026lt;application name\u0026gt; ;启动指定应用 supervisorctl restart all ;重启所有应用 supervisorctl stop all ;停止所有应用 supervisorctl start all ;启动所有应用  来源：https://www.jianshu.com/p/39b476e808d8\n","description":"","id":16,"section":"blog","tags":["转载","Supervisor"],"title":"Supervisor-守护进程工具【转载】","uri":"http://www.shaochenfeng.com/blog/supervisor-%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B%E5%B7%A5%E5%85%B7%E8%BD%AC%E8%BD%BD/"},{"content":" Apache httpd和php的结合方式有两种： * DSO方式，php作为httpd的模块 * FCGI方式，使用php-fpm单独管理php进程池\nyum方式安装httpd和php centos8\ndnf install httpd dnf install php  默认是php7.2版本\ncentos7\nyum install httpd yum install php  默认是php5.4版本\n这会自动为httpd安装php插件，并启用，使用OSO方式运行php，也就是php作为httpd的模块 默认为每个网站都配置了php的支持，直接就能可以使用\n测试一下 创建测试文件\necho -e \u0026quot;\u0026lt;?php\\nphpinfo();\\n?\u0026gt;\u0026quot;\u0026gt; /var/www/html/index.php echo -e \u0026quot;\u0026lt;?php\\nphpinfo();\\n?\u0026gt;\u0026quot;\u0026gt; /usr/share/nginx/html/index.php  这样就可以通过 http://\u0026lt;你的服务器ip\u0026gt; 访问下\n源码方式安装php7.3 环境 centos8\n1.首先安装 httpd 和 httpd-devel 这里安装httpd-devel是为了使用apxs动态加载插件\ndnf install httpd httpd-devel  2.安装必要的依赖 dnf install libxml2-devel openssl-devel libcurl libcurl-devel libjpeg-turbo-devel libpng-devel freetype-devel libzip-devel gcc make  3.下载php源码包 wget https://www.php.net/distributions/php-7.3.13.tar.xz  4.解压、编译、安装 cd php-7.3.13 tar xvf php-7.3.13.tar.xz ./configure --prefix=/opt/php7.3 --with-apxs2=/usr/bin/apxs --with-config-file-path=/opt/php7.3/usr --enable-mbstring --with-openssl --enable-ftp --with-gd --with-jpeg-dir=/opt/php7.3/usr --with-png-dir=/opt/php7.3/usr --with-mysqli=mysqlnd --with-pdo-mysql=mysqlnd --with-pear --enable-sockets --with-freetype-dir=/opt/php7.3/usr --with-zlib --with-libxml-dir=/opt/php7.3/usr --with-xmlrpc --enable-zip --enable-fpm --enable-xml --enable-sockets --with-gd --with-zlib --with-iconv --enable-zip --with-freetype-dir=/opt/php7.3/usr/lib --enable-soap --enable-pcntl --enable-cli --with-curl --enable-bcmath --with-gettext make \u0026amp;\u0026amp; make install   这里使用 --prefix=/opt/php7.3 安装在 /opt/php7.3 ，可以自定义安装位置\n这里使用 --with-apxs2=/usr/bin/apxs 指出了apxs的位置，如果是源码安装的httpd，则在安装目录下的 ./sbin/apxs\n 5.复制配置文件 cp php.ini-development /opt/php7.3/php.ini\n6.配置httpd使用php cd httpd.conf\nLoadModule php7_module\tmodules/libphp7.so # 有可能已经自动添加了  ","description":"","id":17,"section":"blog","tags":["php","httpd","centos8"],"title":"Apache httpd结合php，yum方式和源码方式","uri":"http://www.shaochenfeng.com/blog/apache_httpd%E5%92%8Cphp/"},{"content":" 1.安装jdk tomcat9可以工作在jdk8及之后的版本\n所以可以安装jdk8或是jdk11\ndnf install java-11-openjdk # centos8 yum install java-11-openjdk # centos7  2.下载最新的tomcat二进制包 打开网站 https://mirrors.tuna.tsinghua.edu.cn/apache/tomcat/tomcat-9/\n在这里找到最新版本，进入后进入bin目录\n里面有名为 apache-tomcat-XXXX.tar.gz 的文件，右键复制地址\n下载并解压\nwget https://mirrors.tuna.tsinghua.edu.cn/apache/tomcat/tomcat-9/v9.0.31/bin/apache-tomcat-9.0.31.tar.gz tar xvf apache-tomcat-9.0.31.tar.gz  移动到安装目录\nmv apache-tomcat-9.0.31 /opt/tomcat9  3.常见命令和目录    命令或目录 作用     /opt/tomcat9/bin/startup.sh 启动tomcat   /opt/tomcat9/bin/shutdown.sh 关闭tomcat   /opt/tomcat9/conf/ 配置   /opt/tomcat9/logs/ 日志   /opt/tomcat9/webapps/ 默认应用目录    4.如何选择tomcat版本 下面表格来自tomcat官网\n   Servlet 规范 JSP 规范 EL 规范 WebSocket 规范 JASPIC 规范 Apache Tomcat 版本 最新版本（2020.2.19） 支持的 Java 版本     4.0 2.3 3.0 1.1 1.1 9.0.x 9.0.31 8 and later   3.1 2.3 3.0 1.1 1.1 8.5.x 8.5.51 7 and later   3.1 2.3 3.0 1.1 N/A 8.0.x (superseded) 8.0.53 (superseded) 7 and later   3.0 2.2 2.2 1.1 N/A 7.0.x 7.0.100 6 and later (7 and later for WebSocket)   2.5 2.1 2.1 N/A N/A 6.0.x (archived) 6.0.53 (archived) 5 and later   2.4 2.0 N/A N/A N/A 5.5.x (archived) 5.5.36 (archived) 1.4 and later   2.3 1.2 N/A N/A N/A 4.1.x (archived) 4.1.40 (archived) 1.3 and later   2.2 1.1 N/A N/A N/A 3.3.x (archived) 3.3.2 (archived) 1.1 and later    ","description":"","id":18,"section":"blog","tags":["java","tomcat"],"title":"Centos8(7)安装tomcat9和常见用法","uri":"http://www.shaochenfeng.com/blog/centos87%E5%AE%89%E8%A3%85tomcat9%E5%92%8C%E5%B8%B8%E8%A7%81%E7%94%A8%E6%B3%95/"},{"content":"httpd(apache)以其功能丰富，安全稳定，广为使用\n安装httpd 对于CentOS8:\ndnf -y install httpd  对于CentOS7:\nyum -y install httpd  如果出错检查检查一下网络和yum源，如何更换yum源到阿里源\n下面设置两个虚拟主机 虚拟主机可以让一个web服务器服务多个网站，每个网站可以有不同的设置，不同的语言，并且有独立的日志\n这里假设两个主机分别为\n game.shaochenfeng.com map.shaochenfeng.com  新建配置文件 注意要以conf为扩展名\nvim /etc/httpd/conf.d/virtual.conf  内容为\n\u0026lt;VirtualHost *:80\u0026gt; ServerName game.shaochenfeng.com DocumentRoot /var/www/game.shaochenfeng.com DirectoryIndex index.html ErrorLog logs/game.shaochenfeng.com.error.log TransferLog logs/game.shaochenfeng.com.log \u0026lt;/VirtualHost\u0026gt; \u0026lt;Directory \u0026quot;/var/www/game.shaochenfeng.com\u0026quot;\u0026gt; Require all granted \u0026lt;/Directory\u0026gt; \u0026lt;VirtualHost *:80\u0026gt; ServerName map.shaochenfeng.com DocumentRoot /var/www/map.shaochenfeng.com DirectoryIndex index.html ErrorLog logs/map.shaochenfeng.com.error.log TransferLog logs/map.shaochenfeng.com.log \u0026lt;/VirtualHost\u0026gt; \u0026lt;Directory \u0026quot;/var/www/map.shaochenfeng.com\u0026quot;\u0026gt; Require all granted \u0026lt;/Directory\u0026gt;  其中第一行中的 \u0026lt;VirtualHost *:80\u0026gt; 指定了监听的端口和主机范围 * ServerName 监听的域名 * DocumentRoot 网站根目录 * DirectoryIndex 网站默认文档 * ErrorLog 错误日志 * TransferLog 访问日志\n后面一部分 \u0026lt;Directory \u0026quot;/var/www/game.shaochenfeng.com\u0026quot;\u0026gt; 对网站目录进行设置\n保存并退出\n创建虚拟主机的主目录和日志目录 mkdir /var/www/game.shaochenfeng.com mkdir /var/www/map.shaochenfeng.com #将你的网站文件复制到上面对应的目录 chown apache:apache -R /var/www/game.shaochenfeng.com # httpd运行在apache用户下，所以要给网站文件授予权限 chown apache:apache -R /var/www/map.shaochenfeng.com  启动并开机启动httpd systemctl enable httpd # 设置httpd开机启动 systemctl start httpd # 启动httpd systemctl status httpd # 查看httpd状态 ","description":"","id":19,"section":"blog","tags":["apache","httpd","yum","centos"],"title":"Yum安装httpd(apache)并设置虚拟主机","uri":"http://www.shaochenfeng.com/blog/yum%E5%AE%89%E8%A3%85httpdapache%E5%B9%B6%E8%AE%BE%E7%BD%AE%E8%99%9A%E6%8B%9F%E4%B8%BB%E6%9C%BA/"},{"content":"首先是全部步骤概括 yum install -y libaio ncurses gcc gcc-c++ cmake ncurses-devel wget yum install -y pcre-devel zlib-devel wget http://nginx.org/download/nginx-1.16.1.tar.gz # 下载源码包 tar -zxvf nginx-1.16.1.tar.gz cd nginx-1.16.1 ./configure --prefix=/opt/nginx1.16 # 这里指定安装目录 make \u0026amp;\u0026amp; make install useradd www -s /bin/false vi /opt/nginx1.16/conf/nginx.conf # 修改配置文件 # 第一行去掉前面井号并改为 user www; /opt/nginx1.16/sbin/nginx #启动nginx #以下为可选 /opt/nginx1.16/sbin/nginx -s stop #停止 /opt/nginx1.16/sbin/nginx -s reload #重新载入配置  1.安装编译器和依赖 yum install libaio ncurses gcc gcc-c++ cmake ncurses-devel wget yum install pcre-devel zlib-devel  这些依赖是编译nginx需要的，否则无法完成编译\n2.下载源码包并解压 wget http://nginx.org/download/nginx-1.16.1.tar.gz # 下载源码包 tar -zxvf nginx-1.16.1.tar.gz cd nginx-1.16.1  3.编译安装 ./configure --prefix=/opt/nginx1.16 # 这里指定安装目录 make \u0026amp;\u0026amp; make install  在编译之前可以制定安装目录，这样所有的数据、配置、程序都会放到这个目录下\n也可以不指定，如下所示\n./configure make \u0026amp;\u0026amp; make install  这样会安装到默认位置\n4.添加nginx使用的用户 useradd www -s /bin/false vi /opt/nginx1.16/conf/nginx.conf # 修改配置文件 # 第一行去掉前面井号并改为 user www;  nginx默认不使用root用户运行网站的脚本，而是使用nobody，因为一旦执行恶意脚本，后果很严重\n但是nobidy的权限很小，我们通常会新建一个nginx用户或是www用户，当作nginx使用的用户\n5.启动和重启 /opt/nginx1.16/sbin/nginx #启动nginx /opt/nginx1.16/sbin/nginx -s stop #停止 /opt/nginx1.16/sbin/nginx -s reload #重新载入配置 ","description":"","id":20,"section":"blog","tags":["nginx"],"title":"源码安装nginx到指定目录","uri":"http://www.shaochenfeng.com/blog/%E6%BA%90%E7%A0%81%E5%AE%89%E8%A3%85nginx%E5%88%B0%E6%8C%87%E5%AE%9A%E7%9B%AE%E5%BD%95/"},{"content":"https是加密的http协议，现在以谷歌浏览器为首的很多浏览器开始将仅支持http的网站标识为不安全\n所以全站https就成为了现代网站的标配，本文介绍ngnix如何配置ssl证书，以支持https\n首先在准备申请来的证书文件[如何申请?]()\n这里假设ssl证书放在\n /usr/share/nginx/ssl/www.shaochenfeng.com.cer; /usr/share/nginx/ssl/www.shaochenfeng.com.key;  编辑nginx配置文件\nvim /etc/nginx/nginx.conf  找到下面被注释的ssl配置，全部取消注释\n开始可能是这样\n改成这样\n主要就是改了红框中的两个参数 * ssl_certificate 证书 * ssl_certificate_key 证书密钥\n然后重启nginx生效\n如果不想在主配置中添加，可以在虚拟主机配置中为每个网站单独配置\n实例文件如下\nserver { listen 80; listen 443 ssl; server_name www.shaochenfeng.com; root /usr/share/nginx/www.shaochenfeng.com; ssl on; ssl_certificate /usr/share/nginx/ssl/www.shaochenfeng.com.cer; ssl_certificate_key /usr/share/nginx/ssl/www.shaochenfeng.com.key; location / { } } ","description":"","id":21,"section":"blog","tags":["https","nginx"],"title":"Nginx配置ssl证书，支持https","uri":"http://www.shaochenfeng.com/blog/nginx%E9%85%8D%E7%BD%AEssl%E8%AF%81%E4%B9%A6%E6%94%AF%E6%8C%81htts/"},{"content":"CentOS7默认安装MariaDB，安装mysql5.7就需要添加mysql官方yum源\n1. 下载官方yum源 首先需要下载官方yum源\nwget https://repo.mysql.com/mysql57-community-release-el7.rpm  2.安装yum源 yum -y install mysql57-community-release-el7.rpm  3.安装mysql服务器 一切准备就绪，现在可以安装mysql服务器了\nyum -y install mysql-community-server  4. 启动服务 现在使用 systemctl 启动mysql守护进程\nsystemctl start mysqld  第一次启动mysql会初始化数据库，所以需要点时间\n5. 查看root密码 初始化数据库的时候会为root设置一个默认密码，这个密码在log文件中可以找到\nless /var/log/mysqld.log # 查看日志查看密码 # 会有一行 password is generated XXXXX  或者可以使用下面语句直接提取出密码\ngrep \u0026quot;password is generated\u0026quot; /var/log/mysqld.log | awk '{print $NF}'  找到密码后可以用以下命令输入密码进入数据库\nmysql -uroot -p  第一次进入数据库只能修改密码，不能做任何事\nmysql\u0026gt; ALTER USER 'root'@'localhost' IDENTIFIED BY 'new password';  这里的新密码不能太简单，因为mysql默认对密码有复杂度要求\n可以通过下面命令关闭复杂度要求\nmysql\u0026gt; set global validate_password_policy=0; # 关闭密码复杂性策略 mysql\u0026gt; set global validate_password_length=4; # 设置密码最低长度为4 ","description":"","id":22,"section":"blog","tags":["mysql5.7","CentOS7"],"title":"yum安装mysql5.7，查看默认root密码","uri":"http://www.shaochenfeng.com/blog/yum%E5%AE%89%E8%A3%85mysql5.7%E6%9F%A5%E7%9C%8B%E9%BB%98%E8%AE%A4root%E5%AF%86%E7%A0%81/"},{"content":" 1. 下载官方yum源 CentOS8默认源安装的就是mysql8 跳过这一步，去第三步\nCentOS7默认安装MariaDB，安装mysql8就需要添加mysql官方yum源\n首先需要下载官方yum源\nwget https://repo.mysql.com/mysql80-community-release-el7.rpm # 仅CentOS7  2.安装yum源 yum -y install mysql80-community-release-el7.rpm # 仅CentOS7  3.安装mysql服务器 一切准备就绪，现在可以安装mysql服务器了\n对于CentOS8:\ndnf -y install mysql-server  对于CentOS7:\nyum -y install mysql-community-server  4. 启动服务 现在使用 systemctl 启动mysql守护进程\nsystemctl start mysqld  第一次启动mysql会初始化数据库，所以需要点时间\n对于CentOS8，从默认源安装mysql8没有密码，可以直接mysql进入使用\n对于CentOS7,从官方源安装会生成默认密码，可以通过后面的步骤查看密码并修改\n5. 查看root密码 初始化数据库的时候会为root设置一个默认密码，这个密码在log文件中可以找到\nless /var/log/mysqld.log # 查看日志查看密码 # 会有一行 password is generated XXXXX  或者可以使用下面语句直接提取出密码\ngrep \u0026quot;password is generated\u0026quot; /var/log/mysqld.log | awk '{print $NF}'  找到密码后可以用以下命令输入密码进入数据库\nmysql -uroot -p  第一次进入数据库只能修改密码，不能做任何事\nmysql\u0026gt; ALTER USER 'root'@'localhost' IDENTIFIED BY 'new password';  这里的新密码不能太简单，因为mysql默认对密码有复杂度要求\n可以通过下面命令关闭复杂度要求\nshow global variables like '%validate_password%'; mysql\u0026gt; set global validate_password.policy=0; # 关闭密码复杂性策略 mysql\u0026gt; set global validate_password.length=4; # 设置密码最低长度为4  ","description":"","id":23,"section":"blog","tags":["mysql8","CentOS"],"title":"yum安装mysql8，查看默认root密码","uri":"http://www.shaochenfeng.com/blog/yum%E5%AE%89%E8%A3%85mysql8%E6%9F%A5%E7%9C%8B%E9%BB%98%E8%AE%A4root%E5%AF%86%E7%A0%81/"},{"content":"sed可以按照指令或脚本编辑文本的linux工具，文本处理功能非常强大，本文总结一些工作中常用的sed模板，方便大家使用\n替换 1. 替换文件中所有的 aaa 到 bbb sed -i 's/aaa/bbb/g' /path/to/file  2. 找到文件的修改日期 stat deploy | sed -n '/^Modify.*/p' # 找到 stat deploy | sed -n '/^Modify.*/p' | grep -Eo \u0026quot;....-..-.. ..:..:..\u0026quot; # 提取出修改起义  2. 找到 aaa 参数，并设置为off sed -i '/^aaa/s/on/off/' /path/to/file  可以配合grep使用，完成自动设置参数\nhave_aaa=$(grep aaa /path/to/file | sed '/^#.*/d') # 寻找是否以存在aaa参数 if [ ! -z $have_aaa ];then # 如果存在 sed -i '/^aaa/s/on/off/' /path/to/file # 则修改为off else # 如果不存在 sed -i '/ccc/a aaa off' /path/to/file # 则在ccc参数下新增 aaa off # sed -i '$a/aaa off' /path/to/file # 则在最后新增 aaa off fi  滤掉所有注释行 cat /etc/my.cnf | sed '/^#.*/d'  找到并删除 找到包含aaa的行并删除\nsed -i '/aaa/d' /path/to/file  插入追加  a/ 在当前行下面插入; i/ 在当前行上面插入; c/ 把当前行改为新的;  在ccc开头的行下面插入 something\nsed -i '/^ccc/a something' /path/to/file  在ccc开头的行后追加 something\nsed -i '/^ccc/s/$/something/' /path/to/file  在ccc后紧接着追加something\nsed -i 's/ccc/\u0026amp;something/' /path/to/file ","description":"","id":24,"section":"blog","tags":["sed","linux命令"],"title":"sed常用模板整理","uri":"http://www.shaochenfeng.com/blog/sed%E5%B8%B8%E7%94%A8%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/"},{"content":"有时我们会使用一些java或node应用，但又不想让他们直接监听80端口，这时就需要用到端口转发\n本文中，我们介绍Nginx如何做端口转发，还有各种转发规则\n将域名转发到本地端口 首先介绍最常用的，将域名转发到本地另一个端口上\nserver{ listen 80; server_name tomcat.shaochenfeng.com; index index.php index.html index.htm; location / { proxy_pass http://127.0.0.1:8080; # 转发规则 proxy_set_header Host $proxy_host; # 修改转发请求头，让8080端口的应用可以受到真实的请求 proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; } }  这样访问 http://tomcat.shaochenfeng.com 时就会转发到本地的 8080 端口\n将域名转发到另一个域名 server{ listen 80; server_name baidu.shaochenfeng.com; index index.php index.html index.htm; location / { proxy_pass http://www.baidu.com; proxy_set_header Host $proxy_host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; } }  这样访问 http://baidu.shaochenfeng.com 时就会转发到 http://www.baidu.com\n本地一个端口转发到另一个端口或另一个域名 server{ listen 80; server_name 127.0.0.1; # 公网ip index index.php index.html index.htm; location / { proxy_pass http://127.0.0.1:8080; # 或 http://www.baidu.com proxy_set_header Host $proxy_host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; } }  这样访问 http://127.0.0.1 时就会转发到本地的 8080 端口或 http://www.baidu.com\n加 / 与不加 / 在配置proxy_pass代理转发时，如果后面的url加/，表示绝对根路径；如果没有/，表示相对路径\n例如\n 加 /\nserver_name shaochenfeng.com location /data/ { proxy_pass http://127.0.0.1/; }  访问 http://shaochenfeng.com/data/index.html 会转发到 http://127.0.0.1/index.html\n 不加 /\nserver_name shaochenfeng.com location /data/ { proxy_pass http://127.0.0.1; }  访问 http://shaochenfeng.com/data/index.html 会转发到 http://127.0.0.1/data/index.html\n ","description":"","id":25,"section":"blog","tags":["端口转发","nginx"],"title":"Nginx端口转发（反向代理）","uri":"http://www.shaochenfeng.com/blog/nginx%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/"},{"content":"整个网站通常会很大，尤其的其中静态的图片视频之类，但我们通常不会修改他们，平常只会修改几个文件，如果每次更新都将整个网站从本地上传到服务器，无疑很费时间，如果要找到修改的文件，并只上传这些文件，甚至只上传这些文件修改的部分，无疑会方便很多。\n这就要用的到今天的主角*Rsync*，Rsync 可以执行增量备份，它只传输源文件和目标文件之间不一致的部分\n环境： web服务器root目录 /usr/share/nginx/game.shaochenfeng.com 本地项目目录 /git/game.shaochenfeng.com/public\n首先建议配置好本地到web服务器的ssh免密码登陆[如何？]()，不配置需要以后每次同步时输入密码\n1.在web服务器端安装rsync 直接yum或apt安装就可以，在服务器端和本地都安装\nyum install rsync # 红帽系 apt install rsync # Debian系  为什么要在服务器也安装rsync呢？因为虽然是通过ssh建立链接，但rsync使用的是自己的传输规则，而不是scp\n2.向服务器推送 在本地执行，同步 本地项目目录 到 web服务器root目录\nrsync -avz --delete \u0026lt;本地路径\u0026gt; www@192.168.56.10:\u0026lt;远程路径\u0026gt; rsync -avz --delete /git/game.shaochenfeng.com/public www@192.168.56.10:/usr/share/nginx/game.shaochenfeng.com  其中参数 * -a 是递归传输并保持文件属性，在传输带有文件夹时使用，并保留文件的属性 * -v 显示传输过程 * -z 进行压缩传输，提高效率 * \u0026ndash;delete 本地删除的文件，在服务器也会被删除\n附上rsync常用选项 -a 包含-rtplgoD\n-r 递归传输 同步有文件夹时使用\n-v 显示传输过程\n-l 保留软连接\n-p 保持权限属性\n-o 保持属主\n-g 保持属组\n-D 保持设备文件信息\n-t 保持文件的时间属性，这个一定要有，不然下次同步不能判断那些文件发生了修改\n\u0026ndash;backup 对服务器已存在的文件做一个备份，备份的文件名后默认使用\u0026rdquo;~\u0026ldquo;做后缀\n\u0026ndash;delete 本地删除的文件，在服务器也会被删除\n\u0026ndash;exclude 过滤指定文件，如\u0026ndash;exclude “logs”会把文件名包含logs的文件或者目录过滤掉，不同步\n-P 显示同步过程，比如速率，比-v更加详细\n-u 加上该选项后，如果DEST中的文件比SRC新，则不同步\n\u0026ndash;size-only 默认算法会检查修改时间和文件大小，加上这个只检查文件大小\n-z 进行压缩传输，提高效率\n-h \u0026ndash;progress 同步了那些文件和进度过程\n","description":"","id":26,"section":"blog","tags":["部署","Rsync"],"title":"用Rsync,实现网站的增量部署","uri":"http://www.shaochenfeng.com/blog/%E7%94%A8rsync%E5%AE%9E%E7%8E%B0%E7%BD%91%E7%AB%99%E7%9A%84%E5%A2%9E%E9%87%8F%E9%83%A8%E7%BD%B2/"},{"content":"点击打开PDF,有书签\n","description":"","id":27,"section":"blog","tags":["官方文档","转载"],"title":"红帽8发行版说明PDF","uri":"http://www.shaochenfeng.com/blog/%E7%BA%A2%E5%B8%BD8%E5%8F%91%E8%A1%8C%E7%89%88%E8%AF%B4%E6%98%8Epdf/"},{"content":"1.首先备份当前配置文件 mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup  2.下载新的 CentOS-Base.repo 到 /etc/yum.repos.d 对于CentOS8\nwget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-8.repo  对于CentOS7\nwget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo  3. 运行 yum makecache 生成缓存 yum makecache ","description":"","id":28,"section":"blog","tags":["centos","yum"],"title":"2020年CentOS8(7)更换yum源为阿里源","uri":"http://www.shaochenfeng.com/blog/2020%E5%B9%B4centos87%E6%9B%B4%E6%8D%A2yum%E6%BA%90%E4%B8%BA%E9%98%BF%E9%87%8C%E6%BA%90/"},{"content":"nginx是最近非常火的web服务器，这次CentOS8也在yum官方源中新增了nginx 1.14\n与Apache相比可以承担更大的并发，并占用更少的内存\nCentOS8使用了新一代的yum，使用dnf作为命令（原来的yum以dnf的软链接形式存在）\n安装只需要一句 dnf install nginx -y  如果出错检查检查一下网络和yum源，如何更换yum源到阿里源\n下面设置两个虚拟主机 虚拟主机可以让一个web服务器服务多个网站，每个网站可以有不同的设置，不同的语言，并且有独立的日志\n这里假设两个主机分别为\n game.shaochenfeng.com map.shaochenfeng.com  首先编辑nginx的主配置文件，如果虚拟主机很多的话，应该写到多个配置文件中(如何？)\nvim /etc/nginx/nginx.conf  可以看到里面有个默认网站，不用管它，在红色箭头处插入两个网站的配置\nserver { listen 80; listen [::]:80; access_log /usr/share/nginx/log/game.shaochenfeng.com; error_log /usr/share/nginx/log/game.shaochenfeng.com.err error; server_name game.shaochenfeng.com; root /usr/share/nginx/game.shaochenfeng.com; location / { } } server { listen 80; listen [::]:80; access_log /usr/share/nginx/log/map.shaochenfeng.com; error_log /usr/share/nginx/log/map.shaochenfeng.com.err error; server_name map.shaochenfeng.com; root /usr/share/nginx/map.shaochenfeng.com; location / { } }  保存并退出 下面创建虚拟主机的主目录和日志目录\nmkdir /usr/share/nginx/game.shaochenfeng.com # 创建虚拟主机的主目录和日志目录 mkdir /usr/share/nginx/map.shaochenfeng.com #将你的网站文件复制到上面对应的目录 mkdir /usr/share/nginx/log chown nginx:nginx -R /usr/share/nginx/game.shaochenfeng.com # nginx运行在nginx用户下，所以要给网站文件授予权限 chown nginx:nginx -R /usr/share/nginx/map.shaochenfeng.com  启动并开机启动nginx\nsystemctl enable nginx # 设置nginx开机启动 systemctl start nginx # 启动nginx systemctl status nginx # 查看nginx状态  这样， 当访问game.shaochenfeng.com时就会得到/usr/share/nginx/game.shaochenfeng.com/index.html 当访问map.shaochenfeng.com时就会得到/usr/share/nginx/map.shaochenfeng.com/index.html\n","description":"","id":29,"section":"blog","tags":["虚拟主机","nginx","Centos8"],"title":"Centos8 Yum安装nginx并设置虚拟主机","uri":"http://www.shaochenfeng.com/blog/centos8yum%E5%AE%89%E8%A3%85nginx%E5%B9%B6%E8%AE%BE%E7%BD%AE%E8%99%9A%E6%8B%9F%E4%B8%BB%E6%9C%BA/"},{"content":"Markdown here\n","description":"test post","id":30,"section":"docs","tags":null,"title":"Related content","uri":"http://www.shaochenfeng.com/docs/relatedcontent/"},{"content":"Markdown here\n","description":"test post","id":31,"section":"docs","tags":null,"title":"Page Resources","uri":"http://www.shaochenfeng.com/docs/pageresources/"},{"content":"Markdown here\n","description":"test post","id":32,"section":"docs","tags":null,"title":"Page Bundles","uri":"http://www.shaochenfeng.com/docs/pagebundles/"},{"content":"Markdown here\n","description":"test post","id":33,"section":"docs","tags":null,"title":"Content Formats","uri":"http://www.shaochenfeng.com/docs/contentfortmats/"},{"content":"Markdown here\n","description":"test post","id":34,"section":"docs","tags":null,"title":"Image Processing","uri":"http://www.shaochenfeng.com/docs/imageprocessing/"},{"content":"Markdown here\n","description":"test post","id":35,"section":"docs","tags":null,"title":"Shortcodes","uri":"http://www.shaochenfeng.com/docs/contentmanagement/shortcodes/"},{"content":"Markdown here\n","description":"test post","id":36,"section":"docs","tags":null,"title":"Frontmatter","uri":"http://www.shaochenfeng.com/docs/contentmanagement/frontmatter/"},{"content":"本文将介绍 C语言标准库 中的 宏、函数、数据类型 在最后给出一个实例程序，尽可能运用到所有函数\n宏 EXIT_SUCCESS 和 EXIT_FAILURE exit函数成功退出和失败的返回值\n#define EXIT_SUCCESS\t0 #define EXIT_FAILURE\t1  RAND_MAX rand 函数返回的最大的数 #define RAND_MAX\t0x7FFF  MB_CUR_MAX 一个多字节字符的最大字节数 源码处理的比较复杂\n函数 将字符串转换为 double double atof (const char *);  将字符串转换为 int int atoi (const char *);  将字符串转换为 long int long atol (const char *);  将以数字开头的字符串转换为 double str 是一个以数字开头的字符串， 返回把 str 转换后的 double ， endptr 指向第一个不是数字的字符\ndouble strtod(const char *str, char **endptr)  将以数字开头的字符串转换为 long int str 是一个以数字开头的字符串， 返回把 str 以 base 为基数（进制）转换后的 long int ， endptr 指向第一个不是数字的字符\nlong int strtol(const char *str, char **endptr, int base)  str 是一个以数字开头的字符串， 返回把 str 以 base 为基数 转换后的 unsigned long int ， endptr 指向第一个不是数字的字符\nunsigned long int strtoul(const char *str, char **endptr, int base)  分配请求的内存大小(nitems * size)并返回指向它的指针 void *calloc(size_t nitems, size_t size)  分配请求的内存(size)并返回指向它的指针 void *malloc(size_t size)  调整之前分配的内存块大小  ptr 执行要调整的内存块 size 要调整到的字节数\nvoid *realloc(void *ptr, size_t size)   回收先前分配的内存 void free(void *ptr)  搜索环境变量并返回字符串 char *getenv(const char *name)  把命令(string)传递给主机由主机执行 int system(const char *string)  快速排序  base是数组的基地址 nitems是数组的元素个数 size是数组元素大小 compar是比较函数，靠返回值正负来比较，为0的情况未定义\nvoid qsort(void *base, size_t nitems, size_t size, int (*compar)(const void *, const void*))   二分查找  key是要查找的元素 base是数组的基地址 num是数组的元素个数 size数组元素大小 cmp是比较函数，靠返回值正负来比较，数组必须是排好序的 返回找到的元素的指针\nvoid *bsearch(const void *key, const void *base, size_t num, size_t size, int (*cmp)(const void *, const void *));   返回x的绝对值 int abs(int x) long int labs(long int x)  做除法，分别得到除数和被除数 div_t div(int numer, int denom) ldiv_t ldiv(long int numer, long int denom)  返回一个随机数，范围(0~RAND_MAX) int rand(void)  对随机函数设置种子 void srand(unsigned int seed)  计算一个多字节字符的长度  n 是多字节字符的长度的最大值\nint mblen(const char *str, size_t n)   多字节字符串转换为数组 将由参数str指向的多字节字符串转换为由pwcs指向的数组 * n 是多字节字符的长度的最大值\nsize_t mbstowcs(schar_t *pwcs, const char *str, size_t n)  在程序正常退出时执行  func 要执行的函数\nint atexit(void (*func)(void))  程序异常退出 void abort(void)  程序正常退出 ,返回给操作系统 status void exit(int status)  数据类型  size_t是sizeof关键词的值，无符号整形 wchar_t 宽字符类型 div_t与ldiv_t结构体 作为 div 的返回值 typedef struct { int quot; // 商 int rem; // 余数 } div_t; //------------------------------- typedef struct { long int quot; // 商 long int rem; // 余数 } ldiv_t;  示例文件 Github\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; void test(){ printf(\u0026quot;do this at exit\\n\u0026quot;); } int cmptest(const void * a, const void * b){ return (int)( *(char*)a - *(char*)b ); } int main (){ /// /// ## 数据类型 /// /// ### size_t是sizeof关键词的值，无符号整形 printf(\u0026quot;size_t %d\\n\u0026quot;,sizeof(size_t)); /// ### wchar_t 宽字符类型 printf(\u0026quot;wchar_t %d\\n\u0026quot;,sizeof(wchar_t)); /// ### div_t与ldiv_t结构体 作为 div 的返回值 /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c /// typedef struct { /// int quot; // 商 /// int rem; // 余数 /// } div_t; div_t div_t_timp; printf(\u0026quot;div_t %d div_t.quot %d div_t.rem %d\\n\u0026quot;, sizeof(div_t),sizeof(div_t_timp.quot),sizeof(div_t_timp.rem)); /// //------------------------------- /// typedef struct { /// long int quot; // 商 /// long int rem; // 余数 /// } ldiv_t; /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ldiv_t ldiv_t_timp; printf(\u0026quot;ldiv_t %d ldiv_t.quot %d ldiv_t.rem %d\\n\u0026quot;, sizeof(ldiv_t),sizeof(ldiv_t_timp.quot),sizeof(ldiv_t_timp.rem)); /// /// ## 宏 /// /// ### EXIT_SUCCESS 和 EXIT_FAILURE /// exit函数成功退出和失败的返回值 /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c /// #define EXIT_SUCCESS\t0 /// #define EXIT_FAILURE\t1 /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ printf(\u0026quot;EXIT_SUCCESS %d\\nEXIT_FAILURE %d\\n\u0026quot;,EXIT_SUCCESS,EXIT_FAILURE); /// ### RAND_MAX rand 函数返回的最大的数 /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c /// #define RAND_MAX\t0x7FFF /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ printf(\u0026quot;RAND_MAX %d\\n\u0026quot;,RAND_MAX); /// ### MB_CUR_MAX 一个多字节字符的最大字节数 /// 头文件中的处理比较复杂 printf(\u0026quot;MB_CUR_MAX %d\\n\u0026quot;,MB_CUR_MAX); /// /// ## 函数 /// /// ### 将字符串转换为 double /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c /// double atof (const char *); /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ printf(\u0026quot;atof(\\\u0026quot;12.3\\\u0026quot;) %f\\n\u0026quot;,atof(\u0026quot;12.3\u0026quot;)); /// ### 将字符串转换为 int /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c /// int atoi (const char *); /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ printf(\u0026quot;atoi(\\\u0026quot;12\\\u0026quot;) %d\\n\u0026quot;,atoi(\u0026quot;12\u0026quot;)); /// ### 将字符串转换为 long int /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c /// long atol (const char *); /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ printf(\u0026quot;atol(\\\u0026quot;123456789\\\u0026quot;) %ld\\n\u0026quot;,atol(\u0026quot;123456789\u0026quot;)); /// ### 将以数字开头的字符串转换为 double /// str 是一个以数字开头的字符串， /// 返回把 str 转换后的 double ， endptr 指向第一个不是数字的字符 /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c /// double strtod(const char *str, char **endptr) /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ char *p; printf(\u0026quot;strtod(\\\u0026quot;12.030 hello\\\u0026quot;,\u0026amp;p) %f\u0026quot;,strtod(\u0026quot;12.030hello\u0026quot;,\u0026amp;p)); printf(\u0026quot; %s\\n\u0026quot;,p); /// ### 将以数字开头的字符串转换为 long int /// str 是一个以数字开头的字符串， /// 返回把 str 以 base 为基数（进制）转换后的 long int ， /// endptr 指向第一个不是数字的字符 /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c /// long int strtol(const char *str, char **endptr, int base) /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ printf(\u0026quot;strtol(\\\u0026quot;ffhello\\\u0026quot;,\u0026amp;p,16) %ld\u0026quot;,strtol(\u0026quot;ffhello\u0026quot;,\u0026amp;p,16)); printf(\u0026quot; %s\\n\u0026quot;,p); /// ### str 是一个以数字开头的字符串， /// 返回把 str 以 base 为基数 转换后的 unsigned long int ， /// endptr 指向第一个不是数字的字符 /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c /// unsigned long int strtoul(const char *str, char **endptr, int base) /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ printf(\u0026quot;strtoul(\\\u0026quot;ffhello\\\u0026quot;,\u0026amp;p,16) %uld\u0026quot;,strtoul(\u0026quot;ffhello\u0026quot;,\u0026amp;p,16)); printf(\u0026quot; %s\\n\u0026quot;,p); /// ### 分配请求的内存大小(nitems * size)并返回指向它的指针 /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c /// void *calloc(size_t nitems, size_t size) /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ p = (char *)calloc(5, sizeof(char)); printf(\u0026quot;calloc(5, sizeof(char)) %p\\n\u0026quot;,p); /// ### 分配请求的内存(size)并返回指向它的指针 /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c /// void *malloc(size_t size) /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ /* p = (char *)calloc(5 * sizeof(char)); */ /// ### 调整之前分配的内存块大小 /// * ptr 执行要调整的内存块 /// * size 要调整到的字节数 /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c /// void *realloc(void *ptr, size_t size) /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ p = realloc(p,10*sizeof(char)); printf(\u0026quot;realloc(p,10*sizeof(char)) %p\\n\u0026quot;,p); p = realloc(p,10000*sizeof(char)); printf(\u0026quot;realloc(p,10000*sizeof(char)) %p\\n\u0026quot;,p); /// ### 回收先前分配的内存 /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c /// void free(void *ptr) /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ free(p); /// ### 搜索环境变量并返回字符串 /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c /// char *getenv(const char *name) /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ printf(\u0026quot;getenv(\\\u0026quot;PATH\\\u0026quot;) %.30s ...\\n\u0026quot;, getenv(\u0026quot;PATH\u0026quot;)); /// ### 把命令(string)传递给主机由主机执行 /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c /// int system(const char *string) /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ printf(\u0026quot;system(\\\u0026quot;echo ok\\\u0026quot;)\\n\u0026quot;); system(\u0026quot;echo ok\u0026quot;); /// ### 快速排序 /// * base是数组的基地址 /// * nitems是数组的元素个数 /// * size是数组元素大小 /// * compar是比较函数，靠返回值正负来比较，为0的情况未定义 /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c /// void qsort(void *base, size_t nitems, size_t size, /// int (*compar)(const void *, const void*)) /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ p = (char *)calloc(11, sizeof(char)); strcpy(p,\u0026quot;5147096382\u0026quot;); qsort(p,10,sizeof(char),cmptest); printf(\u0026quot;qsort \u0026quot;); printf(p); putchar('\\n'); /// ### 二分查找 /// * key是要查找的元素 /// * base是数组的基地址 /// * num是数组的元素个数 /// * size数组元素大小 /// * cmp是比较函数，靠返回值正负来比较，数组必须是排好序的 /// * 返回找到的元素的指针 /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c /// void *bsearch(const void *key, const void *base, size_t num, size_t size, /// int (*cmp)(const void *, const void *)); /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ char a = '3'; /* 搜索a */ printf(\u0026quot;bsearch \u0026quot;); printf((char *)bsearch(\u0026amp;a,p,10,sizeof(char),cmptest)); free(p); putchar('\\n'); /// ### 返回x的绝对值 /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c /// int abs(int x) /// long int labs(long int x) /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ printf(\u0026quot;abs(-5) %d\\n\u0026quot;,abs(-5)); /// ### 做除法，分别得到除数和被除数 /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c /// div_t div(int numer, int denom) /// ldiv_t ldiv(long int numer, long int denom) /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ div_t div_out = div(7,2); printf(\u0026quot;div(7,2)={%d,%d}\\n\u0026quot;,div_out.quot,div_out.rem); /// ### 返回一个随机数，范围(0~RAND_MAX) /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c /// int rand(void) /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ printf(\u0026quot;rand() = %d\\n\u0026quot;,rand()); /// ### 对随机函数设置种子 /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c /// void srand(unsigned int seed) /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ srand(15); /// ### 计算一个多字节字符的长度 /// * n 是多字节字符的长度的最大值 /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c /// int mblen(const char *str, size_t n) /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ wchar_t mywchar = L'汉'; /* 换成'国'就不行了，不知道为什么 */ printf(\u0026quot;mblen('%x',MB_CUR_MAX) %u\\n\u0026quot;,L'汉',mblen((char *)\u0026amp;mywchar,MB_CUR_MAX)); /// ### 多字节字符串转换为数组 /// 将由参数str指向的多字节字符串转换为由pwcs指向的数组 /// * n 是多字节字符的长度的最大值 /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c /// size_t mbstowcs(schar_t *pwcs, const char *str, size_t n) /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ /* todu 宽字符处理看不懂 int mbtowc(whcar_t *pwc, const char *str, size_t n) Examines the multibyte character pointed to by the argument str. size_t wcstombs(char *str, const wchar_t *pwcs, size_t n) Converts the codes stored in the array pwcs to multibyte characters and stores them in the string str. int wctomb(char *str, wchar_t wchar) Examines the code which corresponds to a multibyte character given by the argument wchar. */ /// ### 在程序正常退出时执行 /// * func 要执行的函数 /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c /// int atexit(void (*func)(void)) /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ atexit(test); /// ### 程序异常退出 /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c /// void abort(void) /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ /* abort(); */ /// ### 程序正常退出 ,返回给操作系统 status /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c /// void exit(int status) /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ exit(0); } ","description":"","id":38,"section":"blog","tags":["标准库","c/c++"],"title":"C语言标准库stdlib","uri":"http://www.shaochenfeng.com/blog/c%E8%AF%AD%E8%A8%80%E6%A0%87%E5%87%86%E5%BA%93stdlib.h%E5%AD%A6%E4%B9%A0/"},{"content":"我是邵晨峰，这是我的网站 我是一个小火苗\n我很小，经不住风吹雨打\n我很弱，经不起狂风大浪\n但是\n我不会停止追求伟大的脚步\n因为\n爱你，世界\n我是邵晨峰\n","description":"","id":39,"section":"blog","tags":["纪念碑"],"title":"关于我","uri":"http://www.shaochenfeng.com/blog/%E5%85%B3%E4%BA%8E%E6%88%91/"},{"content":"本文以demo.example.com为例，详细介绍了使用acme.sh进行ssl申请和自动续约的方法\n安装 只需要用任意用户执行\ncurl https://get.acme.sh | sh  acme.sh 会安装到 ~/.acme.sh/目录下，并创建新的自动计划（cronjob）在凌晨0点检查所有证书\n生成证书的方式主要有三种  网站文件方式，适合于已经部署好apache或是nginx服务器的情况 临时监听80端口方式，适合于没有部署好服务的服务器 手动配置DNS，需要有手动配置DNS的权限，适合没有服务器或是不想更改服务器的情况  1.文件认证 acme.sh --issue -d \u0026lt;域名\u0026gt; --webroot \u0026lt;网站根目录\u0026gt; acme.sh --issue -d demo.example.com --webroot /home/wwwroot/demo.example.com/  2.暂时监听80端口 yum install socat acme.sh --issue -d demo.example.com --standalone  3. DNS方式 手动方式 首先获得认证需要的解析记录\nacme.sh --issue --dns -d demo.example.com  然后在DNS服务商中添加记录 最后重新生成证书\nacme.sh --renew -d demo.example.com  使用这种方式 acme.sh 将无法自动更新证书，每次都需要手动再次重新解析验证域名所有权。\n自动方式 dns 方式的真正强大之处在于可以使用域名解析商提供的 api 自动添加 txt 记录完成验证\n首先需要在云上申请有DNS配置权限的账号密码\n腾讯云 参考： 操作方法\n在dnspod官网上申请 https://www.dnspod.cn/Login?r=/console\n然后登录远程服务器\nexport DP_Id=\u0026quot;1234\u0026quot; export DP_Key=\u0026quot;sADDsdasdgdsf\u0026quot; acme.sh --issue --dns dns_dp -d demo.example.com  阿里云 参考： 操作方法\n在阿里云官网登录添加拥有DNS配置权限的子账户 https://ram.console.aliyun.com/overview 然后登录远程服务器\nexport Ali_Key=\u0026quot;AccessKeyId\u0026quot; export Ali_Secret=\u0026quot;AccessKeySecret\u0026quot; acme.sh --issue --dns dns_ali -d demo.example.com  证书的安装 默认生成的证书都放在安装目录下: ~/.acme.sh/\n需要将证书“拷贝”到自定义位置，方便配置，这里的复制需要用acme.sh的自带工具用于日后自动更新\nacme.sh --installcert -d demo.example.com \\ --key-file /usr/local/nginx/ssl/demo_example_com.key \\ --fullchain-file /usr/local/nginx/ssl/demo_example_com.cer \\ --reloadcmd \u0026quot;/usr/local/nginx/sbin/nginx -s reload\u0026quot;  apache服务器的配置 暂无\nnginx服务器的配置 nginx 设置类似如下\n server { listen 443 ssl; ssl on; ssl_certificate /usr/local/nginx/ssl/demo_example_com.cer; # 这里指向证书安装的位置 ssl_certificate_key /usr/local/nginx/ssl/demo_example_com.key; }  让你的SSL更安全 参考：https://mikemiao111.com/nginx%E5%A2%9E%E5%BC%BAhttps%E5%AE%89%E5%85%A8%E9%85%8D%E7%BD%AE/\nnginx默认采用1024位的加密算法，如果需要的话可以使用2048位的代替，这样可以让加密更安全\n首先生成 zjk_zoollcar_top.pem 文件到指定目录\nopenssl dhparam -out /usr/local/nginx/ssl/demo_example_com.pem 2048  然后在nginx配置文件中设置\n server { listen 443 ssl; ssl on; ssl_certificate /usr/local/nginx/ssl/demo_example_com.cer; ssl_certificate_key /usr/local/nginx/ssl/demo_example_com.key; ssl_dhparam /usr/local/nginx/ssl/demo_example_com.pem; #新增 }  可以用下面的网站测试SSL安全性\nhttps://www.ssllabs.com/ssltest/\n更新 acme.sh 目前由于 acme 协议和 letsencrypt CA 都在频繁的更新, 因此 acme.sh 也经常更新以保持同步.\n升级 acme.sh 到最新版 :\nacme.sh --upgrade  如果不想手动升级, 可以开启自动升级:\nacme.sh --upgrade --auto-upgrade  之后, acme.sh 就会自动保持更新了.\n你也可以随时关闭自动更新:\nacme.sh --upgrade --auto-upgrade 0 ","description":"","id":40,"section":"blog","tags":["https","ssl"],"title":"使用acme.sh进行ssl申请和自动续约","uri":"http://www.shaochenfeng.com/blog/acme.sh/"},{"content":"Lorem est tota propiore conpellat pectoribus de pectora summo. Redit teque digerit hominumque toris verebor lumina non cervice subde tollit usus habet Arctonque, furores quas nec ferunt. Quoque montibus nunc caluere tempus\nThis article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme. \nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution  Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\n Blockquote with attribution  Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\n Tables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\n   Name Age     Bob 27   Alice 23    Inline Markdown within tables    Inline\u0026nbsp;\u0026nbsp;\u0026nbsp; Markdown\u0026nbsp;\u0026nbsp;\u0026nbsp; In\u0026nbsp;\u0026nbsp;\u0026nbsp; Table     italics bold strikethrough\u0026nbsp;\u0026nbsp;\u0026nbsp; code    Code Blocks Code block with backticks html \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;UTF-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;  Code block indented with four spaces \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;UTF-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;  Code block with Hugo\u0026rsquo;s internal highlight shortcode \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; List Types Ordered List  First item Second item Third item  Unordered List  List item Another item And another item  Nested list  Item  First Sub-item Second Sub-item   Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL+ALT+Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\n The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015. [return]  ","description":"","id":41,"section":"blog","tags":["markdown","css","html","themes"],"title":"Markdown Syntax Guide","uri":"http://www.shaochenfeng.com/blog/markdown-syntax/"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution  Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\n Blockquote with attribution  Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\n Tables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\n   Name Age     Bob 27   Alice 23    Inline Markdown within tables    Inline\u0026nbsp;\u0026nbsp;\u0026nbsp; Markdown\u0026nbsp;\u0026nbsp;\u0026nbsp; In\u0026nbsp;\u0026nbsp;\u0026nbsp; Table     italics bold strikethrough\u0026nbsp;\u0026nbsp;\u0026nbsp; code    Code Blocks Code block with backticks html \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;UTF-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;  Code block indented with four spaces \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;UTF-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;  Code block with Hugo\u0026rsquo;s internal highlight shortcode \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; List Types Ordered List  First item Second item Third item  Unordered List  List item Another item And another item  Nested list  Item  First Sub-item Second Sub-item   Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL+ALT+Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\n The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015. [return]  ","description":"Sample article showcasing basic Markdown syntax and formatting for HTML elements.","id":42,"section":"docs","tags":["markdown","css","html","themes"],"title":"Section","uri":"http://www.shaochenfeng.com/docs/contentmanagement/sections/"},{"content":"Lorem est tota propiore conpellat pectoribus de pectora summo. Redit teque digerit hominumque toris verebor lumina non cervice subde tollit usus habet Arctonque, furores quas nec ferunt. Quoque montibus nunc caluere tempus\ninhospita parcite confusaque translucet patri vestro qui optatis lumine cognoscere flos nubis! Fronde ipsamque patulos Dryopen deorum.\n Exierant elisi ambit vivere dedere Duce pollice Eris modo Spargitque ferrea quos palude  Rursus nulli murmur; hastile inridet ut ab gravi sententia! Nomine potitus silentia flumen, sustinet placuit petis in dilapsa erat sunt. Atria tractus malis.\n Comas hunc haec pietate fetum procerum dixit Post torum vates letum Tiresia Flumen querellas Arcanaque montibus omnes Quidem et  Vagus elidunt \nThe Van de Graaf Canon\nMane refeci capiebant unda mulcebat Victa caducifer, malo vulnere contra dicere aurato, ludit regale, voca! Retorsit colit est profanae esse virescere furit nec; iaculi matertera et visa est, viribus. Divesque creatis, tecta novat collumque vulnus est, parvas. Faces illo pepulere tempus adest. Tendit flamma, ab opes virum sustinet, sidus sequendo urbis.\nIubar proles corpore raptos vero auctor imperium; sed et huic: manus caeli Lelegas tu lux. Verbis obstitit intus oblectamina fixis linguisque ausus sperare Echionides cornuaque tenent clausit possit. Omnia putatur. Praeteritae refert ausus; ferebant e primus lora nutat, vici quae mea ipse. Et iter nil spectatae vulnus haerentia iuste et exercebat, sui et.\nEurytus Hector, materna ipsumque ut Politen, nec, nate, ignari, vernum cohaesit sequitur. Vel mitis temploque vocatus, inque alis, oculos nomen non silvis corpore coniunx ne displicet illa. Crescunt non unus, vidit visa quantum inmiti flumina mortis facto sic: undique a alios vincula sunt iactata abdita! Suspenderat ego fuit tendit: luna, ante urbem Propoetides parte.\n","description":"","id":43,"section":"blog","tags":["markdown","text"],"title":"Placeholder Text","uri":"http://www.shaochenfeng.com/blog/placeholder-text/"},{"content":"Lorem est tota propiore conpellat pectoribus de pectora summo. Redit teque digerit hominumque toris verebor lumina non cervice subde tollit usus habet Arctonque, furores quas nec ferunt. Quoque montibus nunc caluere tempus\nEmoji can be enabled in a Hugo project in a number of ways.  The emojify function can be called directly in templates or Inline Shortcodes.\nTo enable emoji globally, set enableEmoji to true in your site’s configuration and then you can type emoji shorthand codes directly in content files; e.g.\n🙈 🙈 🙉 🙉 🙊 🙊\nThe Emoji cheat sheet is a useful reference for emoji shorthand codes.\nN.B. The above steps enable Unicode Standard emoji characters and sequences in Hugo, however the rendering of these glyphs depends on the browser and the platform. To style the emoji you can either use a third party emoji font or a font stack; e.g.\n.emoji { font-family: Apple Color Emoji,Segoe UI Emoji,NotoColorEmoji,Segoe UI Symbol,Android Emoji,EmojiSymbols; }","description":"","id":44,"section":"blog","tags":["emoji"],"title":"Emoji Support","uri":"http://www.shaochenfeng.com/blog/emoji-support/"},{"content":"更新于 2020年2月 源作者已不再维护，请谨慎选择 最近在逛Github时发现了一个单文件跨平台零依赖的图形库nuklear，这使我产生了兴趣，一个大约两万行的程序，实现了很不错的效果，更神奇的是它是零依赖的，这意味着可以运用到类似单片机等特殊环境，于是我果断Fork了它开始了学习之路zoollcar/nuklear，下面我们分析下nuklear图形库的源代码\n综述 首先看一下官方提供的demo（win gui版），后面会一部分一部分的分析\n/* win32 实现细节*/ while (running) { /* 输入部分 */ /* win32 实现细节 */ nk_input_begin(ctx); /* input 细节 */ nk_input_end(ctx); /* GUI 部分 */ if (nk_begin(ctx, \u0026quot;Demo\u0026quot;, nk_rect(50, 50, 200, 200), NK_WINDOW_BORDER|NK_WINDOW_MOVABLE|NK_WINDOW_SCALABLE| NK_WINDOW_CLOSABLE|NK_WINDOW_MINIMIZABLE|NK_WINDOW_TITLE)) { enum {EASY, HARD}; static int op = EASY; static int property = 20; /* 固定小部件像素宽度（纵向布局） */ /* 创建小部件之前使用 nk_layout_xxx 来说明后面的小部件布局 */ nk_layout_row_static(ctx, 30/* 高度 */, 80/* 元素宽度 */, 1/* 个数 */); if (nk_button_label(ctx, \u0026quot;button\u0026quot;)){ /* 点击事件 */ fprintf(stdout, \u0026quot;button pressed\\n\u0026quot;); } /* 小部件横向动态布局（默认是纵向） */ nk_layout_row_dynamic(ctx, 30, 2); if (nk_option_label(ctx, \u0026quot;easy\u0026quot;, op == EASY)) op = EASY; if (nk_option_label(ctx, \u0026quot;hard\u0026quot;, op == HARD)) op = HARD; nk_layout_row_dynamic(ctx, 22, 1); nk_property_int(ctx, \u0026quot;Compression:\u0026quot;, 0, \u0026amp;property, 100, 10, 1); } nk_end(ctx); /* 绘制部分 */ nk_gdi_render(nk_rgb(30,30,30)); /* 平台专用渲染 */ }  这里去除了win32实现细节，因为它本身虽然是跨平台的，但并不是所有部分都跨平台 整个程序可以分为三个输入部分，GUI部分，绘制部分，他们的关系是这样的：\ngraph TD; 输入部分--输入信息--\u0026gt;GUI部分; GUI部分--绘制命令--\u0026gt;绘制部分;  在 nuklear 中一个称为上下文的变量会贯穿整个程序，其类型为nk_context，其中记录了这个程序几乎所有的信息，包括输入结构体、整体样式、个个窗口、渲染命令缓冲区，它起着连接 nuklear 所有部分的功能\n/* 上下文 */ struct nk_context { struct nk_input input; /* 输入 */ struct nk_style style; /* 样式 */ struct nk_buffer memory; /* 缓冲区 */ struct nk_clipboard clip; /* 剪切板 */ nk_flags last_widget_state; /* 最近一个小部件状态 */ enum nk_button_behavior button_behavior; /* 按钮行为是默认还是被替换的 */ struct nk_configuration_stacks stacks; float delta_time_seconds; /* 时间（秒） */ /* 其他细节 */ /* 窗口 */ int build; int use_pool; struct nk_pool pool; struct nk_window *begin; /* 窗口链表 */ struct nk_window *end; struct nk_window *active; /* 激活窗口 */ struct nk_window *current; /* 当前窗口 */ struct nk_page_element *freelist; unsigned int count; unsigned int seq; };  输入部分 input API 负责组织一个由当前鼠标、按键和文本输入所组成的输入状态（nk_input结构体）。 nuklear 并没有直接与系统通信，有输入状态都必须由特定于平台的代码提供的。\nnk_input_begin 会清空当前的状态，然后就可以使用nk_input_motion、nk_input_key、nk_input_button、nk_input_scroll、nk_input_char 等 这些输入函数将消息提供给nuklear，nuklear会将这些信息记录在nk_input结构体中。nk_input结构体 在 nk_context 主上下文中。\n下面是nk_input的数据结构\n/* nk_input结构体，分为键盘和鼠标 */ struct nk_input { struct nk_keyboard keyboard; struct nk_mouse mouse; }; /* 鼠标结构体 */ struct nk_mouse { struct nk_mouse_button buttons[NK_BUTTON_MAX]; struct nk_vec2 pos; struct nk_vec2 prev; struct nk_vec2 delta; struct nk_vec2 scroll_delta; unsigned char grab; unsigned char grabbed; unsigned char ungrab; }; /* 键盘结构体 */ struct nk_keyboard { struct nk_key keys[NK_KEY_MAX]; char text[NK_INPUT_MAX]; int text_len; };  最后使用 nk_input_end 结束输入过程，这会固定下输入信息，知道下一帧中执行 nk_input_begin 。\nGUI部分 这部分是 nuklear 中最精彩的部分，这部分是跨平台的，它会将这部分中注册的小部件（按钮，单选，文字等）转换为渲染部分需要的简单命令\n总的来说，它的作用就是用尽可能简单的命令制作出美观的 UI 。\n建立一个新窗口的方法是 使用 nk_begin 它会在上下文中新建一个窗口，然后的操作就都在这个窗口进行了\n在向窗口加入小部件前需要先设定布局， nuklear 使用的是基于行的布局，使用 nk_layout_xxx 来为当前行设置布局，后面再加入的小部件就使用这个布局提供的位置和大小了。\n放置小部件可以调用 nk_button_xxx 、 nk_option_xxx 等函数创建，他们会使用 nk_widget 从窗口的 layout 中得到下一个小部件的位置大小信息，然后将渲染信息加入到渲染命令缓冲区\n最后使用 nk_end 结束建立这个窗口，可以建立下一个窗口了\n具体来说， nk_begin 建立了一个新窗口， nk_layout_xxx 设置这个窗口的 layout 属性来控制下面小部件的位置和大小， nk_button 等建立小部件的函数使用从窗口中得到位置大小信息，然后处理加入到缓冲区\n下面结合代码看一遍：\n新建窗口 （为了效果进行了削减，突出重点）：\n/* 建立一个新窗口，分离的标题和标识符的窗口，允许出现具有相同名称但不同标题的多个窗口 */ NK_API int nk_begin_titled(struct nk_context *ctx, const char *name, const char *title, struct nk_rect bounds, nk_flags flags) { struct nk_window *win; struct nk_style *style; /* 此处省略对参数进行可行性检验的代码 */ /* 下面判断这个名字是否已经存在相同的窗口 */ /* 如果有更新窗口，否则新建窗口 */ style = \u0026amp;ctx-\u0026gt;style; title_len = (int)nk_strlen(name); /* 将窗口名字计算为一个哈希值，比较哈希值比字符串比较快 */ title_hash = nk_murmur_hash(name, (int)title_len, NK_WINDOW_TITLE); /* 寻找窗口，返回值为0表示没找到，返回值为一个nk_window指针说明找到了 */ win = nk_find_window(ctx, title_hash, name); /* 下面创建或更新窗口 */ if (!win) { /* 创建一个新窗口 create new window */ nk_size name_length = (nk_size)nk_strlen(name); win = (struct nk_window*)nk_create_window(ctx); NK_ASSERT(win); if (!win) return 0; /* 将窗口添加到 ctx */ if (flags \u0026amp; NK_WINDOW_BACKGROUND) nk_insert_window(ctx, win, NK_INSERT_FRONT);/* 顶部添加 */ else nk_insert_window(ctx, win, NK_INSERT_BACK);/* 尾部添加 */ /* 初始化命令缓冲区 */ nk_command_buffer_init(\u0026amp;win-\u0026gt;buffer, \u0026amp;ctx-\u0026gt;memory, NK_CLIPPING_ON); win-\u0026gt;flags = flags; win-\u0026gt;bounds = bounds; win-\u0026gt;name = title_hash; /* 如果窗口名字比最大长度长，会被截断 */ name_length = NK_MIN(name_length, NK_WINDOW_MAX_NAME-1); NK_MEMCPY(win-\u0026gt;name_string, name, name_length); win-\u0026gt;name_string[name_length] = 0; /* 不是弹出式窗口 */ win-\u0026gt;popup.win = 0; if (!ctx-\u0026gt;active) ctx-\u0026gt;active = win; } else { /* 省略更新窗口的代码 */ } /* 省略后面会对鼠标点击后窗口的排列进行控制，大致就是点哪个哪个放到窗口链表顶端 */ win-\u0026gt;layout = (struct nk_panel*)nk_create_panel(ctx); ctx-\u0026gt;current = win; ret = nk_panel_begin(ctx, title, NK_PANEL_WINDOW); win-\u0026gt;layout-\u0026gt;offset_x = \u0026amp;win-\u0026gt;scrollbar.x; win-\u0026gt;layout-\u0026gt;offset_y = \u0026amp;win-\u0026gt;scrollbar.y; return ret; }  设置布局函数： NK_LIB void nk_row_layout(struct nk_context *ctx, enum nk_layout_format fmt,/* fmt 布局类型 */ float height, int cols, int width) { /* 更新当前行并设置当前行的布局 */ struct nk_window *win; NK_ASSERT(ctx); NK_ASSERT(ctx-\u0026gt;current); NK_ASSERT(ctx-\u0026gt;current-\u0026gt;layout); if (!ctx || !ctx-\u0026gt;current || !ctx-\u0026gt;current-\u0026gt;layout) return; win = ctx-\u0026gt;current; /* 创建横向 cols 个面板 高度是 height */ nk_panel_layout(ctx, win, height, cols); /* 在下面 */ /* 根据布局类型设置 */ if (fmt == NK_DYNAMIC) win-\u0026gt;layout-\u0026gt;row.type = NK_LAYOUT_DYNAMIC_FIXED;/* 固定宽度 */ else win-\u0026gt;layout-\u0026gt;row.type = NK_LAYOUT_STATIC_FIXED;/* 动态宽度 */ win-\u0026gt;layout-\u0026gt;row.ratio = 0; win-\u0026gt;layout-\u0026gt;row.filled = 0; win-\u0026gt;layout-\u0026gt;row.item_offset = 0; win-\u0026gt;layout-\u0026gt;row.item_width = (float)width; } NK_LIB void nk_panel_layout(const struct nk_context *ctx, struct nk_window *win, float height, int cols) { struct nk_panel *layout; const struct nk_style *style; struct nk_command_buffer *out; struct nk_vec2 item_spacing; struct nk_color color; /* 省略对参数可行性检验 */ /* 先获得一些预设的配置数据 prefetch some configuration data */ layout = win-\u0026gt;layout; style = \u0026amp;ctx-\u0026gt;style; out = \u0026amp;win-\u0026gt;buffer; color = style-\u0026gt;window.background; item_spacing = style-\u0026gt;window.spacing; /* 更新当前行并设置当前行布局 update the current row and set the current row layout */ /* 通过前面获得的 layout 指针更改后面的小部件都会使用的 win-\u0026gt;layout */ layout-\u0026gt;row.index = 0; layout-\u0026gt;at_y += layout-\u0026gt;row.height; layout-\u0026gt;row.columns = cols; if (height == 0.0f) layout-\u0026gt;row.height = NK_MAX(height, layout-\u0026gt;row.min_height) + item_spacing.y; else layout-\u0026gt;row.height = height + item_spacing.y; layout-\u0026gt;row.item_offset = 0; if (layout-\u0026gt;flags \u0026amp; NK_WINDOW_DYNAMIC) { /* 为动态区域设置背景 draw background for dynamic panels */ struct nk_rect background; background.x = win-\u0026gt;bounds.x; background.w = win-\u0026gt;bounds.w; background.y = layout-\u0026gt;at_y - 1.0f; background.h = layout-\u0026gt;row.height + 1.0f; nk_fill_rect(out, background, 0, color); } }  创建小部件： /* 创建按钮 */ NK_API int nk_button_text_styled(struct nk_context *ctx, const struct nk_style_button *style, const char *title, int len) { struct nk_window *win; struct nk_panel *layout; const struct nk_input *in; struct nk_rect bounds; enum nk_widget_layout_states state; /* 省略对参数可行性检验 */ /* 从 nk_context 中得到位置和大小的 nk_rect */ win = ctx-\u0026gt;current; layout = win-\u0026gt;layout; state = nk_widget(\u0026amp;bounds, ctx); if (!state) return 0; /* 生成按钮 */ in = (state == NK_WIDGET_ROM || layout-\u0026gt;flags \u0026amp; NK_WINDOW_ROM) ? 0 : \u0026amp;ctx-\u0026gt;input; return nk_do_button_text(\u0026amp;ctx-\u0026gt;last_widget_state, \u0026amp;win-\u0026gt;buffer, bounds, title, len, style-\u0026gt;text_alignment, ctx-\u0026gt;button_behavior, style, in, ctx-\u0026gt;style.font); } /* 生成按钮函数 */ NK_LIB int nk_do_button_text(nk_flags *state, struct nk_command_buffer *out, struct nk_rect bounds, const char *string, int len, nk_flags align, enum nk_button_behavior behavior, const struct nk_style_button *style, const struct nk_input *in, const struct nk_user_font *font) { struct nk_rect content; int ret = nk_false; /* 省略对参数可行性检验 */ /* 计算和返回按钮点击事件 */ /* 这里的使用 nk_input 结构中的鼠标点击位置计算是否点击到按钮 */ /* 如果点击到按钮，会返回相应的点击事件，这个时间会一路返回到用户代码中的if判断 */ ret = nk_do_button(state, out, bounds, style, in, behavior, \u0026amp;content); if (style-\u0026gt;draw_begin) style-\u0026gt;draw_begin(out, style-\u0026gt;userdata);/* 绘制开始的回调 */ /* 绘制按钮，生成按钮文字 */ nk_draw_button_text(out, \u0026amp;bounds, \u0026amp;content, *state, style, string, len, align, font); if (style-\u0026gt;draw_end) style-\u0026gt;draw_end(out, style-\u0026gt;userdata);/* 绘制完成的回调 */ return ret; } /* 真正绘制按钮 外观 */ NK_LIB const struct nk_style_item* nk_draw_button(struct nk_command_buffer *out, const struct nk_rect *bounds, nk_flags state, const struct nk_style_button *style) { const struct nk_style_item *background; if (state \u0026amp; NK_WIDGET_STATE_HOVER) background = \u0026amp;style-\u0026gt;hover; else if (state \u0026amp; NK_WIDGET_STATE_ACTIVED) background = \u0026amp;style-\u0026gt;active; else background = \u0026amp;style-\u0026gt;normal; if (background-\u0026gt;type == NK_STYLE_ITEM_IMAGE) { /* 如果是图片背景，就绘制图片 */ nk_draw_image(out, *bounds, \u0026amp;background-\u0026gt;data.image, nk_white); } else { /* 否则绘制矩形 */ nk_fill_rect(out, *bounds, style-\u0026gt;rounding, background-\u0026gt;data.color); nk_stroke_rect(out, *bounds, style-\u0026gt;rounding, style-\u0026gt;border, style-\u0026gt;border_color); } return background; } /* 绘制矩形 */ NK_API void nk_fill_rect(struct nk_command_buffer *b, struct nk_rect rect, float rounding, struct nk_color c) { struct nk_command_rect_filled *cmd; /* 省略对参数可行性检验 */ /* 将绘制命令放入命令缓冲区中，先放入再设置属性 */ cmd = (struct nk_command_rect_filled*) nk_command_buffer_push(b, NK_COMMAND_RECT_FILLED, sizeof(*cmd)); if (!cmd) return; cmd-\u0026gt;rounding = (unsigned short)rounding; cmd-\u0026gt;x = (short)rect.x; cmd-\u0026gt;y = (short)rect.y; cmd-\u0026gt;w = (unsigned short)NK_MAX(0, rect.w); cmd-\u0026gt;h = (unsigned short)NK_MAX(0, rect.h); cmd-\u0026gt;color = c; } /* 将命令加入到命令缓冲 所有的绘制命令都用这个 */ NK_LIB void* nk_command_buffer_push(struct nk_command_buffer* b, enum nk_command_type t, nk_size size) { NK_STORAGE const nk_size align = NK_ALIGNOF(struct nk_command); struct nk_command *cmd; nk_size alignment; void *unaligned; void *memory; NK_ASSERT(b); NK_ASSERT(b-\u0026gt;base); if (!b) return 0; /* 新建一块缓冲区区域，用来将命令加入缓冲区 */ cmd = (struct nk_command*)nk_buffer_alloc(b-\u0026gt;base,NK_BUFFER_FRONT,size,align); if (!cmd) return 0; /* 确保下一命令的偏移量是对齐的 make sure the offset to the next command is aligned */ b-\u0026gt;last = (nk_size)((nk_byte*)cmd - (nk_byte*)b-\u0026gt;base-\u0026gt;memory.ptr); unaligned = (nk_byte*)cmd + size; memory = NK_ALIGN_PTR(unaligned, align); alignment = (nk_size)((nk_byte*)memory - (nk_byte*)unaligned); #ifdef NK_ZERO_COMMAND_MEMORY NK_MEMSET(cmd, 0, size + alignment); #endif cmd-\u0026gt;type = t; cmd-\u0026gt;next = b-\u0026gt;base-\u0026gt;allocated + alignment; #ifdef NK_INCLUDE_COMMAND_USERDATA cmd-\u0026gt;userdata = b-\u0026gt;userdata; #endif b-\u0026gt;end = cmd-\u0026gt;next; /* 返回建好的新命令指针 */ return cmd; }  渲染部分 这个库被设计为推给后端绘制 所以它不会直接在屏幕上绘制任何图形. 而是绘制形状、小部件等。 这会缓冲进内存并组成命令队列。 每一帧会有一个带有绘制命令的命令缓冲区，提供给后端 这些绘制命令需要用户在他们自己的后端绘制中实现 之后，命令缓冲区会被清除，并且开始启动一个新帧。\n后端是用户编写的在自己设备上可以执行 nuklear 需要的最小命令集的一组函数 其中重点在于遍历GUI部分提供的命令队列，然后根据命令类型执行相应操作\n下面看一下 nuklear 自带的在win32 GUI上的实现：\nNK_API void nk_gdi_render(struct nk_color clear) { const struct nk_command *cmd; HDC memory_dc = gdi.memory_dc; SelectObject(memory_dc, GetStockObject(DC_PEN)); SelectObject(memory_dc, GetStockObject(DC_BRUSH)); nk_gdi_clear(memory_dc, clear); nk_foreach(cmd, \u0026amp;gdi.ctx) { switch (cmd-\u0026gt;type) { case NK_COMMAND_NOP: break; case NK_COMMAND_SCISSOR: { const struct nk_command_scissor *s =(const struct nk_command_scissor*)cmd; nk_gdi_scissor(memory_dc, s-\u0026gt;x, s-\u0026gt;y, s-\u0026gt;w, s-\u0026gt;h); } break; case NK_COMMAND_LINE: { const struct nk_command_line *l = (const struct nk_command_line *)cmd; nk_gdi_stroke_line(memory_dc, l-\u0026gt;begin.x, l-\u0026gt;begin.y, l-\u0026gt;end.x, l-\u0026gt;end.y, l-\u0026gt;line_thickness, l-\u0026gt;color); } break; /* 省略类似的处理 */ } nk_gdi_blit(gdi.window_dc); nk_clear(\u0026amp;gdi.ctx); } ","description":"","id":45,"section":"blog","tags":["nuklear"],"title":"nuklear的设计与源码分析","uri":"http://www.shaochenfeng.com/blog/nuklear%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"}]