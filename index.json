[{"content":"Markdown here\n","description":"test post","id":0,"section":"updates","tags":null,"title":"May 2019","uri":"https://shaochenfeng.com/updates/2019_may/"},{"content":"Markdown here\n","description":"test post","id":1,"section":"updates","tags":null,"title":"April 2019","uri":"https://shaochenfeng.com/updates/2019_april/"},{"content":"Markdown here\n","description":"test post","id":2,"section":"updates","tags":null,"title":"March 2019","uri":"https://shaochenfeng.com/updates/2019_march/"},{"content":"Markdown here\n","description":"test post","id":3,"section":"updates","tags":null,"title":"February 2019","uri":"https://shaochenfeng.com/updates/2019_february/"},{"content":"Markdown here\n","description":"test post","id":4,"section":"updates","tags":null,"title":"January 2019","uri":"https://shaochenfeng.com/updates/2019_january/"},{"content":"早期学习的笔记，所以比较乱\n# 常用命令\r## echo \u0026quot;str\u0026quot;|shell变量\r显示一串字符串或 shell 变量\r## linux 环境变量\r* $SHELL shell的类型\r* $HOSTNAME 主机名\r* $PATH path路径\renv命令可以查看所有的环境变量\r## data\r显示时间 可以按格式\r## reboot\r重启\r## elinks [参数] 网址\r一个纯文字界面的浏览器\r# 查看系统状况\r## ifconfig\r获取网卡配置和网络状况等信息\r## uptime\r查看系统负载情况，输出内容分别为系统当前时间、系统已运行时间、当前在线用户以及平均负载值。\r### 习惯用法：watch -n 1 uptime\r每秒刷新获得一次系统负载状况\r## free\r用于显示当前系统中内存的使用情况\r## last\r用于查看所有系统的登录记录\r## history\r用于显示历史执行过的命令，历史执行过的命令保存在家目录的.bash_history文件中\r#文件查看\r## pwd\r显示当前工作的目绝对路径\r## more\r查看纯文本文件，可以翻页\r## head -n [行数] [文件名]\r查看纯文本文件的前N行\r## tail\r查看传文本的后几行\r## od [参数] [文件]\r查看特殊格式的文件\r### od中查看不同格式文件的参数\r不加 二进制\r-t a 默认字符\r-t c ASCII字符\r-t o 八进制\r-t d 十进制\r-t x 十六进制\r-t f 浮点数类型\r## wc [参数] [文件]\r用于统计指定文件的行数、字数、字节数\r-l 只显示行数\r-w 只显示单词数\r-c 只显示字节数\r## tr [原格式] [现格式]\r用于替换文本中的字符\r## diff\r用于比较多个文本文件的差异\r## touch\r用于创建空白文件或修改修改时间\r## mkdir\r创建文件夹\r常用：mkdir -p a/b/c/d 创建一连串文件夹\r## dd\r用于指定大小的精确复制文件或转换指定文件\r## dd命令的参数\rif 输入的文件名字\rof 输出的文件名字\rbs 设置每个块的大小\rcount 设置复制的块数\rconv=ucase 小写变大写\rconv=lcase 大写变小写\r## mount /dev/cdrom /mnt/cdrom\r光盘挂载\r## yum\r管理软件——软件管家\r## 输入输出重定向\r### 对于输出重定向符有这些情况：\r符号\t作用\r命令 \u0026gt; 文件\t将标准输出重定向到一个文件中（清空原有文件的数据）\r命令 2\u0026gt; 文件\t将错误输出重定向到一个文件中（清空原有文件的数据）\r命令 \u0026gt;\u0026gt; 文件\t将标准输出重定向到一个文件中（追加到原有内容的后面）\r命令 2\u0026gt;\u0026gt; 文件\t将错误准输出重定向到一个文件中（追加到原有内容的后面）\r命令 \u0026gt;\u0026gt; 文件 2\u0026gt;$1\t将标准输出与错误输出共同写入到文件中（追加到原有内容的后面）\r### 对于输入重定向有这些情况：\r符号\t作用\r命令 \u0026lt; 文件\t将文件作为命令的标准输入\r命令 \u0026lt;\u0026lt; 分界符\t从标准输入中读入，直到遇见“分界符”才停止\r命令 \u0026lt; 文件1 \u0026gt; 文件2\t将文件1作为命令的标准输入并将标准输出到文件2\r## bash解释器支持很多特殊字符的扩展\r''(单引号)\t转义字符生效\r\u0026quot;\u0026quot;(双引号)\t变量依然生效\r``(反引号)\t执行命令语句\r## alias 别名=命令\r设置命令的别名\rumalias 用于取消别名\r## bash寻找一条命令的方法\r1.如果是以绝对/相对路径输入的，直接执行\r2.检查alias，判断是否是别的命令的别名\r3.bash判断是内部命令还是外部命令 （type [命令]）\r4.通过 $PATH 变量中的路径查找此命令\r## su [用户名]\r切换用户，当用户登出后，会切换回原用户\rifconfig 用于获取网卡配置与网络状态等信息\nuptime 命令用于查看系统的负载情况\n​\t经常用”watch -n 1 uptime“来每秒刷新一次获得当前的系统负载情况，输出内容分别为系统当前时间、系统已运行时间、当前在线用户以及平均负载值。\nfree命令用于显示当前系统中内存的使用量情况\nlast命令用于查看所有系统的登入记录\nhistory命令用于显示历史执行过的命令\n历史命令会被保存到用户家目录中的”.bash_history“文件中\npwd命令用于显示当前的工作目录\nmore命令用于查看纯文本文件（较长的）\nhead命令用于查看纯文本文档的前N行\nhead -n 20 文件名 显示10行\ntail命令用于查看纯文本文档的后N行\nod命令用于对查看特殊格式的文件\n参数\t作用\n不加\t二进制\n-t a\t默认字符\n-t c\tASCII字符\n-t o\t八进制\n-t d\t十进制\n-t x\t十六进制\n-t f\t浮点数\ntr命令用于转换文本文件中的字符\n将tr.txt文件的内容转换成大写\ncat tr.txt | tr [a-z] [A-Z]\nwc命令用于统计指定文本的行数、字数、字节数，格式为“wc [参数] 文本”。\n参数\t作用\n-l\t只显示行数\n-w\t只显示单词数\n-c\t只显示字节数\ndiff命令用于比较显示多个文本文件的差异\ntouch命令用于创建空白文件与修改文件时间\nmkdir -p a/b/c/d/e\n创建一条龙的目录\ndd命令用于指定大小的拷贝的文件或指定转换文件\n参数\t作用\nif\t输入的文件名称。\nof\t输出的文件名称。\nbs\t设置每个“块”的大小。\ncount\t设置要拷贝“块”的个数。\nconv=ucase\t将字母从小写转换为大写。\nconv=lcase\t把字符从大写转换为小写。\nmount /dev/cdrom /mnt/cdrom光盘挂载\nyum -y install 软件名\n安装软件\necho \u0026ldquo;Content\u0026rdquo; | mail -s \u0026ldquo;Subject\u0026rdquo; linuxprobe\n使用非交互式设置用户密码，将root的密码修改为linuxprobe。\n对于输出重定向符有这些情况：\n符号\t作用\n命令 \u0026gt; 文件\t将标准输出重定向到一个文件中（清空原有文件的数据）\n命令 2\u0026gt; 文件\t将错误输出重定向到一个文件中（清空原有文件的数据）\n命令 \u0026raquo; 文件\t将标准输出重定向到一个文件中（追加到原有内容的后面）\n命令 2\u0026raquo; 文件\t将错误准输出重定向到一个文件中（追加到原有内容的后面）\n命令 \u0026raquo; 文件 2\u0026gt;$1\t将标准输出与错误输出共同写入到文件中（追加到原有内容的后面）\n对于输入重定向有这些情况：\n符号\t作用\n命令 \u0026lt; 文件\t将文件作为命令的标准输入\n命令 \u0026laquo; 分界符\t从标准输入中读入，直到遇见“分界符”才停止\n命令 \u0026lt; 文件1 \u0026gt; 文件2\t将文件1作为命令的标准输入并将标准输出到文件2\nbash解释器还支持很多的特殊字符扩展：\n字符\t作用\n(反斜杠)\t转义后面单个字符\n\u0026lsquo;'(单引号)\t转义所有的字符\n\u0026ldquo;\u0026quot;(双引号)\t变量依然生效\n``(反引号)\t执行命令语句\nalias命令用于设置“命令的别名”，格式为：“alias 别名=命令”。\nunalias命令用于取消命令的别名，格式为：“unalias 别名”。\n如同前面所讲的——在Linux中所有的一切都是文件，命令文件也不例外。那当用户执行了一条”ls“命令后发生了什么事情？\n步骤一:如果是以绝对/相对路径输入的命令则直接执行（如执行/bin/ls）。\n步骤二:检查是否为alias别名命令。\n步骤三:由bash判断其是“内部命令”还是“外部命令”。\n内部命令：属于解释器内部的\n外部命令：独立于解释器外的命令文件\n步骤四：通过$PATH变量中定义的路径进行命令查找。\n查看$PATH变量的方法:echo $PATH\n/usr/local/bin:/usr/local/sbin:/usr/bin:/usr/sbin:/bin:/sbin\n如果您想知道某个命令是“内部命令”还是“外部命令”？执行执行“type 命令名字”，解释器就会告诉你\n在Linux系统中还有许多重要的环境变量，我们可以用 env 命令查看到它们。\nsu 临时切换用户，退出后还是原账户\nexport命令用于将局部变量提升为全局变量\n可以通过使用at命令或配置Crontab计划任务服务让系统自动按时工作，让日常工作更加的高效自动化，一劳永逸\nvim编辑器的命令模式中常用的快捷键\n命令\t作用\ndd\t删除(剪切)光标所在整行。\n5dd\t删除(剪切)从光标处开始的5行。\nyy\t复制光标所在整行。\n5yy\t复制从光标处开始的5行。\np\t将之前删除（dd）或复制（yy）过的数据粘贴到光标后。\n/字符串\t在文本中从上至下搜索该字符串。\n?字符串\t在文本中从下至上搜索该字符串。\nn\t显示搜索命令定位到的下一个字符串。\nN\t显示搜索命令定位到的上一个字符串。\nu\t撤销上一步的操作\nnl带行号显示文档\nhead命令 显示文档开头\ntail命令 显示文档结尾\nwhich 命令的作用是，在 PATH 变量指定的路径中搜索可执行文件的所在位置。它一般用来确认系统中是否安装了指定的软件。\nxargs用作替换工具，读取输入数据重新格式化后输出。\n默认转单行输出\n-n 多行输出 -n 3 三个单词一行\n-d 自定义定界符 -d i 用i分割每行\npaste 命令\npaste 命令的功能正好与 cut 相反。它会添加一个或多个文本列到文件中，而不是从文件中抽取文本列。\n它通过读取多个文件，然后把每个文件中的字段整合成单个文本流，输入到标准输出。\ntr 命令\n常被用来更改字符。我们可以把它看作是一种基于字符的查找和替换操作。换字是一种把字符从一个字母转换为另一个字母的过程。\ntr 从标准输入中替换、缩减和/或删除字符，并将结果写到标准输出。\n$tr a c\nasdaa\ncsdcc\n将输入的字符大写转换为小写，可以使用如下命令：\necho \u0026lsquo;THIS IS SHIYANLOU!\u0026rsquo; | tr \u0026lsquo;A-Z\u0026rsquo; \u0026lsquo;a-z\u0026rsquo;\nsort 命令\n能够帮助我们对文本文件和 stdin 进行排序操作。通常，它会结合其他命令来生成所需要的输出。\n-n 基于字符串的长度来排序,使用此选项允许根据数字值排序，而不是字母值\n-k 指定排序关键字\n-b 默认情况下，对整行进行排序，从每行的第一个字符开始。这个选项导致 sort 程序忽略每行开头的空格，从第一个非空白字符开始排序\n-m 只合并多个输入文件\n-r 按相反顺序排序,结果按照降序排列，而不是升序\n-t 自定义分隔符，默认为制表符\n列出/usr/share/目录下使用空间最多的前 10 个目录文件，可以使用如下命令：\ndu -s /usr/share/* | sort -nr | head -10\nuniq 命令经常和 sort 命令结合在一起使用。uniq 从标准输入或单个文件名参数接受数据有序列表，默认情况下，从数据列表中删除任何重复行。\n红帽RHEL7系统中网卡配置文件的前缀则为”ifcfg-eno“，例如”ifcfg-eno16777736″。\n网卡的配置文件存放在“/etc/sysconfig/network-scripts”目录中。\n//xrandr设置屏幕分辨率\nxrandr -s 0 设置回原来分辨率\n-s 指定分辨率大小\n-q 显示可用分辨率\n查看系统中所有可用的Shell解释器:\ncat /etc/shells 查看当前的Shell解释器:\necho $SHELL 执行脚本有三种方法：\n脚本文件路径:./Example.sh（需要有执行权限）\nsh+脚本文件路径:sh Example.sh\nsource+脚本文件路径:source Example.sh\nshell脚本的参数\n$0\t当前执行Shell脚本的程序名。\n$1-9,${10},${11}……\t参数的位置变量。\n$#\t一共有多少个参数。\n$*\t所有位置变量的值。\n$?\t判断上一条命令是否执行成功，0为成功，非0为失败。\n测试语句\n细分测试语句有:文件测试、逻辑测试、整数值比较、字符串比较。\n文件测试:[ 操作符 文件或目录名]\n操作符\t作用\n-d\t测试是否为目录。\n-e\t测试文件或目录是否存在。\n-f\t判断是否为文件。\n-r\t测试当前用户是否有权限读取。\n-w\t测试当前用户是否有权限写入。\n-x\t测试当前用户是否有权限执行。\n测试/etc/fstab是否为目录：\n[root@linuxprobe ~]# [ -d /etc/fstab ]\n显示上一条命令的返回值，非0则为失败，即不是目录：\n[root@linuxprobe ~]# echo $?\n1\n测试/etc/fstab是否为文件：\n[root@linuxprobe ~]# [ -f /etc/fstab ]\n显示上一条命令的返回值为0，即fstab是文件：\n[root@linuxprobe ~]# echo $?\n0\n逻辑测试:[ 表达式1 ] 操作符 [ 表达式2 ]\n操作符\t作用\n\u0026amp;\u0026amp;\t逻辑的与，\u0026ldquo;而且\u0026quot;的意思。\n||\t逻辑的或，\u0026ldquo;或者\u0026quot;的意思。\n!\t逻辑的否。\n“与 ”的运用\n符号\u0026amp;\u0026amp;代表逻辑上的”与“，当前面的命令执行成功才会执行后面的命令，判断/dev/cdrom设备是否存在，若存在则输出Exist：\n[root@linuxprobe ~]# [ -e /dev/cdrom ] \u0026amp;\u0026amp; echo \u0026ldquo;Exist\u0026rdquo;\nExist\n若当前登陆的用户不是root，则输出user，执行后结果为空：\n[root@linuxprobe ~]# [ $USER != root ] \u0026amp;\u0026amp; echo \u0026ldquo;user\u0026rdquo;\n非root用户则输出user，若是root则直接输出root：\n[root@linuxprobe ~]# [ $USER != root ] \u0026amp;\u0026amp; echo \u0026ldquo;user\u0026rdquo; || echo \u0026ldquo;root\u0026rdquo;\nroot\n整数值比较:[ 整数1 操作符 整数2 ]\n操作符\t作用\n-eq\t判断是否等于\n-ne\t判断是否不等于\n-gt\t判断是否大于\n-lt\t判断是否小于\n-le\t判断是否等于或小于\n-ge\t判断是否大于或等于\nread命令\n读入值到变量\n-p 指定提示\n-t 指定时间\n#read -p \u0026ldquo;input:\u0026rdquo; a\nshell脚本\n选择\nif [$a -gt 100]\nthen\nelse\nif\ncase 变量值 in\n[模式1])\n[模式2])\n[模式3])\n*)\nesac\n循环\nfor 变量名 in 取值列表\ndo\ndone\nwhile\ndo\ndone\n计划任务\nat \u0026lt;时间\u0026gt;\t安排一次性任务\natq或at -l\t查看任务列表\nat -c 序号\t预览任务与设置环境\natrm 序号\t删除任务\n一般用at命令创建计划任务有交互式与非交互式两种方法，先来看看交换式的方法，（输完成后敲击Ctrl+d来保存退出）\n直接用echo语句将要执行的命令传送给at命令:\necho \u0026ldquo;systemctl start httpd\u0026rdquo; | at 23:30\n创建长期可循环的计划任务，则要用到cron服务啦，具体使用方法如下：\n创建、编辑计划任务:crontab -e [-u 用户名]\n查看计划任务:crontab -l [-u 用户名]\n删除计划任务:crontab -r [-u 用户名]\n其中在创建、编辑计划任务时有个固定的格式，请读者们一定要记住。\ncrontab -e 分钟 小时 日期 月份 星期 命令\n字段\t说明\n分钟\t取值为从0到59之间的整数\n小时\t取值为从0到23之间的任意整数\n日期\t取值为1到31之间的任意整数\n月份\t取值为1到12之间的任意整数\n星期\t取值为0到7之间的任意整数，其中0与7均为星期日\n命令\t要执行的命令或程序脚本\n将数据同步写入硬盘中的指令： sync 最正确的关机指令： shutdown 重新开机： reboot 关机啰： halt ，poweroff halt 与 poweroff 也具有相同的功能\n主要常见的目录定义：\n目录名称\t应放置文件的内容\n/boot\t开机所需文件——内核,开机菜单及所需配置文件等\n/dev\t任何设备与接口都以文件形式存放在此目录\n/etc\t配置文件\n/home\t用户主目录\n/bin\t单用户维护模式下还能够被操作的命令\n/lib\t开机时用到的函数库及/bin与/sbin下面命令要调用的函数\n/sbin\t开机过程中需要的\n/media\t一般挂载或删除的设备\n/opt\t放置第三方的软件\n/root\t系统管理员的主文件夹\n/srv\t一些网络服务的数据目录\n/tmp\t任何人均可使用的“共享”临时目录\n/proc\t虚拟文件系统，例如系统内核，进程，外部设备及网络状态等\n/usr/local\t用户自行安装的软件\n/usr/sbin\t非系统开机时需要的软件/命令/脚本\n/usr/share\t帮助与说明文件，也可放置共享文件。\n/var\t主要存放经常变化的文件，如日志。\n/lost+found\t当文件系统发生错误时，将一些丢失的文件片段存放在这里\n常见的硬件命名如下：\n硬件设备\t文件名称\nIDE设备\t/dev/hd[a-d]\nSCSI/SATA/U盘\t/dev/sd[a-p]\n软驱\t/dev/fd[0-1]\n打印机\t/dev/lp[0-15]\n光驱\t/dev/cdrom\n鼠标\t/dev/mouse\nmount命令用于挂载文件系统，格式为：\n“mount 文件系统 挂载目录”。\n将光盘文件挂载:“mount /dev/cdrom /media/cdrom”。\n参数\t作用\n-a\t挂载所有在/etc/fstab中定义的文件系统\n-t\t指定文件系统的类型\n想让开机自动挂载需要写到/etc/fstab文件中\n填写格式如下：\n设备文件 挂载目录 格式类型 权限选项 自检 优先级\n设备文件：一般为设备的路径+名称，也可以写UUID值等。\n挂载目录：指定要挂载到的目录，需挂载前创建好。\n格式类型：即指定文件系统的格式，比如有ext3/ext4/xfs/iso9660/swap等。\n权限选项：默认为defaults(rw,suid,dev,exec,auto,nouser,async)，可指定acl或quota等。\n自检：若为1则开机后进行磁盘自检，0为不自检。\n优先级：若“自检”为1，则可对多块硬盘进行优先级设置。\numount命令用于撤销已经挂载的设备文件，格式为：“umount [挂载点/设备文件]”。\nfdisk命令用于管理磁盘分区，格式为：“fdisk [磁盘名称]”。\n管理某硬盘的分区:“fdisk /dev/sda”\n参数\t作用\nm\t查看全部可用的参数\nn\t添加新的分区\nd\t删除某个分区信息\nl\t列出所有可用的分区类型\nt\t改变某个分区的类型\np\t查看分区表信息\nw\t保存并退出\nq\t不保存直接退出\nln命令能够让用户创建出两种不同类型的文件快捷方式\nln [选项] 目标\n参数\t作用\n-s\t创建\u0026quot;软链接\u0026rdquo;(默认是硬链接)\n-f\t强制创建文件或目录的链接\n-i\t覆盖前先询问\n-v\t显示创建链接的过程\n其实”root“只是个名字，真正让它成为“超级用户”的是UID值\nUID（即User IDentification的缩写）：每个用户都有对应的UID值\n超级用户UID0:root用户默认为0。\n系统用户UID1-999:系统中系统服务由不同用户运行，更加安全，默认被限制登陆系统。\n普通用户UID1000~:即管理员创建的用于日常工作而不能管理系统的普通用户。\n帐户名称与UID保存在/etc/passwd文件中，而帐户密码则保存在/etc/shadow文件中。\n文件和文件夹的X权限不同作用\n文件：可执行\n文件夹：可进入\nSUID:让执行者临时拥有属主的权限（仅对拥有执行权限的二进制程序有效）\n因为被给予了SGID权限，所以当用户执行了ps命令，实际有效用户组就是system啦\nchmod命令用于修改文件或目录的权限，格式为：\n”chmod [参数] 权限 文件或目录名称”\n-f 忽略错误信息\n-c 全部显示信息\n-v 显示细节\n-R 递归变更子目录\n+s SGID权限\n-g+s 给组加SGID权限\n-u+s 给用户加SGID权限\n这样他人在运行，或在此目录下建立文件会借用建立者权限（典型例子：password命令）\n+t 目录添加SBIT（粘滞位），只可管理自己的数据而不能删除他人文件，般老师希望学生可以将作业上传到某个特定目录——但为了避免某些小破坏份子，想限制删除其他人文件的话，那就要设置SBIT位了\n启动级别\n这部分好像因为systemd的流行已经过时了\n等级0表示：表示关机 等级1表示：单用户模式 等级2表示：无网络连接的多用户命令行模式 等级3表示：有网络连接的多用户命令行模式 等级4表示：不可用 等级5表示：带图形界面的多用户模式 等级6表示：重新启动\narping命令 是用于发送arp请求到一个相邻主机的工具，arping使用arp数据包，通过ping命令检查设备上的硬件地址。能够测试一个ip地址是否是在网络上已经被使用，并能够获取更多设备信息。功能类似于ping。\nrm\n用于删除给定的文件和目录\n补充说明\nrm 命令 可以删除一个目录中的一个或多个文件或目录，也可以将某个目录及其下属的所有文件及其子目录均删除掉。对于链接文件，只是删除整个链接文件，而原有文件保持不变。\n注意：使用rm命令要格外小心。因为一旦删除了一个文件，就无法再恢复它。所以，在删除文件之前，最好再看一下文件的内容，确定是否真要删除。rm命令可以用-i选项，这个选项在使用文件扩展名字符删除多个文件时特别有用。使用这个选项，系统会要求你逐一确定是否要删除。这时，必须输入y并按Enter键，才能删除文件。如果仅按Enter键或其他字符，文件不会被删除。\n语法\nrm (选项)(参数)\n选项\n-d：直接把欲删除的目录的硬连接数据删除成0，删除该目录；\n-f：强制删除文件或目录；\n-i：删除已有文件或目录之前先询问用户；\n-r或-R：递归处理，将指定目录下的所有文件与子目录一并处理；\n\u0026ndash;preserve-root：不对根目录进行递归操作；\n-v：显示指令的详细执行过程。\n参数\n文件：指定被删除的文件列表，如果参数中含有目录，则必须加上-r或者-R选项。\n实例\n交互式删除当前目录下的文件test和example\nrm -i test example\nRemove test ?n（不删除文件test)\nRemove example ?y（删除文件example)\n删除当前目录下除隐含文件外的所有文件和子目录\n**rm -r ***\n应注意，这样做是非常危险的!\nrm 命令删除文件\nrm 文件1 文件2 \u0026hellip;\nrm testfile.txt\nrm 命令删除目录\nrm -r [目录名称]\n-r 表示递归地删除目录下的所有文件和目录。\n-f 表示强制删除\nrm -rf testdir\nrm -r testdir\n删除操作前有确认提示\nrm -i [文件/目录]\nrm -r -i testdir\nrm 忽略不存在的文件或目录\n-f 选项（LCTT 译注：即 “force”）让此次操作强制执行，忽略错误提示\nrm -f [文件\u0026hellip;]\n仅在某些场景下确认删除\n选项 -I，可保证在删除超过 3 个文件时或递归删除时（LCTT 译注： 如删除目录）仅提示一次确认。\nrm -I file1 file2 file3\n附件 ","description":"基础命令","id":5,"section":"linux","tags":null,"title":"1.基础命令","uri":"https://shaochenfeng.com/linux/linux%E5%9F%BA%E7%A1%80%E5%92%8C%E5%8E%9F%E7%90%86/1.%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/"},{"content":"ansible是新出现的自动化运维工具，基于Python开发。\nansible基于模块化工作，本身没有批量部署的能力。真正具有批量部署的是ansible所运行的模块，ansible只是提供一种框架。ansible不需要在远程主机上安装client/agents，因为它们是基于ssh来和远程主机通讯的。\nansible目前已经已经被红帽官方收购，是自动化运维工具中大家认可度最高的，并且上手容易，学习简单。是每位运维工程师必须掌握的技能之一。\n安装 使用 pip（python的包管理模块）安装 　首先，我们需要安装一个python-pip包，安装完成以后，则直接使用pip命令来安装我们的包，具体操作过程如下：\n\tyum install python-pip\rpip install ansible\r使用 yum 安装 　yum 安装是我们很熟悉的安装方式了。我们需要先安装一个epel-release包，然后再安装我们的 ansible 即可。\n\tyum install epel-release -y\ryum install ansible –y\r安装目录如下(yum安装)：\n配置文件目录：/etc/ansible/\n执行文件目录：/usr/bin/\nLib库依赖目录：/usr/lib/pythonX.X/site-packages/ansible/\nHelp文档目录：/usr/share/doc/ansible-X.X.X/\nMan文档目录：/usr/share/man/man1/\nansible 任务执行模式 Ansible 系统由控制主机对被管节点的操作方式可分为两类，即adhoc和playbook：\n ad-hoc模式(点对点模式)\n使用单个模块，支持批量执行单条命令。ad-hoc 命令是一种可以快速输入的命令，而且不需要保存起来的命令。就相当于bash中的一句话shell。 playbook模式(剧本模式)\n是Ansible主要管理方式，也是Ansible功能强大的关键所在。playbook通过多个task集合完成一类功能，如Web服务的安装部署、数据库服务器的批量备份等。可以简单地把playbook理解为通过组合多条ad-hoc操作的配置文件。  配置文件 /etc/ansible/ansible.cfg\n~/.ansible.cfg\n./ansible.cfg\nANSIBLE_CONFIG 环境变量\nhosts主机列表\n不改配置的话是/etc/ansible/hosts\nansible-config dump 当前应用配置\n常见的配置参数 inventory = /etc/ansible/hosts\t#这个参数表示资源清单inventory文件的位置\rlibrary = /usr/share/ansible\t#指向存放Ansible模块的目录，支持多个目录方式，只要用冒号（：）隔开就可以\rforks = 5\t#并发连接数，默认为5\rsudo_user = root\t#设置默认执行命令的用户\rremote_port = 22\t#指定连接被管节点的管理端口，默认为22端口，建议修改，能够更加安全\rhost_key_checking = False\t#设置是否检查SSH主机的密钥，值为True/False。关闭后第一次连接不会提示配置实例\rtimeout = 60\t#设置SSH连接的超时时间，单位为秒\rlog_path = /var/log/ansible.log\t#指定一个存储ansible日志的文件（默认不记录日志）\r主机列表的写法 1、 直接指明主机地址或主机名：\r## green.example.com#\r# blue.example.com#\r# 192.168.100.1\r# 192.168.100.10\r2、 定义一个主机组[组名]把地址或主机名加进去\r[mysql_test]\r192.168.253.159\r192.168.253.160\r192.168.253.153\r使用点对点模式 例如test是hosts定义的主机组名\nansible \u0026lt;主机组或主机\u0026gt; -m \u0026lt;模块名\u0026gt; -a \u0026lt;模块的参数\u0026gt;\nansible test -a \u0026lsquo;ip a\u0026rsquo;\n-K 手动输入sudo密码\n-k 手动输入ssh密码\nansible test2 -m debug -a \u0026ldquo;msg={{test}}\u0026rdquo;\nansible test2 -m debug -a \u0026ldquo;msg={{play_hosts}}\u0026rdquo;\nansible test2 -m ping\nansible test2 -l 192.168.56.118 -m shell -a \u0026lsquo;hostname\u0026rsquo; # 指定组中的一个主机\n使用剧本模式  ansible-playbook a.yml #执行 ansible-playbook a.yml \u0026ndash;syntax-check #检查yaml文件的语法是否正确 ansible-playbook a.yml \u0026ndash;list-task #检查tasks任务 ansible-playbook a.yml \u0026ndash;list-hosts #检查生效的主机 ansible-playbook a.yml \u0026ndash;start-at-task=\u0026lsquo;Copy Nginx.conf\u0026rsquo; #指定从某个task开始运行  a.yml 如下：\n---\r- hosts: test\rremote_user: root\r#become: yes # 切换用户执行\r#become_user: zoollcar\rvars: # 变量\r- hello: hi,zoollcar\r- service: nginx\rtasks:\r- name: hello\rcommand: 'echo {{hello}}' # 使用变量\r- name: stop nginx\rservice: name=nginx state=stopped\r- name: shell date time # shell模块支持各种shell操作，管道、变量等\rshell: 'echo $(date) \u0026gt;\u0026gt; /tmp/datetime.log'\r- name: command false\rcommand: 'false'\rignore_errors: True # 如果命令返回不是0 就会失败回退，用这个可以不强制成功\r- name: make file # 引用ansible的内部变量、hosts文件中的主机变量\rcopy: content=\u0026quot;{{ansible_all_ipv4_addresses}},{{test}}\u0026quot; dest=/tmp/ipv4.txt\r常见的命令行操作 ansible-console test2 #交互式执行多个命令\nansible-doc shell # 查看插件的帮助文档\nansible-doc -l # 显示所有的可用插件\nansible-doc -t httpapi -l # 查看所有httpapi相关的插件列表\nansible-galaxy search tomcat # 查找插件\nansible-galaxy install XXX # 安装插件\nansible-galaxy init XXX # 新建插件\nansible 常用模块 这部分是最重要的，文章来源 https://www.cnblogs.com/keerya/p/7987886.html\n1）主机连通性测试 　我们使用ansible web -m ping命令来进行主机连通性测试，效果如下：\n[root@server ~]# ansible web -m ping\r192.168.37.122 | SUCCESS =\u0026gt; {\r\u0026quot;changed\u0026quot;: false, \u0026quot;ping\u0026quot;: \u0026quot;pong\u0026quot;\r}\r192.168.37.133 | SUCCESS =\u0026gt; {\r\u0026quot;changed\u0026quot;: false, \u0026quot;ping\u0026quot;: \u0026quot;pong\u0026quot;\r}\r　这样就说明我们的主机是连通状态的。接下来的操作才可以正常进行。\n2）command 模块 　这个模块可以直接在远程主机上执行命令，并将结果返回本主机。\n举例如下：\n[root@server ~]# ansible web -m command -a 'ss -ntl'\r192.168.37.122 | SUCCESS | rc=0 \u0026gt;\u0026gt;\rState Recv-Q Send-Q Local Address:Port Peer Address:Port LISTEN 0 128 *:111 *:* LISTEN 0 5 192.168.122.1:53 *:* LISTEN 0 128 *:22 *:* LISTEN 0 128 127.0.0.1:631 *:* LISTEN 0 128 *:23000 *:* LISTEN 0 100 127.0.0.1:25 *:* LISTEN 0 128 :::111 :::* LISTEN 0 128 :::22 :::* LISTEN 0 128 ::1:631 :::* LISTEN 0 100 ::1:25 :::* 192.168.37.133 | SUCCESS | rc=0 \u0026gt;\u0026gt;\rState Recv-Q Send-Q Local Address:Port Peer Address:Port LISTEN 0 128 *:111 *:* LISTEN 0 128 *:22 *:* LISTEN 0 128 127.0.0.1:631 *:* LISTEN 0 128 *:23000 *:* LISTEN 0 100 127.0.0.1:25 *:* LISTEN 0 128 :::111 :::* LISTEN 0 128 :::22 :::* LISTEN 0 128 ::1:631 :::* LISTEN 0 100 ::1:25 :::* 　命令模块接受命令名称，后面是空格分隔的列表参数。给定的命令将在所有选定的节点上执行。它不会通过shell进行处理，比如$HOME和操作如\u0026quot;\u0026lt;\u0026quot;，\u0026quot;\u0026gt;\u0026quot;，\u0026quot;|\u0026quot;，\u0026quot;;\u0026quot;，\u0026quot;\u0026amp;\u0026quot; 工作（需要使用（shell）模块实现这些功能）。注意，该命令不支持| 管道命令。\n下面来看一看该模块下常用的几个命令：\n chdir　# 在执行命令之前，先切换到该目录\nexecutable # 切换shell来执行命令，需要使用命令的绝对路径\nfree_form # 要执行的Linux指令，一般使用Ansible的-a参数代替。\ncreates # 一个文件名，当这个文件存在，则该命令不执行,可以\n用来做判断\nremoves # 一个文件名，这个文件不存在，则该命令不执行\n 　下面我们来看看这些命令的执行效果：\n[root@server ~]# ansible web -m command -a 'chdir=/data/ ls'\t#先切换到/data/ 目录，再执行“ls”命令\r192.168.37.122 | SUCCESS | rc=0 \u0026gt;\u0026gt;\raaa.jpg\rfastdfs\rmogdata\rtmp\rweb\rwKgleloeYoCAMLtZAAAWEekAtkc497.jpg\r192.168.37.133 | SUCCESS | rc=0 \u0026gt;\u0026gt;\raaa.jpg\rfastdfs\rmogdata\rtmp\rweb\rwKgleloeYoCAMLtZAAAWEekAtkc497.jpg\r[root@server ~]# ansible web -m command -a 'creates=/data/aaa.jpg ls'\t#如果/data/aaa.jpg存在，则不执行“ls”命令\r192.168.37.122 | SUCCESS | rc=0 \u0026gt;\u0026gt;\rskipped, since /data/aaa.jpg exists\r192.168.37.133 | SUCCESS | rc=0 \u0026gt;\u0026gt;\rskipped, since /data/aaa.jpg exists\r[root@server ~]# ansible web -m command -a 'removes=/data/aaa.jpg cat /data/a'\t#如果/data/aaa.jpg存在，则执行“cat /data/a”命令\r192.168.37.122 | SUCCESS | rc=0 \u0026gt;\u0026gt;\rhello\r192.168.37.133 | SUCCESS | rc=0 \u0026gt;\u0026gt;\rhello\r3）shell 模块 　shell模块可以在远程主机上调用shell解释器运行命令，支持shell的各种功能，例如管道等。\n[root@server ~]# ansible web -m shell -a 'cat /etc/passwd |grep \u0026quot;keer\u0026quot;'\r192.168.37.122 | SUCCESS | rc=0 \u0026gt;\u0026gt;\rkeer❌10001:1000:keer:/home/keer:/bin/sh\r192.168.37.133 | SUCCESS | rc=0 \u0026gt;\u0026gt;\rkeer❌10001:10001::/home/keer:/bin/sh\r　只要是我们的shell命令，都可以通过这个模块在远程主机上运行，这里就不一一举例了。\n4）copy 模块 　这个模块用于将文件复制到远程主机，同时支持给定内容生成文件和修改权限等。\n其相关选项如下：\n src　#被复制到远程主机的本地文件。可以是绝对路径，也可以是相对路径。如果路径是一个目录，则会递归复制，用法类似于\u0026quot;rsync\u0026quot;\ncontent　#用于替换\u0026quot;src\u0026quot;，可以直接指定文件的值\ndest　#必选项，将源文件复制到的远程主机的绝对路径\nbackup　#当文件内容发生改变后，在覆盖之前把源文件备份，备份文件包含时间信息\ndirectory_mode　#递归设定目录的权限，默认为系统默认权限\nforce　#当目标主机包含该文件，但内容不同时，设为\u0026quot;yes\u0026quot;，表示强制覆盖；设为\u0026quot;no\u0026quot;，表示目标主机的目标位置不存在该文件才复制。默认为\u0026quot;yes\u0026quot;\nothers　#所有的 file 模块中的选项可以在这里使用\n 用法举例如下：\n① 复制文件：\n[root@server ~]# ansible web -m copy -a 'src=~/hello dest=/data/hello' 192.168.37.122 | SUCCESS =\u0026gt; {\r\u0026quot;changed\u0026quot;: true, \u0026quot;checksum\u0026quot;: \u0026quot;22596363b3de40b06f981fb85d82312e8c0ed511\u0026quot;, \u0026quot;dest\u0026quot;: \u0026quot;/data/hello\u0026quot;, \u0026quot;gid\u0026quot;: 0, \u0026quot;group\u0026quot;: \u0026quot;root\u0026quot;, \u0026quot;md5sum\u0026quot;: \u0026quot;6f5902ac237024bdd0c176cb93063dc4\u0026quot;, \u0026quot;mode\u0026quot;: \u0026quot;0644\u0026quot;, \u0026quot;owner\u0026quot;: \u0026quot;root\u0026quot;, \u0026quot;size\u0026quot;: 12, \u0026quot;src\u0026quot;: \u0026quot;/root/.ansible/tmp/ansible-tmp-1512437093.55-228281064292921/source\u0026quot;, \u0026quot;state\u0026quot;: \u0026quot;file\u0026quot;, \u0026quot;uid\u0026quot;: 0\r}\r192.168.37.133 | SUCCESS =\u0026gt; {\r\u0026quot;changed\u0026quot;: true, \u0026quot;checksum\u0026quot;: \u0026quot;22596363b3de40b06f981fb85d82312e8c0ed511\u0026quot;, \u0026quot;dest\u0026quot;: \u0026quot;/data/hello\u0026quot;, \u0026quot;gid\u0026quot;: 0, \u0026quot;group\u0026quot;: \u0026quot;root\u0026quot;, \u0026quot;md5sum\u0026quot;: \u0026quot;6f5902ac237024bdd0c176cb93063dc4\u0026quot;, \u0026quot;mode\u0026quot;: \u0026quot;0644\u0026quot;, \u0026quot;owner\u0026quot;: \u0026quot;root\u0026quot;, \u0026quot;size\u0026quot;: 12, \u0026quot;src\u0026quot;: \u0026quot;/root/.ansible/tmp/ansible-tmp-1512437093.74-44694985235189/source\u0026quot;, \u0026quot;state\u0026quot;: \u0026quot;file\u0026quot;, \u0026quot;uid\u0026quot;: 0\r}\r② 给定内容生成文件，并制定权限\n[root@server ~]# ansible web -m copy -a 'content=\u0026quot;I am keer\\n\u0026quot; dest=/data/name mode=666'\r192.168.37.122 | SUCCESS =\u0026gt; {\r\u0026quot;changed\u0026quot;: true, \u0026quot;checksum\u0026quot;: \u0026quot;0421570938940ea784f9d8598dab87f07685b968\u0026quot;, \u0026quot;dest\u0026quot;: \u0026quot;/data/name\u0026quot;, \u0026quot;gid\u0026quot;: 0, \u0026quot;group\u0026quot;: \u0026quot;root\u0026quot;, \u0026quot;md5sum\u0026quot;: \u0026quot;497fa8386590a5fc89090725b07f175c\u0026quot;, \u0026quot;mode\u0026quot;: \u0026quot;0666\u0026quot;, \u0026quot;owner\u0026quot;: \u0026quot;root\u0026quot;, \u0026quot;size\u0026quot;: 10, \u0026quot;src\u0026quot;: \u0026quot;/root/.ansible/tmp/ansible-tmp-1512437327.37-199512601767687/source\u0026quot;, \u0026quot;state\u0026quot;: \u0026quot;file\u0026quot;, \u0026quot;uid\u0026quot;: 0\r}\r192.168.37.133 | SUCCESS =\u0026gt; {\r\u0026quot;changed\u0026quot;: true, \u0026quot;checksum\u0026quot;: \u0026quot;0421570938940ea784f9d8598dab87f07685b968\u0026quot;, \u0026quot;dest\u0026quot;: \u0026quot;/data/name\u0026quot;, \u0026quot;gid\u0026quot;: 0, \u0026quot;group\u0026quot;: \u0026quot;root\u0026quot;, \u0026quot;md5sum\u0026quot;: \u0026quot;497fa8386590a5fc89090725b07f175c\u0026quot;, \u0026quot;mode\u0026quot;: \u0026quot;0666\u0026quot;, \u0026quot;owner\u0026quot;: \u0026quot;root\u0026quot;, \u0026quot;size\u0026quot;: 10, \u0026quot;src\u0026quot;: \u0026quot;/root/.ansible/tmp/ansible-tmp-1512437327.55-218104039503110/source\u0026quot;, \u0026quot;state\u0026quot;: \u0026quot;file\u0026quot;, \u0026quot;uid\u0026quot;: 0\r}\r　我们现在可以去查看一下我们生成的文件及其权限：\n[root@server ~]# ansible web -m shell -a 'ls -l /data/'\r192.168.37.122 | SUCCESS | rc=0 \u0026gt;\u0026gt;\rtotal 28\r-rw-rw-rw- 1 root root 12 Dec 6 09:45 name\r192.168.37.133 | SUCCESS | rc=0 \u0026gt;\u0026gt;\rtotal 40\r-rw-rw-rw- 1 root root 12 Dec 5 09:45 name\r　可以看出我们的name文件已经生成，并且权限为666。\n③ 关于覆盖\n我们把文件的内容修改一下，然后选择覆盖备份：\n[root@server ~]# ansible web -m copy -a 'content=\u0026quot;I am keerya\\n\u0026quot; backup=yes dest=/data/name mode=666'\r192.168.37.122 | SUCCESS =\u0026gt; {\r\u0026quot;backup_file\u0026quot;: \u0026quot;/data/name.4394.2017-12-06@09:46:25~\u0026quot;, \u0026quot;changed\u0026quot;: true, \u0026quot;checksum\u0026quot;: \u0026quot;064a68908ab9971ee85dbc08ea038387598e3778\u0026quot;, \u0026quot;dest\u0026quot;: \u0026quot;/data/name\u0026quot;, \u0026quot;gid\u0026quot;: 0, \u0026quot;group\u0026quot;: \u0026quot;root\u0026quot;, \u0026quot;md5sum\u0026quot;: \u0026quot;8ca7c11385856155af52e560f608891c\u0026quot;, \u0026quot;mode\u0026quot;: \u0026quot;0666\u0026quot;, \u0026quot;owner\u0026quot;: \u0026quot;root\u0026quot;, \u0026quot;size\u0026quot;: 12, \u0026quot;src\u0026quot;: \u0026quot;/root/.ansible/tmp/ansible-tmp-1512438383.78-228128616784888/source\u0026quot;, \u0026quot;state\u0026quot;: \u0026quot;file\u0026quot;, \u0026quot;uid\u0026quot;: 0\r}\r192.168.37.133 | SUCCESS =\u0026gt; {\r\u0026quot;backup_file\u0026quot;: \u0026quot;/data/name.5962.2017-12-05@09:46:24~\u0026quot;, \u0026quot;changed\u0026quot;: true, \u0026quot;checksum\u0026quot;: \u0026quot;064a68908ab9971ee85dbc08ea038387598e3778\u0026quot;, \u0026quot;dest\u0026quot;: \u0026quot;/data/name\u0026quot;, \u0026quot;gid\u0026quot;: 0, \u0026quot;group\u0026quot;: \u0026quot;root\u0026quot;, \u0026quot;md5sum\u0026quot;: \u0026quot;8ca7c11385856155af52e560f608891c\u0026quot;, \u0026quot;mode\u0026quot;: \u0026quot;0666\u0026quot;, \u0026quot;owner\u0026quot;: \u0026quot;root\u0026quot;, \u0026quot;size\u0026quot;: 12, \u0026quot;src\u0026quot;: \u0026quot;/root/.ansible/tmp/ansible-tmp-1512438384.0-170718946740009/source\u0026quot;, \u0026quot;state\u0026quot;: \u0026quot;file\u0026quot;, \u0026quot;uid\u0026quot;: 0\r}\r　现在我们可以去查看一下：\n[root@server ~]# ansible web -m shell -a 'ls -l /data/'\r192.168.37.122 | SUCCESS | rc=0 \u0026gt;\u0026gt;\rtotal 28\r-rw-rw-rw- 1 root root 12 Dec 6 09:46 name\r-rw-rw-rw- 1 root root 10 Dec 6 09:45 name.4394.2017-12-06@09:46:25~\r192.168.37.133 | SUCCESS | rc=0 \u0026gt;\u0026gt;\rtotal 40\r-rw-rw-rw- 1 root root 12 Dec 5 09:46 name\r-rw-rw-rw- 1 root root 10 Dec 5 09:45 name.5962.2017-12-05@09:46:24~\r　可以看出，我们的源文件已经被备份，我们还可以查看一下name文件的内容：\n[root@server ~]# ansible web -m shell -a 'cat /data/name'\r192.168.37.122 | SUCCESS | rc=0 \u0026gt;\u0026gt;\rI am keerya\r192.168.37.133 | SUCCESS | rc=0 \u0026gt;\u0026gt;\rI am keerya\r　证明，这正是我们新导入的文件的内容。\n5）file 模块 　该模块主要用于设置文件的属性，比如创建文件、创建链接文件、删除文件等。\n下面是一些常见的命令：\n force　#需要在两种情况下强制创建软链接，一种是源文件不存在，但之后会建立的情况下；另一种是目标软链接已存在，需要先取消之前的软链，然后创建新的软链，有两个选项：yes|no\ngroup　#定义文件/目录的属组。后面可以加上mode：定义文件/目录的权限\nowner　#定义文件/目录的属主。后面必须跟上path：定义文件/目录的路径\nrecurse　#递归设置文件的属性，只对目录有效，后面跟上src：被链接的源文件路径，只应用于state=link的情况\ndest　#被链接到的路径，只应用于state=link的情况\nstate　#状态，有以下选项：\n directory：如果目录不存在，就创建目录\nfile：即使文件不存在，也不会被创建\nlink：创建软链接\nhard：创建硬链接\ntouch：如果文件不存在，则会创建一个新的文件，如果文件或目录已存在，则更新其最后修改时间\nabsent：删除目录、文件或者取消链接文件\n  　用法举例如下：\n① 创建目录：\n[root@server ~]# ansible web -m file -a 'path=/data/app state=directory'\r192.168.37.122 | SUCCESS =\u0026gt; {\r\u0026quot;changed\u0026quot;: true, \u0026quot;gid\u0026quot;: 0, \u0026quot;group\u0026quot;: \u0026quot;root\u0026quot;, \u0026quot;mode\u0026quot;: \u0026quot;0755\u0026quot;, \u0026quot;owner\u0026quot;: \u0026quot;root\u0026quot;, \u0026quot;path\u0026quot;: \u0026quot;/data/app\u0026quot;, \u0026quot;size\u0026quot;: 6, \u0026quot;state\u0026quot;: \u0026quot;directory\u0026quot;, \u0026quot;uid\u0026quot;: 0\r}\r192.168.37.133 | SUCCESS =\u0026gt; {\r\u0026quot;changed\u0026quot;: true, \u0026quot;gid\u0026quot;: 0, \u0026quot;group\u0026quot;: \u0026quot;root\u0026quot;, \u0026quot;mode\u0026quot;: \u0026quot;0755\u0026quot;, \u0026quot;owner\u0026quot;: \u0026quot;root\u0026quot;, \u0026quot;path\u0026quot;: \u0026quot;/data/app\u0026quot;, \u0026quot;size\u0026quot;: 4096, \u0026quot;state\u0026quot;: \u0026quot;directory\u0026quot;, \u0026quot;uid\u0026quot;: 0\r}\r　我们可以查看一下：\n[root@server ~]# ansible web -m shell -a 'ls -l /data'\r192.168.37.122 | SUCCESS | rc=0 \u0026gt;\u0026gt;\rtotal 28\rdrwxr-xr-x 2 root root 6 Dec 6 10:21 app\r192.168.37.133 | SUCCESS | rc=0 \u0026gt;\u0026gt;\rtotal 44\rdrwxr-xr-x 2 root root 4096 Dec 5 10:21 app\r　可以看出，我们的目录已经创建完成。\n② 创建链接文件\n[root@server ~]# ansible web -m file -a 'path=/data/bbb.jpg src=aaa.jpg state=link'\r192.168.37.122 | SUCCESS =\u0026gt; {\r\u0026quot;changed\u0026quot;: true, \u0026quot;dest\u0026quot;: \u0026quot;/data/bbb.jpg\u0026quot;, \u0026quot;gid\u0026quot;: 0, \u0026quot;group\u0026quot;: \u0026quot;root\u0026quot;, \u0026quot;mode\u0026quot;: \u0026quot;0777\u0026quot;, \u0026quot;owner\u0026quot;: \u0026quot;root\u0026quot;, \u0026quot;size\u0026quot;: 7, \u0026quot;src\u0026quot;: \u0026quot;aaa.jpg\u0026quot;, \u0026quot;state\u0026quot;: \u0026quot;link\u0026quot;, \u0026quot;uid\u0026quot;: 0\r}\r192.168.37.133 | SUCCESS =\u0026gt; {\r\u0026quot;changed\u0026quot;: true, \u0026quot;dest\u0026quot;: \u0026quot;/data/bbb.jpg\u0026quot;, \u0026quot;gid\u0026quot;: 0, \u0026quot;group\u0026quot;: \u0026quot;root\u0026quot;, \u0026quot;mode\u0026quot;: \u0026quot;0777\u0026quot;, \u0026quot;owner\u0026quot;: \u0026quot;root\u0026quot;, \u0026quot;size\u0026quot;: 7, \u0026quot;src\u0026quot;: \u0026quot;aaa.jpg\u0026quot;, \u0026quot;state\u0026quot;: \u0026quot;link\u0026quot;, \u0026quot;uid\u0026quot;: 0\r}\r　我们可以去查看一下：\n[root@server ~]# ansible web -m shell -a 'ls -l /data'\r192.168.37.122 | SUCCESS | rc=0 \u0026gt;\u0026gt;\rtotal 28\r-rw-r--r-- 1 root root 5649 Dec 5 13:49 aaa.jpg\rlrwxrwxrwx 1 root root 7 Dec 6 10:25 bbb.jpg -\u0026gt; aaa.jpg\r192.168.37.133 | SUCCESS | rc=0 \u0026gt;\u0026gt;\rtotal 44\r-rw-r--r-- 1 root root 5649 Dec 4 14:44 aaa.jpg\rlrwxrwxrwx 1 root root 7 Dec 5 10:25 bbb.jpg -\u0026gt; aaa.jpg\r　我们的链接文件已经创建成功。\n③ 删除文件\n[root@server ~]# ansible web -m file -a 'path=/data/a state=absent'\r192.168.37.122 | SUCCESS =\u0026gt; {\r\u0026quot;changed\u0026quot;: true, \u0026quot;path\u0026quot;: \u0026quot;/data/a\u0026quot;, \u0026quot;state\u0026quot;: \u0026quot;absent\u0026quot;\r}\r192.168.37.133 | SUCCESS =\u0026gt; {\r\u0026quot;changed\u0026quot;: true, \u0026quot;path\u0026quot;: \u0026quot;/data/a\u0026quot;, \u0026quot;state\u0026quot;: \u0026quot;absent\u0026quot;\r}\r　我们可以查看一下：\n[root@server ~]# ansible web -m shell -a 'ls /data/a'\r192.168.37.122 | FAILED | rc=2 \u0026gt;\u0026gt;\rls: cannot access /data/a: No such file or directory\r192.168.37.133 | FAILED | rc=2 \u0026gt;\u0026gt;\rls: cannot access /data/a: No such file or directory\r　发现已经没有这个文件了。\n6）fetch 模块 　该模块用于从远程某主机获取（复制）文件到本地。\n有两个选项：\n dest：用来存放文件的目录\nsrc：在远程拉取的文件，并且必须是一个file，不能是目录\n 　具体举例如下：\n[root@server ~]# ansible web -m fetch -a 'src=/data/hello dest=/data' 192.168.37.122 | SUCCESS =\u0026gt; {\r\u0026quot;changed\u0026quot;: true, \u0026quot;checksum\u0026quot;: \u0026quot;22596363b3de40b06f981fb85d82312e8c0ed511\u0026quot;, \u0026quot;dest\u0026quot;: \u0026quot;/data/192.168.37.122/data/hello\u0026quot;, \u0026quot;md5sum\u0026quot;: \u0026quot;6f5902ac237024bdd0c176cb93063dc4\u0026quot;, \u0026quot;remote_checksum\u0026quot;: \u0026quot;22596363b3de40b06f981fb85d82312e8c0ed511\u0026quot;, \u0026quot;remote_md5sum\u0026quot;: null\r}\r192.168.37.133 | SUCCESS =\u0026gt; {\r\u0026quot;changed\u0026quot;: true, \u0026quot;checksum\u0026quot;: \u0026quot;22596363b3de40b06f981fb85d82312e8c0ed511\u0026quot;, \u0026quot;dest\u0026quot;: \u0026quot;/data/192.168.37.133/data/hello\u0026quot;, \u0026quot;md5sum\u0026quot;: \u0026quot;6f5902ac237024bdd0c176cb93063dc4\u0026quot;, \u0026quot;remote_checksum\u0026quot;: \u0026quot;22596363b3de40b06f981fb85d82312e8c0ed511\u0026quot;, \u0026quot;remote_md5sum\u0026quot;: null\r}\r　我们可以在本机上查看一下文件是否复制成功。要注意，文件保存的路径是我们设置的接收目录下的被管制主机ip目录下：\n[root@server ~]# cd /data/\r[root@server data]# ls\r1 192.168.37.122 192.168.37.133 fastdfs web\r[root@server data]# cd 192.168.37.122\r[root@server 192.168.37.122]# ls\rdata\r[root@server 192.168.37.122]# cd data/\r[root@server data]# ls\rhello\r[root@server data]# pwd\r/data/192.168.37.122/data\r7）cron 模块 　该模块适用于管理cron计划任务的。\n其使用的语法跟我们的crontab文件中的语法一致，同时，可以指定以下选项：\n day= #日应该运行的工作( 1-31, *, */2, )\nhour= # 小时 ( 0-23, *, */2, )\nminute= #分钟( 0-59, *, */2, )\nmonth= # 月( 1-12, *, /2, )\nweekday= # 周 ( 0-6 for Sunday-Saturday,, )\njob= #指明运行的命令是什么\nname= #定时任务描述\nreboot # 任务在重启时运行，不建议使用，建议使用special_time\nspecial_time #特殊的时间范围，参数：reboot（重启时），annually（每年），monthly（每月），weekly（每周），daily（每天），hourly（每小时）\nstate #指定状态，present表示添加定时任务，也是默认设置，absent表示删除定时任务\nuser # 以哪个用户的身份执行\n 　举例如下：\n① 添加计划任务\n[root@server ~]# ansible web -m cron -a 'name=\u0026quot;ntp update every 5 min\u0026quot; minute=*/5 job=\u0026quot;/sbin/ntpdate 172.17.0.1 \u0026amp;\u0026gt; /dev/null\u0026quot;'\r192.168.37.122 | SUCCESS =\u0026gt; {\r\u0026quot;changed\u0026quot;: true, \u0026quot;envs\u0026quot;: [], \u0026quot;jobs\u0026quot;: [\r\u0026quot;ntp update every 5 min\u0026quot;\r]\r}\r192.168.37.133 | SUCCESS =\u0026gt; {\r\u0026quot;changed\u0026quot;: true, \u0026quot;envs\u0026quot;: [], \u0026quot;jobs\u0026quot;: [\r\u0026quot;ntp update every 5 min\u0026quot;\r]\r}\r　我们可以去查看一下：\n[root@server ~]# ansible web -m shell -a 'crontab -l'\r192.168.37.122 | SUCCESS | rc=0 \u0026gt;\u0026gt;\r#Ansible: ntp update every 5 min\r*/5 * * * * /sbin/ntpdate 172.17.0.1 \u0026amp;\u0026gt; /dev/null\r192.168.37.133 | SUCCESS | rc=0 \u0026gt;\u0026gt;\r#Ansible: ntp update every 5 min\r*/5 * * * * /sbin/ntpdate 172.17.0.1 \u0026amp;\u0026gt; /dev/null\r　可以看出，我们的计划任务已经设置成功了。\n② 删除计划任务\n如果我们的计划任务添加错误，想要删除的话，则执行以下操作：\n首先我们查看一下现有的计划任务：\n[root@server ~]# ansible web -m shell -a 'crontab -l'\r192.168.37.122 | SUCCESS | rc=0 \u0026gt;\u0026gt;\r#Ansible: ntp update every 5 min\r*/5 * * * * /sbin/ntpdate 172.17.0.1 \u0026amp;\u0026gt; /dev/null\r#Ansible: df everyday\r* 15 * * * df -lh \u0026gt;\u0026gt; /tmp/disk_total \u0026amp;\u0026gt; /dev/null\r192.168.37.133 | SUCCESS | rc=0 \u0026gt;\u0026gt;\r#Ansible: ntp update every 5 min\r*/5 * * * * /sbin/ntpdate 172.17.0.1 \u0026amp;\u0026gt; /dev/null\r#Ansible: df everyday\r* 15 * * * df -lh \u0026gt;\u0026gt; /tmp/disk_total \u0026amp;\u0026gt; /dev/null\r　然后执行删除操作：\n[root@server ~]# ansible web -m cron -a 'name=\u0026quot;df everyday\u0026quot; hour=15 job=\u0026quot;df -lh \u0026gt;\u0026gt; /tmp/disk_total \u0026amp;\u0026gt; /dev/null\u0026quot; state=absent'\r192.168.37.122 | SUCCESS =\u0026gt; {\r\u0026quot;changed\u0026quot;: true, \u0026quot;envs\u0026quot;: [], \u0026quot;jobs\u0026quot;: [\r\u0026quot;ntp update every 5 min\u0026quot;\r]\r}\r192.168.37.133 | SUCCESS =\u0026gt; {\r\u0026quot;changed\u0026quot;: true, \u0026quot;envs\u0026quot;: [], \u0026quot;jobs\u0026quot;: [\r\u0026quot;ntp update every 5 min\u0026quot;\r]\r}\r　删除完成后，我们再查看一下现有的计划任务确认一下：\n[root@server ~]# ansible web -m shell -a 'crontab -l'\r192.168.37.122 | SUCCESS | rc=0 \u0026gt;\u0026gt;\r#Ansible: ntp update every 5 min\r*/5 * * * * /sbin/ntpdate 172.17.0.1 \u0026amp;\u0026gt; /dev/null\r192.168.37.133 | SUCCESS | rc=0 \u0026gt;\u0026gt;\r#Ansible: ntp update every 5 min\r*/5 * * * * /sbin/ntpdate 172.17.0.1 \u0026amp;\u0026gt; /dev/null\r　我们的删除操作已经成功。\n8）yum 模块 　顾名思义，该模块主要用于软件的安装。\n其选项如下：\n name=　#所安装的包的名称\nstate=　#present\u0026mdash;\u0026gt;安装， latest\u0026mdash;\u0026gt;安装最新的, absent\u0026mdash;\u0026gt; 卸载软件。\nupdate_cache　#强制更新yum的缓存\nconf_file　#指定远程yum安装时所依赖的配置文件（安装本地已有的包）。\ndisable_pgp_check　#是否禁止GPG checking，只用于presentor latest。\ndisablerepo　#临时禁止使用yum库。 只用于安装或更新时。\nenablerepo　#临时使用的yum库。只用于安装或更新时。\n 　下面我们就来安装一个包试试看：\n[root@server ~]# ansible web -m yum -a 'name=htop state=present'\r192.168.37.122 | SUCCESS =\u0026gt; {\r\u0026quot;changed\u0026quot;: true, \u0026quot;msg\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;rc\u0026quot;: 0, \u0026quot;results\u0026quot;: [\r\u0026quot;Loaded plugins: fastestmirror, langpacks\\nLoading mirror speeds from cached hostfile\\nResolving Dependencies\\n--\u0026gt; Running transaction check\\n---\u0026gt; Package htop.x86_64 0:2.0.2-1.el7 will be installed\\n--\u0026gt; Finished Dependency Resolution\\n\\nDependencies Resolved\\n\\n================================================================================\\n Package Arch Version Repository Size\\n================================================================================\\nInstalling:\\n htop x86_64 2.0.2-1.el7 epel 98 k\\n\\nTransaction Summary\\n================================================================================\\nInstall 1 Package\\n\\nTotal download size: 98 k\\nInstalled size: 207 k\\nDownloading packages:\\nRunning transaction check\\nRunning transaction test\\nTransaction test succeeded\\nRunning transaction\\n Installing : htop-2.0.2-1.el7.x86_64 1/1 \\n Verifying : htop-2.0.2-1.el7.x86_64 1/1 \\n\\nInstalled:\\n htop.x86_64 0:2.0.2-1.el7 \\n\\nComplete!\\n\u0026quot;\r]\r}\r192.168.37.133 | SUCCESS =\u0026gt; {\r\u0026quot;changed\u0026quot;: true, \u0026quot;msg\u0026quot;: \u0026quot;Warning: RPMDB altered outside of yum.\\n** Found 3 pre-existing rpmdb problem(s), 'yum check' output follows:\\nipa-client-4.4.0-12.el7.centos.x86_64 has installed conflicts freeipa-client: ipa-client-4.4.0-12.el7.centos.x86_64\\nipa-client-common-4.4.0-12.el7.centos.noarch has installed conflicts freeipa-client-common: ipa-client-common-4.4.0-12.el7.centos.noarch\\nipa-common-4.4.0-12.el7.centos.noarch has installed conflicts freeipa-common: ipa-common-4.4.0-12.el7.centos.noarch\\n\u0026quot;, \u0026quot;rc\u0026quot;: 0, \u0026quot;results\u0026quot;: [\r\u0026quot;Loaded plugins: fastestmirror, langpacks\\nLoading mirror speeds from cached hostfile\\nResolving Dependencies\\n--\u0026gt; Running transaction check\\n---\u0026gt; Package htop.x86_64 0:2.0.2-1.el7 will be installed\\n--\u0026gt; Finished Dependency Resolution\\n\\nDependencies Resolved\\n\\n================================================================================\\n Package Arch Version Repository Size\\n================================================================================\\nInstalling:\\n htop x86_64 2.0.2-1.el7 epel 98 k\\n\\nTransaction Summary\\n================================================================================\\nInstall 1 Package\\n\\nTotal download size: 98 k\\nInstalled size: 207 k\\nDownloading packages:\\nRunning transaction check\\nRunning transaction test\\nTransaction test succeeded\\nRunning transaction\\n Installing : htop-2.0.2-1.el7.x86_64 1/1 \\n Verifying : htop-2.0.2-1.el7.x86_64 1/1 \\n\\nInstalled:\\n htop.x86_64 0:2.0.2-1.el7 \\n\\nComplete!\\n\u0026quot;\r]\r}\r　安装成功。\n9）service 模块 　该模块用于服务程序的管理。\n其主要选项如下：\n arguments #命令行提供额外的参数\nenabled #设置开机启动。\nname= #服务名称\nrunlevel #开机启动的级别，一般不用指定。\nsleep #在重启服务的过程中，是否等待。如在服务关闭以后等待2秒再启动。(定义在剧本中。)\nstate #有四种状态，分别为：started\u0026mdash;\u0026gt;启动服务， stopped\u0026mdash;\u0026gt;停止服务， restarted\u0026mdash;\u0026gt;重启服务， reloaded\u0026mdash;\u0026gt;重载配置\n 　下面是一些例子：\n① 开启服务并设置自启动\n[root@server ~]# ansible web -m service -a 'name=nginx state=started enabled=true' 192.168.37.122 | SUCCESS =\u0026gt; {\r\u0026quot;changed\u0026quot;: true, \u0026quot;enabled\u0026quot;: true, \u0026quot;name\u0026quot;: \u0026quot;nginx\u0026quot;, \u0026quot;state\u0026quot;: \u0026quot;started\u0026quot;, ……\r}\r192.168.37.133 | SUCCESS =\u0026gt; {\r\u0026quot;changed\u0026quot;: true, \u0026quot;enabled\u0026quot;: true, \u0026quot;name\u0026quot;: \u0026quot;nginx\u0026quot;, \u0026quot;state\u0026quot;: \u0026quot;started\u0026quot;, ……\r}\r　我们可以去查看一下端口是否打开：\n[root@server ~]# ansible web -m shell -a 'ss -ntl'\r192.168.37.122 | SUCCESS | rc=0 \u0026gt;\u0026gt;\rState Recv-Q Send-Q Local Address:Port Peer Address:Port LISTEN 0 128 *:80 *:* 192.168.37.133 | SUCCESS | rc=0 \u0026gt;\u0026gt;\rState Recv-Q Send-Q Local Address:Port Peer Address:Port LISTEN 0 128 *:80 *:* 　可以看出我们的80端口已经打开。\n② 关闭服务\n我们也可以通过该模块来关闭我们的服务：\n[root@server ~]# ansible web -m service -a 'name=nginx state=stopped'\r192.168.37.122 | SUCCESS =\u0026gt; {\r\u0026quot;changed\u0026quot;: true, \u0026quot;name\u0026quot;: \u0026quot;nginx\u0026quot;, \u0026quot;state\u0026quot;: \u0026quot;stopped\u0026quot;, ……\r}\r192.168.37.133 | SUCCESS =\u0026gt; {\r\u0026quot;changed\u0026quot;: true, \u0026quot;name\u0026quot;: \u0026quot;nginx\u0026quot;, \u0026quot;state\u0026quot;: \u0026quot;stopped\u0026quot;, ……\r}\r　一样的，我们来查看一下端口：\n[root@server ~]# ansible web -m shell -a 'ss -ntl | grep 80'\r192.168.37.122 | FAILED | rc=1 \u0026gt;\u0026gt;\r192.168.37.133 | FAILED | rc=1 \u0026gt;\u0026gt;\r　可以看出，我们已经没有80端口了，说明我们的nginx服务已经关闭了。\n10）user 模块 　该模块主要是用来管理用户账号。\n其主要选项如下：\n comment　# 用户的描述信息\ncreatehome　# 是否创建家目录\nforce　# 在使用state=absent时, 行为与userdel –force一致.\ngroup　# 指定基本组\ngroups　# 指定附加组，如果指定为(groups=)表示删除所有组\nhome　# 指定用户家目录\nmove_home　# 如果设置为home=时, 试图将用户主目录移动到指定的目录\nname　# 指定用户名\nnon_unique　# 该选项允许改变非唯一的用户ID值\npassword　# 指定用户密码\nremove　# 在使用state=absent时, 行为是与userdel –remove一致\nshell　# 指定默认shell\nstate　# 设置帐号状态，不指定为创建，指定值为absent表示删除\nsystem　# 当创建一个用户，设置这个用户是系统用户。这个设置不能更改现有用户\nuid　# 指定用户的uid\n 　举例如下：\n① 添加一个用户并指定其 uid\n[root@server ~]# ansible web -m user -a 'name=keer uid=11111'\r192.168.37.122 | SUCCESS =\u0026gt; {\r\u0026quot;changed\u0026quot;: true, \u0026quot;comment\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;createhome\u0026quot;: true, \u0026quot;group\u0026quot;: 11111, \u0026quot;home\u0026quot;: \u0026quot;/home/keer\u0026quot;, \u0026quot;name\u0026quot;: \u0026quot;keer\u0026quot;, \u0026quot;shell\u0026quot;: \u0026quot;/bin/bash\u0026quot;, \u0026quot;state\u0026quot;: \u0026quot;present\u0026quot;, \u0026quot;stderr\u0026quot;: \u0026quot;useradd: warning: the home directory already exists.\\nNot copying any file from skel directory into it.\\nCreating mailbox file: File exists\\n\u0026quot;, \u0026quot;system\u0026quot;: false, \u0026quot;uid\u0026quot;: 11111\r}\r192.168.37.133 | SUCCESS =\u0026gt; {\r\u0026quot;changed\u0026quot;: true, \u0026quot;comment\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;createhome\u0026quot;: true, \u0026quot;group\u0026quot;: 11111, \u0026quot;home\u0026quot;: \u0026quot;/home/keer\u0026quot;, \u0026quot;name\u0026quot;: \u0026quot;keer\u0026quot;, \u0026quot;shell\u0026quot;: \u0026quot;/bin/bash\u0026quot;, \u0026quot;state\u0026quot;: \u0026quot;present\u0026quot;, \u0026quot;stderr\u0026quot;: \u0026quot;useradd: warning: the home directory already exists.\\nNot copying any file from skel directory into it.\\nCreating mailbox file: File exists\\n\u0026quot;, \u0026quot;system\u0026quot;: false, \u0026quot;uid\u0026quot;: 11111\r}\r　添加完成，我们可以去查看一下：\n[root@server ~]# ansible web -m shell -a 'cat /etc/passwd |grep keer'\r192.168.37.122 | SUCCESS | rc=0 \u0026gt;\u0026gt;\rkeer❌11111:11111::/home/keer:/bin/bash\r192.168.37.133 | SUCCESS | rc=0 \u0026gt;\u0026gt;\rkeer❌11111:11111::/home/keer:/bin/bash\r② 删除用户\n[root@server ~]# ansible web -m user -a 'name=keer state=absent'\r192.168.37.122 | SUCCESS =\u0026gt; {\r\u0026quot;changed\u0026quot;: true, \u0026quot;force\u0026quot;: false, \u0026quot;name\u0026quot;: \u0026quot;keer\u0026quot;, \u0026quot;remove\u0026quot;: false, \u0026quot;state\u0026quot;: \u0026quot;absent\u0026quot;\r}\r192.168.37.133 | SUCCESS =\u0026gt; {\r\u0026quot;changed\u0026quot;: true, \u0026quot;force\u0026quot;: false, \u0026quot;name\u0026quot;: \u0026quot;keer\u0026quot;, \u0026quot;remove\u0026quot;: false, \u0026quot;state\u0026quot;: \u0026quot;absent\u0026quot;\r}\r　一样的，删除之后，我们去看一下：\n[root@server ~]# ansible web -m shell -a 'cat /etc/passwd |grep keer'\r192.168.37.122 | FAILED | rc=1 \u0026gt;\u0026gt;\r192.168.37.133 | FAILED | rc=1 \u0026gt;\u0026gt;\r　发现已经没有这个用户了。\n11）group 模块 　该模块主要用于添加或删除组。\n常用的选项如下：\n gid=　#设置组的GID号\nname=　#指定组的名称\nstate=　#指定组的状态，默认为创建，设置值为absent为删除\nsystem=　#设置值为yes，表示创建为系统组\n 　举例如下：\n① 创建组\n[root@server ~]# ansible web -m group -a 'name=sanguo gid=12222'\r192.168.37.122 | SUCCESS =\u0026gt; {\r\u0026quot;changed\u0026quot;: true, \u0026quot;gid\u0026quot;: 12222, \u0026quot;name\u0026quot;: \u0026quot;sanguo\u0026quot;, \u0026quot;state\u0026quot;: \u0026quot;present\u0026quot;, \u0026quot;system\u0026quot;: false\r}\r192.168.37.133 | SUCCESS =\u0026gt; {\r\u0026quot;changed\u0026quot;: true, \u0026quot;gid\u0026quot;: 12222, \u0026quot;name\u0026quot;: \u0026quot;sanguo\u0026quot;, \u0026quot;state\u0026quot;: \u0026quot;present\u0026quot;, \u0026quot;system\u0026quot;: false\r}\r　创建过后，我们来查看一下：\n[root@server ~]# ansible web -m shell -a 'cat /etc/group | grep 12222' 192.168.37.122 | SUCCESS | rc=0 \u0026gt;\u0026gt;\rsanguo❌12222:\r192.168.37.133 | SUCCESS | rc=0 \u0026gt;\u0026gt;\rsanguo❌12222:\r　可以看出，我们的组已经创建成功了。\n② 删除组\n[root@server ~]# ansible web -m group -a 'name=sanguo state=absent'\r192.168.37.122 | SUCCESS =\u0026gt; {\r\u0026quot;changed\u0026quot;: true, \u0026quot;name\u0026quot;: \u0026quot;sanguo\u0026quot;, \u0026quot;state\u0026quot;: \u0026quot;absent\u0026quot;\r}\r192.168.37.133 | SUCCESS =\u0026gt; {\r\u0026quot;changed\u0026quot;: true, \u0026quot;name\u0026quot;: \u0026quot;sanguo\u0026quot;, \u0026quot;state\u0026quot;: \u0026quot;absent\u0026quot;\r}\r　照例查看一下：\n[root@server ~]# ansible web -m shell -a 'cat /etc/group | grep 12222' 192.168.37.122 | FAILED | rc=1 \u0026gt;\u0026gt;\r192.168.37.133 | FAILED | rc=1 \u0026gt;\u0026gt;\r　已经没有这个组的相关信息了。\n12）script 模块 　该模块用于将本机的脚本在被管理端的机器上运行。\n该模块直接指定脚本的路径即可，我们通过例子来看一看到底如何使用的：\n首先，我们写一个脚本，并给其加上执行权限：\n[root@server ~]# vim /tmp/df.sh\r#!/bin/bash\rdate \u0026gt;\u0026gt; /tmp/disk_total.log\rdf -lh \u0026gt;\u0026gt; /tmp/disk_total.log [root@server ~]# chmod +x /tmp/df.sh 　然后，我们直接运行命令来实现在被管理端执行该脚本：\n[root@server ~]# ansible web -m script -a '/tmp/df.sh'\r192.168.37.122 | SUCCESS =\u0026gt; {\r\u0026quot;changed\u0026quot;: true, \u0026quot;rc\u0026quot;: 0, \u0026quot;stderr\u0026quot;: \u0026quot;Shared connection to 192.168.37.122 closed.\\r\\n\u0026quot;, \u0026quot;stdout\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;stdout_lines\u0026quot;: []\r}\r192.168.37.133 | SUCCESS =\u0026gt; {\r\u0026quot;changed\u0026quot;: true, \u0026quot;rc\u0026quot;: 0, \u0026quot;stderr\u0026quot;: \u0026quot;Shared connection to 192.168.37.133 closed.\\r\\n\u0026quot;, \u0026quot;stdout\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;stdout_lines\u0026quot;: []\r}\r　照例查看一下文件内容：\n[root@server ~]# ansible web -m shell -a 'cat /tmp/disk_total.log'\r192.168.37.122 | SUCCESS | rc=0 \u0026gt;\u0026gt;\rTue Dec 5 15:58:21 CST 2017\rFilesystem Size Used Avail Use% Mounted on\r/dev/sda2 47G 4.4G 43G 10% /\rdevtmpfs 978M 0 978M 0% /dev\rtmpfs 993M 84K 993M 1% /dev/shm\rtmpfs 993M 9.1M 984M 1% /run\rtmpfs 993M 0 993M 0% /sys/fs/cgroup\r/dev/sda3 47G 33M 47G 1% /app\r/dev/sda1 950M 153M 798M 17% /boot\rtmpfs 199M 16K 199M 1% /run/user/42\rtmpfs 199M 0 199M 0% /run/user/0\r192.168.37.133 | SUCCESS | rc=0 \u0026gt;\u0026gt;\rTue Dec 5 15:58:21 CST 2017\rFilesystem Size Used Avail Use% Mounted on\r/dev/sda2 46G 4.1G 40G 10% /\rdevtmpfs 898M 0 898M 0% /dev\rtmpfs 912M 84K 912M 1% /dev/shm\rtmpfs 912M 9.0M 903M 1% /run\rtmpfs 912M 0 912M 0% /sys/fs/cgroup\r/dev/sda3 3.7G 15M 3.4G 1% /app\r/dev/sda1 1.9G 141M 1.6G 9% /boot\rtmpfs 183M 16K 183M 1% /run/user/42\rtmpfs 183M 0 183M 0% /run/user/0\r　可以看出已经执行成功了。\n13）setup 模块 　该模块主要用于收集信息，是通过调用facts组件来实现的。\nfacts组件是Ansible用于采集被管机器设备信息的一个功能，我们可以使用setup模块查机器的所有facts信息，可以使用filter来查看指定信息。整个facts信息被包装在一个JSON格式的数据结构中，ansible_facts是最上层的值。\nfacts就是变量，内建变量 。每个主机的各种信息，cpu颗数、内存大小等。会存在facts中的某个变量中。调用后返回很多对应主机的信息，在后面的操作中可以根据不同的信息来做不同的操作。如redhat系列用yum安装，而debian系列用apt来安装软件。\n① 查看信息\n我们可以直接用命令获取到变量的值，具体我们来看看例子：\n[root@server ~]# ansible web -m setup -a 'filter=\u0026quot;*mem*\u0026quot;'\t#查看内存\r192.168.37.122 | SUCCESS =\u0026gt; {\r\u0026quot;ansible_facts\u0026quot;: {\r\u0026quot;ansible_memfree_mb\u0026quot;: 1116, \u0026quot;ansible_memory_mb\u0026quot;: {\r\u0026quot;nocache\u0026quot;: {\r\u0026quot;free\u0026quot;: 1397, \u0026quot;used\u0026quot;: 587\r}, \u0026quot;real\u0026quot;: {\r\u0026quot;free\u0026quot;: 1116, \u0026quot;total\u0026quot;: 1984, \u0026quot;used\u0026quot;: 868\r}, \u0026quot;swap\u0026quot;: {\r\u0026quot;cached\u0026quot;: 0, \u0026quot;free\u0026quot;: 3813, \u0026quot;total\u0026quot;: 3813, \u0026quot;used\u0026quot;: 0\r}\r}, \u0026quot;ansible_memtotal_mb\u0026quot;: 1984\r}, \u0026quot;changed\u0026quot;: false\r}\r192.168.37.133 | SUCCESS =\u0026gt; {\r\u0026quot;ansible_facts\u0026quot;: {\r\u0026quot;ansible_memfree_mb\u0026quot;: 1203, \u0026quot;ansible_memory_mb\u0026quot;: {\r\u0026quot;nocache\u0026quot;: {\r\u0026quot;free\u0026quot;: 1470, \u0026quot;used\u0026quot;: 353\r}, \u0026quot;real\u0026quot;: {\r\u0026quot;free\u0026quot;: 1203, \u0026quot;total\u0026quot;: 1823, \u0026quot;used\u0026quot;: 620\r}, \u0026quot;swap\u0026quot;: {\r\u0026quot;cached\u0026quot;: 0, \u0026quot;free\u0026quot;: 3813, \u0026quot;total\u0026quot;: 3813, \u0026quot;used\u0026quot;: 0\r}\r}, \u0026quot;ansible_memtotal_mb\u0026quot;: 1823\r}, \u0026quot;changed\u0026quot;: false\r}\r　我们可以通过命令查看一下内存的大小以确认一下是否一致：\n[root@server ~]# ansible web -m shell -a 'free -m'\r192.168.37.122 | SUCCESS | rc=0 \u0026gt;\u0026gt;\rtotal used free shared buff/cache available\rMem: 1984 404 1122 9 457 1346\rSwap: 3813 0 3813\r192.168.37.133 | SUCCESS | rc=0 \u0026gt;\u0026gt;\rtotal used free shared buff/cache available\rMem: 1823 292 1207 9 323 1351\rSwap: 3813 0 3813\r　可以看出信息是一致的。\n② 保存信息\n我们的setup模块还有一个很好用的功能就是可以保存我们所筛选的信息至我们的主机上，同时，文件名为我们被管制的主机的IP，这样方便我们知道是哪台机器出的问题。\n我们可以看一看例子：\n[root@server tmp]# ansible web -m setup -a 'filter=\u0026quot;*mem*\u0026quot;' --tree /tmp/facts\r192.168.37.122 | SUCCESS =\u0026gt; {\r\u0026quot;ansible_facts\u0026quot;: {\r\u0026quot;ansible_memfree_mb\u0026quot;: 1115, \u0026quot;ansible_memory_mb\u0026quot;: {\r\u0026quot;nocache\u0026quot;: {\r\u0026quot;free\u0026quot;: 1396, \u0026quot;used\u0026quot;: 588\r}, \u0026quot;real\u0026quot;: {\r\u0026quot;free\u0026quot;: 1115, \u0026quot;total\u0026quot;: 1984, \u0026quot;used\u0026quot;: 869\r}, \u0026quot;swap\u0026quot;: {\r\u0026quot;cached\u0026quot;: 0, \u0026quot;free\u0026quot;: 3813, \u0026quot;total\u0026quot;: 3813, \u0026quot;used\u0026quot;: 0\r}\r}, \u0026quot;ansible_memtotal_mb\u0026quot;: 1984\r}, \u0026quot;changed\u0026quot;: false\r}\r192.168.37.133 | SUCCESS =\u0026gt; {\r\u0026quot;ansible_facts\u0026quot;: {\r\u0026quot;ansible_memfree_mb\u0026quot;: 1199, \u0026quot;ansible_memory_mb\u0026quot;: {\r\u0026quot;nocache\u0026quot;: {\r\u0026quot;free\u0026quot;: 1467, \u0026quot;used\u0026quot;: 356\r}, \u0026quot;real\u0026quot;: {\r\u0026quot;free\u0026quot;: 1199, \u0026quot;total\u0026quot;: 1823, \u0026quot;used\u0026quot;: 624\r}, \u0026quot;swap\u0026quot;: {\r\u0026quot;cached\u0026quot;: 0, \u0026quot;free\u0026quot;: 3813, \u0026quot;total\u0026quot;: 3813, \u0026quot;used\u0026quot;: 0\r}\r}, \u0026quot;ansible_memtotal_mb\u0026quot;: 1823\r}, \u0026quot;changed\u0026quot;: false\r}\r　然后我们可以去查看一下：\n[root@server ~]# cd /tmp/facts/\r[root@server facts]# ls\r192.168.37.122 192.168.37.133\r[root@server facts]# cat 192.168.37.122 {\u0026quot;ansible_facts\u0026quot;: {\u0026quot;ansible_memfree_mb\u0026quot;: 1115, \u0026quot;ansible_memory_mb\u0026quot;: {\u0026quot;nocache\u0026quot;: {\u0026quot;free\u0026quot;: 1396, \u0026quot;u\r案例 廖雪峰的博客系统itranswarp，有ansible部署脚本\nhttps://github.com/michaelliao/itranswarp\n附件 ","description":"ansible","id":6,"section":"linux","tags":null,"title":"ansible自动化运维","uri":"https://shaochenfeng.com/linux/ansible%E8%87%AA%E5%8A%A8%E5%8C%96%E8%BF%90%E7%BB%B4/"},{"content":"安装 19年7月官方安装教程，已经过时\r# CentOS\rsudo yum install -y yum-utils \\\rdevice-mapper-persistent-data \\\rlvm2\rsudo yum-config-manager \\\r--add-repo \\\rhttps://download.docker.com/linux/centos/docker-ce.repo\rsudo yum install docker-ce docker-ce-cli containerd.io\r# Ubuntu\rsudo apt-get update\rsudo apt-get install \\\rapt-transport-https \\\rca-certificates \\\rcurl \\\rgnupg-agent \\\rsoftware-properties-common\rcurl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -\rsudo add-apt-repository \\\r\u0026quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu \\\r$(lsb_release -cs) \\\rstable\u0026quot;\rsudo apt-get update\rsudo apt-get install docker-ce docker-ce-cli containerd.io\rdocker命令 容器生命周期管理\rrun 运行一个容器 run -i -t 交互式运行\rstart/stop/restart\rkill 杀死一个容器\rrm 删除一个容器\rdocker rm `docker ps -a|grep Exited|awk '{print $1}'`\rpause/unpause 暂停容器/解除暂停\rcreate 创建一个新的容器但不启动它 用法同 docker run\rexec 在运行的容器中执行命令 exec -i -t mynginx /bin/bash\r容器操作\rps 查看正在运行的容器 -a 全部（包括没有运行的）\rinspect 获取容器/镜像的元数据\rdocker inspect -f '{{.Id}}' name 获得容器的ID全称\rdocker inspect -f '{{.Name}} - {{.NetworkSettings.IPAddress }}' $(docker ps -aq) 获得所有docker容器和ip\rtop 查看容器中运行的进程信息\rattach 连接到正在运行中的容器\revents\rlogs 查看日志\rwait\rexport\rport\r容器rootfs命令\rcommit\rcp\rdiff\r镜像仓库\rlogin\rpull 下载一个镜像,拉取或者更新指定镜像\rpush\rsearch 查找镜像\r本地镜像管理\rimages 查看本机镜像\rrmi 删除镜像\rtag 给源中镜像打标签\rbuild\rhistory\rsave\rimport\rinfo|version docker版本\rdemo：用docker配置mysql、php、nginx docker pull mysql # 拉取\rdocker run --name hismysql -e MYSQL_ROOT_PASSWORD=123 -d mysql:5.7\r# 这里使用最新版mysql会有加密方式上的问题，导致phpmyadmin不能使用，所以版本我使用的5.7\rphp-fpm\rdocker run -d -v /home/zoollcar/me/hisdockerconfs/www/html:/var/www/html -p 9000:9000 --link hismysql:mysql --name hisphp php:7.2-fpm\r# docker容器中可以这样来安装php插件\rdocker-php-ext-install pdo_mysql\r# 重启启用pdo_mysql\rdocker restart hisphp\r# nginx\r# 这里/home/zoollcar/me/hisdockerconfs/nginx.conf 是我为nginx配置文件进行的挂载\r要先安装并把nginx配置文件临时容器拷贝到宿主机，因为宿主机如果nginx配置文件与容器nginx不一致无法挂载\rdocker run -d -p 80:80 --name hisnginx --link hisphp:phpfpm nginx\rdocker cp hisnginx:/etc/nginx/nginx.conf /home/zoollcar/me/hisdockerconfs/nginx.conf\rdocker stop hisnginx\rdocker rm hisnginx\r# 现在进行正式安装\rdocker run -d -p 80:80 --name hisnginx \\\r-v /home/zoollcar/me/hisdockerconfs/www/html:/usr/share/nginx/html:ro \\\r-v /home/zoollcar/me/hisdockerconfs/nginx:/etc/nginx:ro \\\r--link hisphp:phpfpm nginx\r# 修改nginx的配置文件让它支持php\r# nginx.conf 的配置文件添加\r​```\rlocation ~ \\.php$ {\rroot /var/www/html;\rfastcgi_index index.php;\rfastcgi_pass phpfpm:9000; #这里改成我们之前--link进来的容器，也可以直接用php容器的ip\rfastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;\r# 如果你的根目录和php容器的根目录不一样，这里的$document_root需要换成你php下的根目录，不然php就找不到文件了\rinclude fastcgi_params; }\r​```\rphpmyadmin\rdocker run --name hismyadmin -d --link hismysql:db -p 8880:80 phpmyadmin/phpmyadmin # 拉取并连接到本地testsql容器\r# 使用composer安装php框架\r# 因网络问题可能不能使用\rdocker run -it --name composer -v /home/zoollcar/me/hisdockerconfs/www/html:/app --privileged=true composer \u0026lt;要执行的composer命令\u0026gt;\rdemo：将正在运行的容器保存下来迁移 docker stop safe-wordpress\rdocker commit safe-wordpress zoo_wordpress:1.0\rdocker start safe-wordpress\rdocker save zoo_wordpress:1.0 \u0026gt; zoo_wordpress.tar\rdocker save zoo_notebook:1.0 \u0026gt; zoo_notebook.tar\rdocker save zoo_hustoj:1.0 \u0026gt; zoo_hustoj.tar\r# 将zoo_wordpress.tar传到另一个服务器，导入\rdocker load \u0026lt; zoo_wordpress.tar\r创建自己的docker镜像 TODO：以后补充吧\ndockerfile 文件用于创建新的镜像文件\ndocker-compose 用来配置一个应用所需镜像的依赖关系和启动方式，直接启动一个应用\n附件 ","description":"docker","id":7,"section":"linux","tags":null,"title":"docker容器","uri":"https://shaochenfeng.com/linux/docker%E5%AE%B9%E5%99%A8/"},{"content":"Linus 定义 Linux\n英文：Linus Torvalds，翻译：开源中国\nwww.oschina.net/translate/linux-a-free-unix-386-kernel\n本文是 Linus 写于 1991年10月10日\nLINUX是什么？\nLINUX是一个免费类unix内核，适用于386-AT计算机，附带完整源代码。主要让黑客、计算机科学学生使用，学习和享受。它大部分用C编写，但是一小部分是用gnu格式汇编，而且引导序列用的是因特尔086汇编语言。C代码是相对ANSI的，使用一些GNU增强特性（大多为 asm 和 inline）。\n然而有很多可用于386电脑的unices，他们大部分要花很多钱，而且不附带源码。因此他们是使用计算机的理想选择，但是如果你想了解他们如何工作，那是不可能的。\n也有一些 Unix 是附带源码的。Minix，Andrew S. Tanenbaum编写的学习工具，已经在大学中作为教学工具使用了很多年了。BSD-386系统是附带源码的，但是有版权限制，而且要花很多钱（我记得起始价格为$995）。GNU内核（Hurd）将会是免费的，但是现在还没有准备好，而且对于了解和学习它们来说有点庞大。\nLINUX与Minix是最相似的，由于它很小而且不是非常复杂，因此易于理解（嗯…）。LINUX是基于Minix编写的，因此有相当多的相同点，任何Minix黑客在使用LINUX的时候都感觉非常熟悉。不过，没有在项目中使用Minix代码，因此Minix版权没有限制到这个新系统。它也是完全免费的，而且它的版权非常宽松。因此不像使用Minix，它不需要几兆字节大小的区别。\nLINUX版权\n虽然是免费的发布版，我还是从以下几个方面限制了LINUX的使用：\n你可以自由复制和重新发布源码和二进制，只要是：\n完全开源。因此不能单独发布二进制，即使你只修改了一点。\n你不能从发布版获取利益。事实上甚至“装卸费用”都是不被接受的。\n你要保持完整的适当版权。\n根据需要你可能会修改源码，但是如果你发布了新系统的一部分（或者只有二进制），必须将新的代码包含进去。\n除了不包含版权的代码之外，你可能会做一些小的修改。这由你来定，但是如果能将相关内容或者代码告诉我，将不胜感激。\n对任何使用或者扩展系统的人来说，这应该足够宽松而不会引起任何担忧。如果你有朋友真的不想要源码，只想要一个能运行的二进制，你当然可以给他而不用担心我会起诉你。不过最好只在朋友之间这么做。\nLINUX运行所需的硬件/软件\nLINUX是在一个运行Minix的386-AT上开发的。由于LINUX是一个真正的操作系统，而且需要直接与硬件交互来做一些事情，你必须有一个非常相似的系统来让他顺利运行：\n386-AT（PS/2之类是不同的，不能正常运行）\nVGA或者EGA屏幕硬件。\n标准AT硬盘接口，IDE盘可以运行（实际上我用的就是这个）。\n正常实模式BIOS。一些机器看起来是用虚-86模式运行启动程序，而且在这样的机器LINUX不会启动和正常运行。\nLINUX会发展成为一个自给自足的系统，现在需要Minix-386才能正常运行。你需要Minix让初始化启动文件系统，和编译OS二进制。在那之后LINUX是一个自给自足的系统，但是为了做文件系统检查（fsck）和修改之后重编译系统，推荐使用Minix。\n获取LINUX\nLINUX现在可以使用匿名ftp从‘nic.funet.fi’的‘/pub/OS/Linux’目录获取。这个目录包含操作系统的所有源码，还有一些二进制文件，因此你可以真正使用系统了。\n注意！二进制大多是GNU软件，而且版权比LINUX的严格（GNU非盈利性版权）。因此你不能在不发布他们源码的情况下重新发布他们，可以在/pub/GNU中找到。关于GNU非盈利性版权，从任何GNU软件包了解更多。\n此目录中各类文件如下：\nlinux-0.03.tar.Z–系统的完全源码，16位tar压缩文件格式。\nLinux.tex–这个文件的LATEX源码。\nbash.Z–在LINUX下运行的bash二进制文件。这个二进制文件应该放到预留给LINUX文件系统中的/bin/sh下（参见installation）。\nupdate.Z–更新二进制文件，要放到/bin/update。\ngccbin.tar.Z–GNU cc二进制文件需要由一个可运行的编译器。这个tar压缩包含有编译器，加载器，汇编程序和支持程序（nm，strip等）。它还包含一个小型的库，可用于大部分程序。\ninclude.tar.Z–让gcc运行的必要include文件。\nunistd.tar.Z–unistd库程序的源码（即系统调用接口）。通过这个你可以使用系统独立库源码编译一个大一些的库。\nutilbin.tar.Z–各种GNU工具的二进制文件，包括GNU的fileutils，make和tar。也包含克隆emacs的uemacs。\nREADME, RELNOTES-0.01, INSTALLATION–包含一些（有点过时的）LINUX相关的信息的ascii文件。\n让系统运行的最少文件是OS源码和bash和更新二进制文件。不过只用这些，你做不了什么事。\n安装\n在你拿到了必要LINUX文件之后，你需要编译系统和创建root目录。必要的二进制文件需要放到root文件系统中。按如下操作：\n 备份你的软件。虽然LINUX从没有毁坏过我的任何文件，但没有什么是必然的。安全胜过遗憾。 选择/创建一个标准MinixHD-分区作为新的LINUX root文件系统。 在新的root创建必要的设备节点。LINUX与Minix使用相同类型的节点，所以使用Minix的mknod命令创建下面的设备：节点号与在Minix中相同。\n/dev/tty\n/dev/tty[0-2]\n/dev/hd[0-9] 将必要文件放到新的root分区。文件应该放在下面目录中：\n希望你现在有一个功能正常的unix，而且你已经root权限登录。LINUX现在没有‘init’过程，只要你注销，系统会同步并等待。使用三指键（Ctrl+Alt+Del）重启机器。  gcc\n添加链接到你选择的/usr/local/lib中的文件。我将ld，as，nm，strip和size链接到他们相应的 /usr/local/lib/gcc-XXX。\ngccbin.tar.Z中的内容，除了gcc\ninclude.tar.Z的内容\nutilbin.tar.Z的内容\nsh，即bash.Z\nupdate\n/bin:\n/usr/bin:\n/usr/include:\n/usr/local/lib:\n/usr/local/bin:\n编辑系统中的linux/include/linux/config.h。这个文件包含了针对于系统的信息：内存空间，硬盘类型，root分区号（同样的与Minix中的编号相同），键盘类型（现在只有US和Finnish）等。\n编译LINUX源码。一个简单技巧就可以完成，在你编辑makefiles为适合你的系统之后（即，删除-mstring-insnsflag，和修改适合你的路径。）1.40之前版本gcc的用户可能需要添加gnulib到makefile中‘LIBS=’一行。\n复制产生的镜像文件到软盘（即，cp Image /dev/PS0 或者之类的）。\n使用新的软盘重启。启动界面应该告诉你系统正在启动（加载系统…），然后是一些必要的文件系统信息（xxx/XXX inodes/blocks free），接下来是一个确定，还有bash提示（如果你没有.bashrc文件，则初始化bash#）。\nLINUX 缺失/不兼容的东西\nLINUX 是打算作为一个全部自给自足的内核，但现在并非如此。作为上面已经提到的，你需要 Minix 来设置启动设备并且检查文件系统当它运行起来的时候。这里有一些其它的不足之处：\n硬件的不兼容。一些 AT 标准特性当前还没有支持。最值得注意的是软盘驱动，利用 LINUX 进行实际工作（备份 etc）当前是不可能的[译者：这个是 oldlinux，这个是 Linus Torvalds 1991 年 10 月写的文章，肯定当时是不行的]。还有串行连接的一些特性没有被实现（2400 bps 波特率的硬连接，没有挂断（hang-up）提示等等 ）。\n标准 c 库的不兼容。gcc 分发版的 libc.a 没有完成，我对免费可发布的库功能很感兴趣。\n一些系统调用没有完全实现。这些设计绝大多数“极少调用”的特性比如调试（谁无论如何需要它的话，你的程序第一次是无法工作的:-)）以及其它的特性。\n如上所述，没有登陆和初始化进程。当前 LINUX 启动在单用户模式，以 root 作为控制台用户。对于一些移植工作足够了，但不是实际可用的。\n387支持[译者：硬件浮点，当时 Intel 发布了外接式 FPU] 没有被实现，即使已有一些基础程序被提供出来。”nic.funet.fi” 的 gcc 二进制包使用软浮点（ie 仿真功能调用）来支持 4 个基础数学运算操作。387-支持将尽快实现当我的电脑安装了这个硬件。希望在一个月或者两个月。\n现在还没有重要的系统管理命令实现在 LINUX 中。这些包括 mkfs, format, fsck, mknod 等。这些命令需要的内核特性还没有实现（format, mknod），一些命令只需要实现它。作为一个库，我欢迎任何免费分发文件。\n如您所见，LINUX还不是一个完整的系统。 感谢您的帮助，使其变得更好。 我对为LINUX重写的Minix命令不感兴趣，除非你自己从头开始编写它们。 您当然可以免费（并鼓励）将您的Minix发行版中的所有内容用于您自己的LINUX系统，但由于Minix的版权，它们无法分发给更广泛的受众。\n这里提到的一些问题将由我（即lines/387/floppy支持）尽快修复，但我希望得到库函数的支持。感谢你们提交的错误报告及补丁还有愿望清单，如果你真的有针对问题的补丁，我会立即尝试去修复它。 小的更改将作为补丁形式发送到邮件列表，并在nic.funet.fi\u0026rsquo;上设置，如果经过大量重写，或者修复大的补丁，整个系统将在nic.funet.fi’更新。\nLINUX移植软件\nLINUX被设计得让移植相对容易。因此，就有了完整的termios实现和一些POSIX库。我所移植的（诚然相对较少）程序没有任何问题。\n尽管LINUX与Minix非常相似，但Minix程序通常并不会比为其他nuix设计的程序更容易移植。因此，我不建议从一个特定程序的Minix版本开始，而应该尝试从头开始移植‘’virgin‘’程序。比BSD更接近SYSV，这意味着当给定一个-DUSG或者-DSYSV标识时，大多数程序很容易移植。\n移植过程中最困难的一点就是缺少库函数。这些必须由你来编写，或者从其他的来源复制（Minix可能是个有缘人）。另外，一些程序（特别是GNU）有各种各样的标识，这些标识可以定义哪些函数不可用（一旦在Makefile中添加了足够量的-DXXX_MISSING标识，GNU fileutils将编译的很好）。\n已经移植的程序\n下面这些程序已经移植到LINUX：\nGNU cc (gcc, cc1, cpp)\nGNU assembler (as386)\nGNU binutils (ld, ar, nm, size, strip, ranlib)\nGNU compress (16-bit)\nGNU tar\nGNU make\nGNU bash (Bourne Again SHell)\nGNU sed\nGNU bison (yacc-lookalike)\nGNU awk\nGNU fileutils (ls, cp, rm, mkdir, rmdir, tail etc)\nless\nuemacs\n所有上述程序都能在‘nic.funet.fi’(主要在’/pub/gnu’)中找到，大多数LIINUX-binaries都可以在‘/pub/OS/Linux’目录中找到。包括gcc（cc1）有一些我自己增强的功能，所有这些程序都在没有变化的情况下编译的。先尝试自己编译，遇到问题可以将差异或者资源发邮件给我。\n另外，我提起过明确地GNU差异编译和运行。\n技术帮助\nLINUX目前有一个邮件列表，您可以通过邮件发送到这个地址订阅：Linux-activists-request@niksula.hut.fi ，并要求包括在列表中。然后你可以通过这个邮箱：Linux-activists@niksula.hut.fi 提问题，这将复制你的问题/答案/无论什么，并发送给列表中其他所有人。\n请注意Linux-activists和Linux0activists-request的不同——第一个用于给列表中的所有人发送邮件，第二个仅用于订阅和取消订阅。\n当然，您也可以直接发送邮件至 torvalds@kruuna.helsinki.fi。我会尽量在一两天内回答所有的问题。\n尽管‘nic.funet.fi’可能会保持合理的更新状态，但是它还有些问题（即，我无法因为个人得到文件，但可以通过几个人）。因此，如果邮件列表上的人想要补丁或二进制文件，他们将会更快得到。\n感谢\n我要感谢学院…\n说真的，如果没有其他人的帮助，这个系统将永远不会有曙光，甚至会变得更糟。Bruce Evans 帮助我找到了需要更改的位置，以便gcc能正确地处理浮点数，并提供许多有用的想法/建议（他的Minix-386用于构建系统）。此外，Earl Chew 的estdio包被用于标准的IO库。像这样更自由地分发包！\nAlain W Black和Richard Tobin为Minix制作了gcc，没有它我就无法编译这个东西。GNU完成了我在Linux下使用的大部分程序。Alfred Leung发送了美国键盘补丁。\n附：“感谢”wirzeniu@kruuna.helsinki.fi他的“建设性”批评和“诙谐”的评论。他是我第一个 alpha-测试者，他应该被授予勇气奖章。\nLinus Torvalds (torvalds@kruuna.helsinki.fi) 1991年10月10日\n","description":"Linus定义Linux","id":8,"section":"linux","tags":null,"title":"Linus定义Linux","uri":"https://shaochenfeng.com/linux/linux%E5%9F%BA%E7%A1%80%E5%92%8C%E5%8E%9F%E7%90%86/linus%E5%AE%9A%E4%B9%89linux/"},{"content":"MongoDB是一种Nosql数据库，基于文档的数据库，是Nosql中最接近sql数据库的，使用类似json的数据格式，以文档的方式管理数据库\n这里使用的Ubuntu为例\n安装 sudo apt-get install mongodb\n启动并开机启动\nsudo systemctl start mongodb\nsudo service mongodb start\nsql与MongoDB对比    SQL术语/概念 MongoDB术语/概念 解释/说明     database database 数据库   table collection 数据库表/集合   row document 数据记录行/文档   column field 数据字段/域   index index 索引   table joins 表连接,MongoDB不支持   primary key primary key 主键,MongoDB自动将_id字段设置为主键    mongo：MongoDB的shell命令模式\n数据库操作 show dbs:显示数据库列表\nshow collections：显示当前数据库中的集合\nshow users：显示所有用户\nuse yourDB：切换当前数据库至yourDB\ndb.help() ：显示数据库操作命令\ndb.yourCollection.help() ：显示集合操作命令，yourCollection是集合名\nMongoDB不用新建数据库，使用一个数据库就会新建它\n插入数据\ninsert和save是一样的，插入一条数据\ndb.student.insert({_id:1, sname: \u0026lsquo;zhangsan\u0026rsquo;, sage: 20})\ndb.student.save({_id:1, sname: \u0026lsquo;zhangsan\u0026rsquo;, sage: 22})\n","description":"MongoDB","id":9,"section":"linux","tags":null,"title":"MongoDB","uri":"https://shaochenfeng.com/linux/%E6%95%B0%E6%8D%AE%E5%BA%93/mongodb/"},{"content":"历史 linux操作系统经历了从Sysvinit，到Upstart再到Systemd的进化，\n还有其他的启动管理程序，但是用的不多\nSysvinit 其中Sysvinit是使用最悠久的，它使用运行级别进行不同程序的启动\nSysvinit 的配置文件是/etc/inittab\n读取完配置文件后，\nsysvinit 顺序地执行以下这些步骤，从而将系统初始化为预订的 runlevel X。\n/etc/rc.d/rc.sysinit\n/etc/rc.d/rc 和/etc/rc.d/rcX.d/ (X 代表运行级别 0-6)\n/etc/rc.d/rc.local\nX Display Manager（如果需要的话）\n系统关闭时，会将/etc/rc.d/rcX.d/目录下所有 K 开头的脚本执行\nUpStart UpStart是ubuntu在给系统安装在笔记本上时，发现传统的方式是串行的，\n不能并发也不能进行延后执行（比如插入打印机后再启动驱动）\n所以开发了UpStart\n它使用job工作单位和event事件进行控制\nSystemd 这是我们的主角Systemd，从ubuntu15开始，ubuntu也不使用UpStart了\nsystemctl是 Systemd 的主命令，用于管理系统\n教程 Systemd 入门教程：命令篇——阮一峰\nhttp://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-commands.html\nSystemd 是 Linux 系统工具，用来启动守护进程，已成为大多数发行版的标准配置。\n本文介绍它的基本用法，分为上下两篇。今天介绍它的主要命令，下一篇介绍如何用于实战。\n一、由来 历史上，Linux 的启动一直采用init进程。\n下面的命令用来启动服务。\n 1 2 3  $ sudo /etc/init.d/apache2 start # 或者 $ service apache2 start    这种方法有两个缺点。\n一是启动时间长。init进程是串行启动，只有前一个进程启动完，才会启动下一个进程。\n二是启动脚本复杂。init进程只是执行启动脚本，不管其他事情。脚本需要自己处理各种情况，这往往使得脚本变得很长。\n二、Systemd 概述 Systemd 就是为了解决这些问题而诞生的。它的设计目标是，为系统的启动和管理提供一套完整的解决方案。\n根据 Linux 惯例，字母d是守护进程（daemon）的缩写。 Systemd 这个名字的含义，就是它要守护整个系统。\n（上图为 Systemd 作者 Lennart Poettering）\n使用了 Systemd，就不需要再用init了。Systemd 取代了initd，成为系统的第一个进程（PID 等于 1），其他进程都是它的子进程。\n 1  $ systemctl --version    上面的命令查看 Systemd 的版本。\nSystemd 的优点是功能强大，使用方便，缺点是体系庞大，非常复杂。事实上，现在还有很多人反对使用 Systemd，理由就是它过于复杂，与操作系统的其他部分强耦合，违反\u0026quot;keep simple, keep stupid\u0026quot;的Unix 哲学。\n（上图为 Systemd 架构图）\n三、系统管理 Systemd 并不是一个命令，而是一组命令，涉及到系统管理的方方面面。\n3.1 systemctl systemctl是 Systemd 的主命令，用于管理系统。\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  # 重启系统 $ sudo systemctl reboot # 关闭系统，切断电源 $ sudo systemctl poweroff # CPU停止工作 $ sudo systemctl halt # 暂停系统 $ sudo systemctl suspend # 让系统进入冬眠状态 $ sudo systemctl hibernate # 让系统进入交互式休眠状态 $ sudo systemctl hybrid-sleep # 启动进入救援状态（单用户状态） $ sudo systemctl rescue    3.2 systemd-analyze systemd-analyze命令用于查看启动耗时。\n 1 2 3 4 5 6 7 8 9 10 11  # 查看启动耗时 $ systemd-analyze # 查看每个服务的启动耗时 $ systemd-analyze blame # 显示瀑布状的启动过程流 $ systemd-analyze critical-chain # 显示指定服务的启动流 $ systemd-analyze critical-chain atd.service    3.3 hostnamectl hostnamectl命令用于查看当前主机的信息。\n 1 2 3 4 5  # 显示当前主机的信息 $ hostnamectl # 设置主机名。 $ sudo hostnamectl set-hostname rhel7    3.4 localectl localectl命令用于查看本地化设置。\n 1 2 3 4 5 6  # 查看本地化设置 $ localectl # 设置本地化参数。 $ sudo localectl set-locale LANG=en_GB.utf8 $ sudo localectl set-keymap en_GB    3.5 timedatectl timedatectl命令用于查看当前时区设置。\n 1 2 3 4 5 6 7 8 9 10  # 查看当前时区设置 $ timedatectl # 显示所有可用的时区 $ timedatectl list-timezones # 设置当前时区 $ sudo timedatectl set-timezone America/New_York $ sudo timedatectl set-time YYYY-MM-DD $ sudo timedatectl set-time HH:MM:SS    3.6 loginctl loginctl命令用于查看当前登录的用户。\n 1 2 3 4 5 6 7 8  # 列出当前session $ loginctl list-sessions # 列出当前登录用户 $ loginctl list-users # 列出显示指定用户的信息 $ loginctl show-user ruanyf    四、Unit 4.1 含义 Systemd 可以管理所有系统资源。不同的资源统称为 Unit（单位）。\nUnit 一共分成12种。\n  Service unit：系统服务 Target unit：多个 Unit 构成的一个组 Device Unit：硬件设备 Mount Unit：文件系统的挂载点 Automount Unit：自动挂载点 Path Unit：文件或路径 Scope Unit：不是由 Systemd 启动的外部进程 Slice Unit：进程组 Snapshot Unit：Systemd 快照，可以切回某个快照 Socket Unit：进程间通信的 socket Swap Unit：swap 文件 Timer Unit：定时器   systemctl list-units命令可以查看当前系统的所有 Unit 。\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14  # 列出正在运行的 Unit $ systemctl list-units # 列出所有Unit，包括没有找到配置文件的或者启动失败的 $ systemctl list-units --all # 列出所有没有运行的 Unit $ systemctl list-units --all --state=inactive # 列出所有加载失败的 Unit $ systemctl list-units --failed # 列出所有正在运行的、类型为 service 的 Unit $ systemctl list-units --type=service    4.2 Unit 的状态 systemctl status命令用于查看系统状态和单个 Unit 的状态。\n 1 2 3 4 5 6 7 8  # 显示系统状态 $ systemctl status # 显示单个 Unit 的状态 $ sysystemctl status bluetooth.service # 显示远程主机的某个 Unit 的状态 $ systemctl -H root@rhel7.example.com status httpd.service    除了status命令，systemctl还提供了三个查询状态的简单方法，主要供脚本内部的判断语句使用。\n 1 2 3 4 5 6 7 8  # 显示某个 Unit 是否正在运行 $ systemctl is-active application.service # 显示某个 Unit 是否处于启动失败状态 $ systemctl is-failed application.service # 显示某个 Unit 服务是否建立了启动链接 $ systemctl is-enabled application.service    4.3 Unit 管理 对于用户来说，最常用的是下面这些命令，用于启动和停止 Unit（主要是 service）。\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  # 立即启动一个服务 $ sudo systemctl start apache.service # 立即停止一个服务 $ sudo systemctl stop apache.service # 重启一个服务 $ sudo systemctl restart apache.service # 杀死一个服务的所有子进程 $ sudo systemctl kill apache.service # 重新加载一个服务的配置文件 $ sudo systemctl reload apache.service # 重载所有修改过的配置文件 $ sudo systemctl daemon-reload # 显示某个 Unit 的所有底层参数 $ systemctl show httpd.service # 显示某个 Unit 的指定属性的值 $ systemctl show -p CPUShares httpd.service # 设置某个 Unit 的指定属性 $ sudo systemctl set-property httpd.service CPUShares=500    4.4 依赖关系 Unit 之间存在依赖关系：A 依赖于 B，就意味着 Systemd 在启动 A 的时候，同时会去启动 B。\nsystemctl list-dependencies命令列出一个 Unit 的所有依赖。\n 1  $ systemctl list-dependencies nginx.service    上面命令的输出结果之中，有些依赖是 Target 类型（详见下文），默认不会展开显示。如果要展开 Target，就需要使用--all参数。\n 1  $ systemctl list-dependencies --all nginx.service    五、Unit 的配置文件 5.1 概述 每一个 Unit 都有一个配置文件，告诉 Systemd 怎么启动这个 Unit 。\nSystemd 默认从目录/etc/systemd/system/读取配置文件。但是，里面存放的大部分文件都是符号链接，指向目录/usr/lib/systemd/system/，真正的配置文件存放在那个目录。\nsystemctl enable命令用于在上面两个目录之间，建立符号链接关系。\n 1 2 3  $ sudo systemctl enable clamd@scan.service # 等同于 $ sudo ln -s \u0026#39;/usr/lib/systemd/system/clamd@scan.service\u0026#39; \u0026#39;/etc/systemd/system/multi-user.target.wants/clamd@scan.service\u0026#39;    如果配置文件里面设置了开机启动，systemctl enable命令相当于激活开机启动。\n与之对应的，systemctl disable命令用于在两个目录之间，撤销符号链接关系，相当于撤销开机启动。\n 1  $ sudo systemctl disable clamd@scan.service    配置文件的后缀名，就是该 Unit 的种类，比如sshd.socket。如果省略，Systemd 默认后缀名为.service，所以sshd会被理解成sshd.service。\n5.2 配置文件的状态 systemctl list-unit-files命令用于列出所有配置文件。\n 1 2 3 4 5  # 列出所有配置文件 $ systemctl list-unit-files # 列出指定类型的配置文件 $ systemctl list-unit-files --type=service    这个命令会输出一个列表。\n 1 2 3 4 5 6  $ systemctl list-unit-files UNIT FILE STATE chronyd.service enabled clamd@.service static clamd@scan.service disabled    这个列表显示每个配置文件的状态，一共有四种。\n  enabled：已建立启动链接 disabled：没建立启动链接 static：该配置文件没有[Install]部分（无法执行），只能作为其他配置文件的依赖 masked：该配置文件被禁止建立启动链接   注意，从配置文件的状态无法看出，该 Unit 是否正在运行。这必须执行前面提到的systemctl status命令。\n 1  $ systemctl status bluetooth.service    一旦修改配置文件，就要让 SystemD 重新加载配置文件，然后重新启动，否则修改不会生效。\n 1 2  $ sudo systemctl daemon-reload $ sudo systemctl restart httpd.service    5.3 配置文件的格式 配置文件就是普通的文本文件，可以用文本编辑器打开。\nsystemctl cat命令可以查看配置文件的内容。\n 1 2 3 4 5 6 7 8 9 10 11  $ systemctl cat atd.service [Unit] Description=ATD daemon [Service] Type=forking ExecStart=/usr/bin/atd [Install] WantedBy=multi-user.target    从上面的输出可以看到，配置文件分成几个区块。每个区块的第一行，是用方括号表示的区别名，比如[Unit]。注意，配置文件的区块名和字段名，都是大小写敏感的。\n每个区块内部是一些等号连接的键值对。\n 1 2 3 4 5  [Section] Directive1=value Directive2=value . . .    注意，键值对的等号两侧不能有空格。\n5.4 配置文件的区块 [Unit]区块通常是配置文件的第一个区块，用来定义 Unit 的元数据，以及配置与其他 Unit 的关系。它的主要字段如下。\n  Description：简短描述 Documentation：文档地址 Requires：当前 Unit 依赖的其他 Unit，如果它们没有运行，当前 Unit 会启动失败 Wants：与当前 Unit 配合的其他 Unit，如果它们没有运行，当前 Unit 不会启动失败 BindsTo：与Requires类似，它指定的 Unit 如果退出，会导致当前 Unit 停止运行 Before：如果该字段指定的 Unit 也要启动，那么必须在当前 Unit 之后启动 After：如果该字段指定的 Unit 也要启动，那么必须在当前 Unit 之前启动 Conflicts：这里指定的 Unit 不能与当前 Unit 同时运行 Condition...：当前 Unit 运行必须满足的条件，否则不会运行 Assert...：当前 Unit 运行必须满足的条件，否则会报启动失败   [Install]通常是配置文件的最后一个区块，用来定义如何启动，以及是否开机启动。它的主要字段如下。\n  WantedBy：它的值是一个或多个 Target，当前 Unit 激活时（enable）符号链接会放入/etc/systemd/system目录下面以 Target 名 + .wants后缀构成的子目录中 RequiredBy：它的值是一个或多个 Target，当前 Unit 激活时，符号链接会放入/etc/systemd/system目录下面以 Target 名 + .required后缀构成的子目录中 Alias：当前 Unit 可用于启动的别名 Also：当前 Unit 激活（enable）时，会被同时激活的其他 Unit   [Service]区块用来 Service 的配置，只有 Service 类型的 Unit 才有这个区块。它的主要字段如下。\n  Type：定义启动时的进程行为。它有以下几种值。 Type=simple：默认值，执行ExecStart指定的命令，启动主进程 Type=forking：以 fork 方式从父进程创建子进程，创建后父进程会立即退出 Type=oneshot：一次性进程，Systemd 会等当前服务退出，再继续往下执行 Type=dbus：当前服务通过D-Bus启动 Type=notify：当前服务启动完毕，会通知Systemd，再继续往下执行 Type=idle：若有其他任务执行完毕，当前服务才会运行 ExecStart：启动当前服务的命令 ExecStartPre：启动当前服务之前执行的命令 ExecStartPost：启动当前服务之后执行的命令 ExecReload：重启当前服务时执行的命令 ExecStop：停止当前服务时执行的命令 ExecStopPost：停止当其服务之后执行的命令 RestartSec：自动重启当前服务间隔的秒数 Restart：定义何种情况 Systemd 会自动重启当前服务，可能的值包括always（总是重启）、on-success、on-failure、on-abnormal、on-abort、on-watchdog TimeoutSec：定义 Systemd 停止当前服务之前等待的秒数 Environment：指定环境变量   Unit 配置文件的完整字段清单，请参考官方文档。\n六、Target 启动计算机的时候，需要启动大量的 Unit。如果每一次启动，都要一一写明本次启动需要哪些 Unit，显然非常不方便。Systemd 的解决方案就是 Target。\n简单说，Target 就是一个 Unit 组，包含许多相关的 Unit 。启动某个 Target 的时候，Systemd 就会启动里面所有的 Unit。从这个意义上说，Target 这个概念类似于\u0026quot;状态点\u0026quot;，启动某个 Target 就好比启动到某种状态。\n传统的init启动模式里面，有 RunLevel 的概念，跟 Target 的作用很类似。不同的是，RunLevel 是互斥的，不可能多个 RunLevel 同时启动，但是多个 Target 可以同时启动。\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  # 查看当前系统的所有 Target $ systemctl list-unit-files --type=target # 查看一个 Target 包含的所有 Unit $ systemctl list-dependencies multi-user.target # 查看启动时的默认 Target $ systemctl get-default # 设置启动时的默认 Target $ sudo systemctl set-default multi-user.target # 切换 Target 时，默认不关闭前一个 Target 启动的进程， # systemctl isolate 命令改变这种行为， # 关闭前一个 Target 里面所有不属于后一个 Target 的进程 $ sudo systemctl isolate multi-user.target    Target 与 传统 RunLevel 的对应关系如下。\n 1 2 3 4 5 6 7 8 9  Traditional runlevel New target name Symbolically linked to... Runlevel 0 | runlevel0.target -\u0026gt; poweroff.target Runlevel 1 | runlevel1.target -\u0026gt; rescue.target Runlevel 2 | runlevel2.target -\u0026gt; multi-user.target Runlevel 3 | runlevel3.target -\u0026gt; multi-user.target Runlevel 4 | runlevel4.target -\u0026gt; multi-user.target Runlevel 5 | runlevel5.target -\u0026gt; graphical.target Runlevel 6 | runlevel6.target -\u0026gt; reboot.target    它与init进程的主要差别如下。\n （1）默认的 RunLevel（在/etc/inittab文件设置）现在被默认的 Target 取代，位置是/etc/systemd/system/default.target，通常符号链接到graphical.target（图形界面）或者multi-user.target（多用户命令行）。\n（2）启动脚本的位置，以前是/etc/init.d目录，符号链接到不同的 RunLevel 目录 （比如/etc/rc3.d、/etc/rc5.d等），现在则存放在/lib/systemd/system和/etc/systemd/system目录。\n（3）配置文件的位置，以前init进程的配置文件是/etc/inittab，各种服务的配置文件存放在/etc/sysconfig目录。现在的配置文件主要存放在/lib/systemd目录，在/etc/systemd目录里面的修改可以覆盖原始设置。\n 七、日志管理 Systemd 统一管理所有 Unit 的启动日志。带来的好处就是，可以只用journalctl一个命令，查看所有日志（内核日志和应用日志）。日志的配置文件是/etc/systemd/journald.conf。\njournalctl功能强大，用法非常多。\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80  # 查看所有日志（默认情况下 ，只保存本次启动的日志） $ sudo journalctl # 查看内核日志（不显示应用日志） $ sudo journalctl -k # 查看系统本次启动的日志 $ sudo journalctl -b $ sudo journalctl -b -0 # 查看上一次启动的日志（需更改设置） $ sudo journalctl -b -1 # 查看指定时间的日志 $ sudo journalctl --since=\u0026#34;2012-10-30 18:17:16\u0026#34; $ sudo journalctl --since \u0026#34;20 min ago\u0026#34; $ sudo journalctl --since yesterday $ sudo journalctl --since \u0026#34;2015-01-10\u0026#34; --until \u0026#34;2015-01-11 03:00\u0026#34; $ sudo journalctl --since 09:00 --until \u0026#34;1 hour ago\u0026#34; # 显示尾部的最新10行日志 $ sudo journalctl -n # 显示尾部指定行数的日志 $ sudo journalctl -n 20 # 实时滚动显示最新日志 $ sudo journalctl -f # 查看指定服务的日志 $ sudo journalctl /usr/lib/systemd/systemd # 查看指定进程的日志 $ sudo journalctl _PID=1 # 查看某个路径的脚本的日志 $ sudo journalctl /usr/bin/bash # 查看指定用户的日志 $ sudo journalctl _UID=33 --since today # 查看某个 Unit 的日志 $ sudo journalctl -u nginx.service $ sudo journalctl -u nginx.service --since today # 实时滚动显示某个 Unit 的最新日志 $ sudo journalctl -u nginx.service -f # 合并显示多个 Unit 的日志 $ journalctl -u nginx.service -u php-fpm.service --since today # 查看指定优先级（及其以上级别）的日志，共有8级 # 0: emerg # 1: alert # 2: crit # 3: err # 4: warning # 5: notice # 6: info # 7: debug $ sudo journalctl -p err -b # 日志默认分页输出，--no-pager 改为正常的标准输出 $ sudo journalctl --no-pager # 以 JSON 格式（单行）输出 $ sudo journalctl -b -u nginx.service -o json # 以 JSON 格式（多行）输出，可读性更好 $ sudo journalctl -b -u nginx.serviceqq -o json-pretty # 显示日志占据的硬盘空间 $ sudo journalctl --disk-usage # 指定日志文件占据的最大空间 $ sudo journalctl --vacuum-size=1G # 指定日志文件保存多久 $ sudo journalctl --vacuum-time=1years    ","description":"systemd启动管理","id":10,"section":"linux","tags":null,"title":"systemd启动管理","uri":"https://shaochenfeng.com/linux/linux%E5%9F%BA%E7%A1%80%E5%92%8C%E5%8E%9F%E7%90%86/systemd%E5%90%AF%E5%8A%A8%E7%AE%A1%E7%90%86/"},{"content":"tar Linux下的归档使用工具，用来打包和备份。\n补充说明\ntar命令 可以为linux的文件和目录创建档案。利用tar，可以为某一特定文件创建档案（备份文件），也可以在档案中改变文件，或者向档案中加入新的文件。tar最初被用来在磁带上创建档案，现在，用户可以在任何设备上创建档案。利用tar命令，可以把一大堆的文件和目录全部打包成一个文件，这对于备份文件或将几个文件组合成为一个文件以便于网络传输是非常有用的。\n首先要弄清两个概念：打包和压缩。打包是指将一大堆文件或目录变成一个总的文件；压缩则是将一个大的文件通过一些压缩算法变成一个小文件。\n为什么要区分这两个概念呢？这源于Linux中很多压缩程序只能针对一个文件进行压缩，这样当你想要压缩一大堆文件时，你得先将这一大堆文件先打成一个包（tar命令），然后再用压缩程序进行压缩（gzip bzip2命令）。\n语法\ntar(选项)(参数)\n选项\n-A或\u0026ndash;catenate：新增文件到以存在的备份文件；\n-B：设置区块大小；\n-c或\u0026ndash;create：建立新的备份文件；\n-C \u0026lt;目录\u0026gt;：这个选项用在解压缩，若要在特定目录解压缩，可以使用这个选项。\n-d：记录文件的差别；\n-x或\u0026ndash;extract或\u0026ndash;get：从备份文件中还原文件；\n-t或\u0026ndash;list：列出备份文件的内容；\n-z或\u0026ndash;gzip或\u0026ndash;ungzip：通过gzip指令处理备份文件；\n-Z或\u0026ndash;compress或\u0026ndash;uncompress：通过compress指令处理备份文件；\n-f\u0026lt;备份文件\u0026gt;或\u0026ndash;file=\u0026lt;备份文件\u0026gt;：指定备份文件；\n-v或\u0026ndash;verbose：显示指令执行过程；\n-r：添加文件到已经压缩的文件；\n-u：添加改变了和现有的文件到已经存在的压缩文件；\n-j：支持bzip2解压文件；\n-v：显示操作过程；\n-l：文件系统边界设置；\n-k：保留原有文件不覆盖；\n-m：保留文件不被覆盖；\n-w：确认压缩文件的正确性；\n-p或\u0026ndash;same-permissions：用原来的文件权限还原文件；\n-P或\u0026ndash;absolute-names：文件名使用绝对名称，不移除文件名称前的“/”号；\n-N \u0026lt;日期格式\u0026gt; 或 \u0026ndash;newer=\u0026lt;日期时间\u0026gt;：只将较指定日期更新的文件保存到备份文件里；\n\u0026ndash;exclude=\u0026lt;范本样式\u0026gt;：排除符合范本样式的文件。\n参数\n文件或目录：指定要打包的文件或目录列表。\n实例\n z：有gzip属性的 j：有bz2属性的 Z：有compress属性的 v：显示所有过程 O：将文件解开到标准输出\n下面的参数-f是必须的  -f: 使用档案名字，切记，这个参数是最后一个参数，后面只能接档案名。\ntar -cf all.tar *.jpg\n这条命令是将所有.jpg的文件打成一个名为all.tar的包。-c是表示产生新的包，-f指定包的文件名。\ntar -rf all.tar *.gif\n这条命令是将所有.gif的文件增加到all.tar的包里面去。-r是表示增加文件的意思。\ntar -uf all.tar logo.gif\n这条命令是更新原来tar包all.tar中logo.gif文件，-u是表示更新文件的意思。\ntar -tf all.tar\n这条命令是列出all.tar包中所有文件，-t是列出文件的意思\nzip格式 压缩： zip -r [目标文件名].zip [原文件/目录名]\n解压： unzip [原文件名].zip\n注：-r参数代表递归\n解压windows上压缩的zip 解压单个文件\nunzip -O GBK web.zip\n解压多个文件\nfor i in *\rdo\runzip -O GBK $i\rdone\rtar格式（该格式仅仅打包，不压缩） 打包：tar -cvf [目标文件名].tar [原文件名/目录名]\n解包：tar -xvf [原文件名].tar\n注：c参数代表create（创建），x参数代表extract（解包），v参数代表verbose（详细信息），f参数代表filename（文件名），所以f后必须接文件名。\ntar.gz格式 方式一：利用前面已经打包好的tar文件，直接用压缩命令。\n压缩：gzip [原文件名].tar\n解压：gunzip [原文件名].tar.gz\n方式二：一次性打包并压缩、解压并解包\n打包并压缩： tar -zcvf [目标文件名].tar.gz [原文件名/目录名]\n解压并解包： tar -zxvf [原文件名].tar.gz\n注：z代表用gzip算法来压缩/解压。\ntar.bz2格式 方式一：利用已经打包好的tar文件，直接执行压缩命令：\n压缩：bzip2 [原文件名].tar\n解压：bunzip2 [原文件名].tar.bz2\n方式二：一次性打包并压缩、解压并解包\n打包并压缩： tar -jcvf [目标文件名].tar.bz2 [原文件名/目录名]\n解压并解包： tar -jxvf [原文件名].tar.bz2\n注：小写j代表用bzip2算法来压缩/解压。\ntar.xz格式 方式一：利用已经打包好的tar文件，直接用压缩命令：\n压缩：xz [原文件名].tar\n解压：unxz [原文件名].tar.xz\n方式二：一次性打包并压缩、解压并解包\n打包并压缩： tar -Jcvf [目标文件名].tar.xz [原文件名/目录名]\n解压并解包： tar -Jxvf [原文件名].tar.xz\n注：大写J代表用xz算法来压缩/解压。\ntar.Z格式（已过时） 方式一：利用已经打包好的tar文件，直接用压缩命令：\n压缩：compress [原文件名].tar\n解压：uncompress [原文件名].tar.Z\n方式二：一次性打包并压缩、解压并解包\n打包并压缩： tar -Zcvf [目标文件名].tar.Z [原文件名/目录名]\n解压并解包： tar -Zxvf [原文件名].tar.Z\n注：大写Z代表用ncompress算法来压缩/解压。另，ncompress是早期Unix系统的压缩格式，但由于ncompress的压缩率太低，现已过时。\njar格式 压缩：jar -cvf [目标文件名].jar [原文件名/目录名]\n解压：jar -xvf [原文件名].jar\n注：如果是打包的是Java类库，并且该类库中存在主类，那么需要写一个META-INF/MANIFEST.MF配置文件，内容如下：\nManifest-Version: 1.0\nCreated-By: 1.6.0_27 (Sun Microsystems Inc.)\nMain-class: the_name_of_the_main_class_should_be_put_here\n然后用如下命令打包：\njar -cvfm [目标文件名].jar META-INF/MANIFEST.MF [原文件名/目录名] 这样以后就能用“java -jar [文件名].jar”命令直接运行主类中的public static void main方法了。\n7z格式 压缩：7z a [目标文件名].7z [原文件名/目录名]\n解压：7z x [原文件名].7z\n注：这个7z解压命令支持rar格式，即：\n7z x [原文件名].rar\n其它例子\n将文件全部打包成tar包 ：\ntar -cvf log.tar log2012.log 仅打包，不压缩！ tar -zcvf log.tar.gz log2012.log 打包后，以 gzip 压缩 tar -jcvf log.tar.bz2 log2012.log 打包后，以 bzip2 压缩\n在选项f之后的文件档名是自己取的，我们习惯上都用 .tar 来作为辨识。 如果加z选项，则以.tar.gz或.tgz来代表gzip压缩过的tar包；如果加j选项，则以.tar.bz2来作为tar包名。\n查阅上述tar包内有哪些文件 ：\ntar -ztvf log.tar.gz\n由于我们使用 gzip 压缩的log.tar.gz，所以要查阅log.tar.gz包内的文件时，就得要加上z这个选项了。\n将tar包解压缩 ： tar -zxvf /opt/soft/test/log.tar.gz\n在预设的情况下，我们可以将压缩档在任何地方解开的\n只将tar内的部分文件解压出来 ：\ntar -zxvf /opt/soft/test/log30.tar.gz log2013.log\n我可以透过tar -ztvf来查阅 tar 包内的文件名称，如果单只要一个文件，就可以透过这个方式来解压部分文件！\n文件备份下来，并且保存其权限 ：\ntar -zcvpf log31.tar.gz log2014.log log2015.log log2016.log\n这个-p的属性是很重要的，尤其是当您要保留原本文件的属性时。\n在文件夹当中，比某个日期新的文件才备份 ：\ntar -N \u0026ldquo;2012/11/13\u0026rdquo; -zcvf log17.tar.gz test\n备份文件夹内容是排除部分文件：\ntar \u0026ndash;exclude scf/service -zcvf scf.tar.gz scf/*\n其实最简单的使用 tar 就只要记忆底下的方式即可：\n压　缩：tar -jcv -f filename.tar.bz2 要被压缩的文件或目录名称\n查　询：tar -jtv -f filename.tar.bz2\n解压缩：tar -jxv -f filename.tar.bz2 -C 欲解压缩的目录\n","description":"tar命令和各种压缩格式的压缩和解压","id":11,"section":"linux","tags":null,"title":"tar命令和各种压缩格式的压缩和解压","uri":"https://shaochenfeng.com/linux/linux%E5%9F%BA%E7%A1%80%E5%92%8C%E5%8E%9F%E7%90%86/tar%E5%91%BD%E4%BB%A4%E5%92%8C%E5%90%84%E7%A7%8D%E5%8E%8B%E7%BC%A9%E6%A0%BC%E5%BC%8F%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%92%8C%E8%A7%A3%E5%8E%8B/"},{"content":"yum管理RPM包\nyum [选项][参数]\n-h\t显示帮助\n-y\t自动回答‘yes’\n-c\t指定配置文件\n-v\t详细模式\ninstall\nupdate\ncheck-update\nremove\nlist\ngrouplist\nsearch\ninfo\nclean\nshell\nresolvedep\nlocalinstall\nlocalupdate\ndeplist\n附件 ","description":"yum","id":12,"section":"linux","tags":null,"title":"yum","uri":"https://shaochenfeng.com/linux/linux%E5%9F%BA%E7%A1%80%E5%92%8C%E5%8E%9F%E7%90%86/rhel%E7%BA%A2%E5%B8%BD%E7%B3%BB/yum/"},{"content":"设置中国时区 cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime\n设置系统语言 export LC_ALL=zh_CN.UTF-8\n","description":"中文、时区、编码","id":13,"section":"linux","tags":null,"title":"中文、时区、编码","uri":"https://shaochenfeng.com/linux/linux%E5%9F%BA%E7%A1%80%E5%92%8C%E5%8E%9F%E7%90%86/%E4%B8%AD%E6%96%87%E6%97%B6%E5%8C%BA%E7%BC%96%E7%A0%81/"},{"content":"getenforce # 检查SELinux的状态\n临时关闭\nsetenforce 0\n长期关闭\n修改/etc/selinux/config 文件\n将SELINUX=enforcing改为SELINUX=disabled\n","description":"关闭SELinux","id":14,"section":"linux","tags":null,"title":"关闭SELinux","uri":"https://shaochenfeng.com/linux/linux%E5%9F%BA%E7%A1%80%E5%92%8C%E5%8E%9F%E7%90%86/rhel%E7%BA%A2%E5%B8%BD%E7%B3%BB/%E5%85%B3%E9%97%ADselinux/"},{"content":"对centos LVM逻辑分区的扩容\n首先扩展LVM分区\n然后扩展逻辑卷:\n[root@pc ~]# lvdisplay ## 查看逻辑卷\n[root@pc ~]# lvextend -l +100%FREE /dev/centos/root ## 将剩余百分百空间都添加到逻辑卷中\n[root@pc ~]# lvdisplay ## 看看逻辑卷的空间是否增大\n[root@pc ~]# xfs_growfs /dev/centos/root ## 重新识别一下分区大小\n[root@oracle01 ~]# df -h ## 扩容成功\n","description":"对centos LVM逻辑分区的扩容","id":15,"section":"linux","tags":null,"title":"对centos LVM逻辑分区的扩容","uri":"https://shaochenfeng.com/linux/linux%E5%9F%BA%E7%A1%80%E5%92%8C%E5%8E%9F%E7%90%86/rhel%E7%BA%A2%E5%B8%BD%E7%B3%BB/%E5%AF%B9centos-lvm%E9%80%BB%E8%BE%91%E5%88%86%E5%8C%BA%E7%9A%84%E6%89%A9%E5%AE%B9/"},{"content":"以GBK编码某个读写文件 读入: 1 2 3  BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(\u0026#34;a.txt\u0026#34;), Charset.forName(\u0026#34;GBK\u0026#34;))); String str = br.readLine(); br.close();   写出: 1 2 3 4  BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(\u0026#34;a.txt\u0026#34;), Charset.forName(\u0026#34;GBK\u0026#34;))); bw.write(\u0026#34;hello\u0026#34;); bw.flush(); bw.close();   使用try-with-resource语法确保close被执行 1 2 3 4 5 6 7 8 9 10  try (BufferedInputStream bin = new BufferedInputStream(new FileInputStream(\u0026#34;test.txt\u0026#34;), Charset.forName(\u0026#34;GBK\u0026#34;)); BufferedOutputStream bout = new BufferedOutputStream(new FileOutputStream(\u0026#34;out.txt\u0026#34;, Charset.forName(\u0026#34;GBK\u0026#34;)))) { int b; while ((b = bin.read()) != -1) { bout.write(b); } } catch (IOException e) { e.printStackTrace(); }   查看系统默认字符集 1 2  Charset c = Charset.defaultCharset(); System.out.println(c.name());   输出所有的支持字符集 1 2 3 4 5 6  SortedMap\u0026lt;String, Charset\u0026gt; sm = CharsetavailableCharsets(); Set\u0026lt;String\u0026gt; keyset = sm.keySet(); System.out.println(\u0026#34;Java 支持的所有字符集\u0026#34;; for (String s : keyset) { System.out.println(s); }   字符编码互转 1 2 3 4 5 6 7  String a = \u0026#34;我是中国人\u0026#34;;\tString b = new String(a.getBytes(\u0026#34;UTF-8\u0026#34;), \u0026#34;GBK\u0026#34;); System.out.println(b); String c = new String(b.getBytes(\u0026#34;GBK\u0026#34;), \u0026#34;UTF-8\u0026#34;); System.out.println(c);   ","description":"","id":16,"section":"blog","tags":["java","字符编码"],"title":"Java 读写GBK编码的文件","uri":"https://shaochenfeng.com/blog/java-%E8%AF%BB%E5%86%99gbk%E7%BC%96%E7%A0%81%E7%9A%84%E6%96%87%E4%BB%B6/"},{"content":"检查你的项目 如果你的项目根目录下有 pom.xml 文件，可以认为是Maven项目，参照下面Maven项目执行\n如果你的项目根目录下有 build.gradle 文件，可以认为是Gradle项目，参照下面Gradle项目执行\nMaven项目 1.安装Maven 如果已经安装过maven，可以跳过这步\nMaven可作为zip文件从https://maven.apache.org/download.cgi下载。\n安装Maven只需要二进制文件，下载下图两个压缩包中一个\n下载完压缩文件后，将其解压缩到计算机上。然后将bin文件夹添加到环境变量path中。\n打开Maven目录下的 conf/settings.xml 文件\n注释掉官方仓库，换位阿里源以提高依赖下载速度\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  \u0026lt;mirrors\u0026gt; \u0026lt;!-- \u0026lt;mirror\u0026gt; \u0026lt;id\u0026gt;mirrorId\u0026lt;/id\u0026gt; \u0026lt;mirrorOf\u0026gt;repositoryId\u0026lt;/mirrorOf\u0026gt; \u0026lt;name\u0026gt;Human Readable Name for this Mirror.\u0026lt;/name\u0026gt; \u0026lt;url\u0026gt;http://my.repository.com/repo/path\u0026lt;/url\u0026gt; \u0026lt;/mirror\u0026gt; --\u0026gt; \u0026lt;mirror\u0026gt; \u0026lt;id\u0026gt;nexus-aliyun\u0026lt;/id\u0026gt; \u0026lt;mirrorOf\u0026gt;*\u0026lt;/mirrorOf\u0026gt; \u0026lt;name\u0026gt;Nexus aliyun\u0026lt;/name\u0026gt; \u0026lt;url\u0026gt;http://maven.aliyun.com/nexus/content/groups/public\u0026lt;/url\u0026gt; \u0026lt;/mirror\u0026gt; \u0026lt;/mirrors\u0026gt;   测试Maven安装是否成功，从命令行运行mvn：\nmvn -v\r如果看到版本信息，说明安装成功\n2.编译并运行 编译项目为jar包\nmvn package\r可以打包为jar或war，取决于packaging值，通常都是jar\njar包可以直接运行\njava -jar target/gs-maven-0.1.0.jar\r至此，项目运行成功\n如果有依赖问题，用这条语句安装依赖\nmvn install\r依赖都会在pom.xml中声明\n这条语句进行测试\nmvn test\rGradle项目 1.安装Gradle 如果已经安装过Gradle，可以跳过这步\nGradle可从https://maven.apache.org/download.cgi下载。\n安装Gradle请下载下图命名格式的压缩包\n下载完压缩文件后，将其解压缩到计算机上。然后将bin文件夹添加到环境变量path中。\n测试Gradle安装是否成功，从命令行运行gradle：\ngradle -v\r如果看到版本信息，说明安装成功\n2.编译执行 编译项目为jar包\ngradle build\rjar包可以直接运行\njava -jar build/libs/XXXX.jar\r至此，项目运行成功\n如果遇到依赖下载缓慢，可以打开项目目录下的build.gradle文件，找到 repositories，注释掉mavenCentral(),使用阿里云的仓库地址\nrepositories {\r//mavenCentral()\rmaven {\rurl 'http://maven.aliyun.com/nexus/content/groups/public/'\r}\r}\r","description":"","id":17,"section":"blog","tags":["Maven","Gradle"],"title":"用命令行构建和运行springboot项目","uri":"https://shaochenfeng.com/blog/%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%9E%84%E5%BB%BA%E8%BF%90%E8%A1%8Cspringboot%E9%A1%B9%E7%9B%AE/"},{"content":"全部案例 配置git用户名邮件\n单纯的下载一个仓库\n将远程仓库的更新拉到本地仓库（不影响本地已有的提交）\n将本地修改上传到远程仓库\n将本地更改上传到远程仓库，并使本地远程一致\n新建一个仓库并用本地代码初始化\n我不想同步某些文件/文件夹\n从master创建临时分支作修改，然后合并到主分支\n删除仓库所有历史记录，仅保留当前文件\n修改前n次commit的提交信息\n配置git用户名邮件 1 2  git config --global user.name \u0026#34;Your Name\u0026#34; git config --global user.email \u0026#34;email@example.com\u0026#34;   单纯的下载一个仓库 最常用的方法\n1  git clone https://github.com/xxx/xxx.git   项目太大，想快点下载，不需要历史记录\n1  git clone --depth 1 https://github.com/xxx/xxx.git   想快速下载非master分支\n1 2 3 4 5  git clone --depth 1 https://github.com/xxx/xxx.git cd xxx git remote set-branches origin \u0026#39;remote_branch_name\u0026#39; git fetch --depth 1 origin remote_branch_name git checkout remote_branch_name   将远程仓库的更新拉到本地仓库（不影响本地已有的提交） 1  git pull origin master   将本地修改上传到远程仓库 1 2 3  git add . git commit -m \u0026#34;提交说明\u0026#34; git push origin master   将本地更改上传到远程仓库，并使本地远程一致 1 2 3 4  git add . git commit -m \u0026#34;提交说明\u0026#34; git pull origin master git push origin master   新建一个仓库并用本地代码初始化 首先到github或其他git网站上创建一个新仓库，获得新仓库地址，类似于 https://github.com/xxx/xxx.git\n1 2 3 4 5  git init git add -A git commit -m \u0026#34;初始化代码\u0026#34; git remote add origin https://github.com/xxx/xxx.git git push -u origin master   我不想同步某些文件/文件夹 在仓库的根目录下新建 .gitignore 文件\n其中写上要忽略的内容，支持文件、文件夹、通配符\n1 2 3 4  target/ .idea/ *.log somefile.txt   从master创建临时分支作修改，然后合并到主分支  创建临时分支  1 2 3 4 5 6  git checkout master git pull origin master git checkout -b tmp git push origin tmp # 在远程也创建临时分支 git branch --set-upstream-to=origin/tmp git pull origin tmp   用你喜欢的方式作修改代码，在此过程中可以提交代码  1 2 3  git add . git commit -m \u0026#34;提交说明\u0026#34; git push origin tmp   最后合并分支tmp到master，然后删除tmp  1 2 3 4 5  git checkout master git merge tmp git push origin master git branch -d tmp git push origin --delete tmp   删除仓库所有历史记录，仅保留当前文件 1 2 3 4 5 6  git checkout --orphan lastest # 从0新建分支 git add -A # 添加所有当前文件到分支 git commit -m \u0026#34;init信息\u0026#34; git branch -D master # 删除master分支 git branch -m master # 重命名当前分支为master git push -f origin master # 强制提交到远程   修改前n次commit的提交信息 1 2 3 4  git rebase -i HEAD~n # 这里查看最近n次commit提交信息 # 然后进入编辑模式，将需要修改的commit那一行的pick修改为edit，保存退出 git commit --amend # 这会进入上面修改对应的commit提交信息 git rebase --continue # 回到正常状态   ","description":"","id":18,"section":"blog","tags":["git"],"title":"写给大忙人看的Git案例总结","uri":"https://shaochenfeng.com/blog/%E5%86%99%E7%BB%99%E5%A4%A7%E5%BF%99%E4%BA%BA%E7%9C%8B%E7%9A%84git%E6%A1%88%E4%BE%8B%E6%80%BB%E7%BB%93/"},{"content":"安装中文支持 不然安装以后web界面不能设置为中文\n1 2  dnf install langpacks-zh_CN # 在centos7中是 yum install kde-l10n-Chinese   下载源码 浏览器打开 https://www.zabbix.com/download_sources\n下载最新的长期支持版，上传到服务器\n在服务器解压\n1 2 3 4 5  tar -zxvf zabbix-4.4.4.tar.gz cd zabbix-4.4.4/ # 增加zabbix使用的组和用户 groupadd --system zabbix useradd --system -g zabbix -d /usr/lib/zabbix -s /sbin/nologin -c \u0026#34;Zabbix Monitoring System\u0026#34; zabbix   配置数据库 需要先安装数据库，mysql5.7及以上，没有安装的可以看这篇文章 yum安装mysql8\n然后配置zabbix的数据库和用户权限\n1 2 3 4 5  mysql -uroot -p # 输入登陆密码 mysql\u0026gt; create database zabbix character set utf8 collate utf8_bin; mysql\u0026gt; grant all privileges on zabbix.* to zabbix@localhost identified by \u0026#39;123\u0026#39;; mysql\u0026gt; quit;   导入zabbix数据库\n1 2 3  mysql -uzabbix -p123 zabbix \u0026lt; database/mysql/schema.sql mysql -uzabbix -p123 zabbix \u0026lt; database/mysql/images.sql mysql -uzabbix -p123 zabbix \u0026lt; database/mysql/data.sql   编译zabbix 首先安装编译要用到的工具，除了下面标出的还需要常规编译经常用到的 gcc 等，报错的时候缺啥补啥即可\n1  dnf -y install net-snmp-devel libevent-devel libxml2-devel libcurl-devel pcre-devel   编译安装\n./configure --enable-server --enable-agent --with-mysql=/usr/local/mysql/bin/mysql_config --enable-ipv6 --with-net-snmp --with-libcurl --with-libxml2 --prefix=/opt/zabbix4.0\r# 最后一个选项，我安装到了 /opt/zabbix4.0 目录下，你可以选择自己喜欢的目录\rmake install\r配置 修改 agentd 端和 server 端的配置，主要配置数据库账号密码和连接方式，顺便配置日志位置\ncd /opt/zabbix4.0\nvim etc/zabbix_agentd.conf\n# 这些配置找到对应的行修改即可\rServer=127.0.0.1\rLogFile=/opt/zabbix4.0/zabbix_agentd.log\rPidFile=/opt/zabbix4.0/zabbix_agentd.pid\rvim etc/zabbix_server.conf\nLogFile=/opt/zabbix4.4/zabbix_server.log\rPidFile=/opt/zabbix4.4/zabbix_server.pid\rDBPassword=123\rDBSocket=/tmp/mysql.sock\rnginx虚拟主机配置 为了不影响当前的网站，我们使用虚拟主机的来配置zabbix web界面\n首先参照网上的教程安装nginx并配置php\n将 zabbix web 文件复制到 nginx目录\ncd /usr/share/nginx\nmkdir zabbix\ncp ~/zabbix-4.0/frontends/php/* zabbix/ -r\nchown nginx:nginx zabbix -R\n配置虚拟主机\nvim /etc/nginx/nginx.conf\n#增加\rserver {\rlisten 80;\rlisten [::]:80;\raccess_log log/zabbix.你的域名.com;\rerror_log log/zabbix.你的域名.com.err error;\rserver_name zabbix.你的域名.com;\rroot /usr/share/nginx/zabbix\rlocation / {\r}\r}\r最后 访问 http://zabbix.你的域名.com/ 皆可安装\n默认的账户密码是 Admin/zabbix\n官方安装教程【英文】 https://www.zabbix.com/documentation/4.0/manual/installation/install\n","description":"","id":19,"section":"blog","tags":["CentOS8","zabbix"],"title":"Centos8安装zabbix监控，源码方式","uri":"https://shaochenfeng.com/blog/cento8%E5%AE%89%E8%A3%85szabbix%E7%9B%91%E6%8E%A7/"},{"content":"第一次接触RPM包的概念，初学者可能会不知所措，因为它给人留下了学习曲线陡峭的的印象。在本文中，我将演示用最少的知识和经验来构建RPM。请注意，本文只是作为入门，而不是RPM的完整指南。\n基于ASCII的俄罗斯方块游戏 在我的演示中，我选择了一个简单的基于ASCII的终端游戏，用C编写。过程中做了一些细微的调整以确保可以相对简单的进行RPM构建。我将以一个名为Vitetris的游戏为例。您可以下载该游戏。\n为确保创建RPM软件包时没有错误，我删除了Makefile中将文件权限更改为root的参数，以允许非root用户构建RPM。修改如下：\n$ cat Makefile |grep 'INSTALL '\rINSTALL = install\r#INSTALL = install -oroot -groot # non-root users building the rpm won't be able to set this and the RPM build will fail.\r进行此更改后，请创建一个新的压缩tarball，重命名为：vitetris-0.57.tar.gz。\n准备环境 安装开发环境在红帽企业Linux（RHEL）7系统上，你需要以下存储库构建RPM：rhel-7-server-rpms，rhel-7-server-extras-rpms和rhel-7-server-optional-rpms。\n您需要安装以下软件包：\n# yum install -y rpm* gcc gpg* rng-tools\r我使用rpm*，gpg*因为它使安装时要记住的事情变得更少更加易于管理。\n手动编译软件 RPM打包成功的很大一步是了解您正在使用的软件。首先，最好以非root用户身份进行手动编译软件。我使用rpmbuilder用户。\n首先提取压缩的tarball（vitetris-0.57.tar.gz），然后检查README文件。在这种情况下，自述文件不包含有关从源代码编译游戏的信息。一般的，用C语言编写的开源软件编译可分为三个步骤：configure，make，和make install。这次我们单独运行make以查看软件是否可以构建。\n作为非root用户，请测试运行make是否成功：\n[rpmbuilder@rpm vitetris-0.57]$ make\rgenerating src/src-conf.mk\r./src-conf.sh 'cc' '' ''\r...\rDone.\rNow run ./tetris (or make install)\r要测试游戏，只需运行./tetris以查看游戏是否可以正常游玩：\n创建GPG密钥 对您的RPM软件包进行签名会让您的软件包更可信。因此，要以rpmbuilder用户身份创建GPG密钥。您需要一个具有root权限的会话来运行rngd（以加快生成过程），并需要一个具有X11转发功能的会话作为rpmbuilder用户。\n以root身份运行：\n# rngd -r /dev/urandom\r如果出现以下错误：\nFailed to init entropy source 2: Intel RDRAND Instruction RNG\r尝试：\n# rngd -r /dev/urandom -o /dev/random -f\r您必须以具有X11转发功能的rpmbuilder用户会话登录到主机（否则，密钥生成将失败）：\n$ gpg --gen-key\r...\rPlease select what kind of key you want:\r(1) RSA and RSA (default)\r(2) DSA and Elgamal\r(3) DSA (sign only)\r(4) RSA (sign only)\rYour selection? 1\rRSA keys may be between 1024 and 4096 bits long.\rWhat keysize do you want? (2048) Requested keysize is 2048 bits\rPlease specify how long the key should be valid.\r0 = key does not expire\r\u0026lt;n\u0026gt; = key expires in n days\r\u0026lt;n\u0026gt;w = key expires in n weeks\r\u0026lt;n\u0026gt;m = key expires in n months\r\u0026lt;n\u0026gt;y = key expires in n years\rKey is valid for? (0) Key does not expire at all\rIs this correct? (y/N) y\rGnuPG needs to construct a user ID to identify your key.\rReal name: RPM Build User\rEmail address: rpmbuilder@rpm\rComment: RPM Builder GPG Signing Key\rYou selected this USER-ID:\r\u0026quot;RPM Build User (RPM Builder GPG Signing Key) \u0026lt;rpmbuilder@rpm\u0026gt;\u0026quot;\rChange (N)ame, (C)omment, (E)mail or (O)kay/(Q)uit? O\rYou need a Passphrase to protect your secret key.\r 仅当您打开X11转发时，才会出现此提示。\n ...\rgpg: depth: 0 valid: 1 signed: 0 trust: 0-, 0q, 0n, 0m, 0f, 1u\rpub 2048R/EEF6D9AD 2019-03-02\rKey fingerprint = 6ED1 2456 B7ED EEC6 D0DF B870 444A 40A7 EEF6 D9AD\ruid RPM Build User (RPM Builder GPG Signing Key) \u0026lt;rpmbuilder@rpm\u0026gt;\rsub 2048R/D498F883 2019-03-02\r如果您需要在自定义软件或在yum仓库配置中使用的此密钥时，可以使用以下命令导出密钥：\n$ gpg --armor --export\r-----BEGIN PGP PUBLIC KEY BLOCK-----\rVersion: GnuPG v2.0.22 (GNU/Linux)\r为Vitetris游戏创建RPM包 要构建RPM，首先创建构建目录树和spec文件，然后将源代码放在正确的位置：\n$ rpmdev-setuptree\r$ rpmdev-newspec rpmbuild/SPECS/vitetris.spec\rrpmbuild/SPECS/vitetris.spec created; type minimal, rpm version \u0026gt;= 4.11.\r$ cp vitetris-0.57.tar.gz rpmbuild/SOURCES/\r将初始详细信息添加到spec文件中 提供初始详细信息：\nName: vitetris\rVersion: 0.57\rRelease: 1%{?dist}\rSummary: ASCII based tetris game\rLicense: BSD\rURL: https://www.victornils.net/tetris/\rSource0: vitetris-0.57.tar.gz\rBuildRequires: gcc\r删除不必要的部分  删除该Requires部分，因为此软件没有任何依赖性。 删除此%configure部分，因为无需构建此软件configure（如果需要configure，请保留此部分，然后再运行make）。  添加描述信息 您可以在这里添加任何您喜欢的东西，这是一个例子：\n%description\rvitetris is a multiplayer ASCII-based Tetris game\r测试初始版本 使用刚刚提供的信息测试构建，查看出现了哪些错误：\n$ rpmbuild -ba rpmbuild/SPECS/vitetris.spec\r...\rRPM build errors:\rInstalled (but unpackaged) file(s) found:\r/usr/local/bin/tetris\r/usr/local/share/applications/vitetris.desktop\r/usr/local/share/doc/vitetris/README\r/usr/local/share/doc/vitetris/licence.txt\r/usr/local/share/pixmaps/vitetris.xpm\r将上一步中的文件列表添加到规范文件 您需要将上一步中的文件列表添加到spec文件的%files节中，如下所示：\n%files\r/usr/local/bin/tetris\r/usr/local/share/applications/vitetris.desktop\r%doc /usr/local/share/doc/vitetris/README\r/usr/local/share/doc/vitetris/licence.txt\r/usr/local/share/pixmaps/vitetris.xpm\r请注意，在自述文件的前面需要放上%doc，以将其标识为参考文件。没有这个，RPM仍然会成功构建。\n重新运行构建 $ rpmbuild -ba rpmbuild/SPECS/vitetris.spec\rWrote: /home/rpmbuilder/rpmbuild/SRPMS/vitetris-0.57-1.el7.src.rpm\rWrote: /home/rpmbuilder/rpmbuild/RPMS/x86_64/vitetris-0.57-1.el7.x86_64.rpm\rWrote: /home/rpmbuilder/rpmbuild/RPMS/x86_64/vitetris-debuginfo-0.57-1.el7.x86_64.rpm\rExecuting(%clean): /bin/sh -e /var/tmp/rpm-tmp.AqR4Aq\r+ umask 022\r+ cd /home/rpmbuilder/rpmbuild/BUILD\r+ cd vitetris-0.57\r+ /usr/bin/rm -rf /home/rpmbuilder/rpmbuild/BUILDROOT/vitetris-0.57-1.el7.x86_64\r+ exit 0\r给RPM包签名 给RPM包签名很简单：\n$ rpmsign --addsign /home/rpmbuilder/rpmbuild/RPMS/x86_64/vitetris-0.57-1.el7.x86_64.rpm Enter pass phrase: Pass phrase is good. /home/rpmbuilder/rpmbuild/RPMS/x86_64/vitetris-0.57-1.el7.x86_64.rpm:\r如果出现此错误：\nYou must set \u0026quot;%_gpg_name\u0026quot; in your macro file\r则需要在你的公钥值中设置%_gpg_name：\n$ gpg --list-keys /home/rpmbuilder/.gnupg/pubring.gpg\r-----------------------------------\rpub 2048R/EEF6D9AD 2019-03-02\ruid RPM Build User (RPM Builder GPG Signing Key) \u0026lt;rpmbuilder@rpm\u0026gt;\rsub 2048R/D498F883 2019-03-02\r$ echo \u0026quot;%_gpg_name EEF6D9AD\u0026quot; \u0026gt;\u0026gt; .rpmmacros\r再试一次：\n$ rpmsign --addsign /home/rpmbuilder/rpmbuild/RPMS/x86_64/vitetris-0.57-1.el7.x86_64.rpm\rEnter pass phrase: Pass phrase is good.\r/home/rpmbuilder/rpmbuild/RPMS/x86_64/vitetris-0.57-1.el7.x86_64.rpm:\r以root用户身份测试RPM包的安装/卸载 # rpm -i /home/rpmbuilder/rpmbuild/RPMS/x86_64/vitetris-0.57-1.el7.x86_64.rpm\rwarning: /home/rpmbuilder/rpmbuild/RPMS/x86_64/vitetris-0.57-1.el7.x86_64.rpm: Header V4 RSA/SHA1 Signature, key ID eef6d9ad: NOKEY\r# /usr/local/bin/tetris\r卸载RPM：\n# rpm -qa |grep tetris\rvitetris-0.57-1.el7.x86_64\r=# rpm -e vitetris-0.57-1.el7.x86_64\r# /usr/local/bin/tetris\r-bash: /usr/local/bin/tetris: No such file or directory\r结论 根据需求打包自定义RPM包通常可能会很困难。在本文中，我旨在说明，很少的配置也足以构建RPM。\n要了解更多信息，请参阅Red Hat的RPM包装指南。\n原文链接：https://developers.redhat.com/blog/2019/03/18/rpm-packaging-guide-creating-rpm/\n作者：Mohammad Ahmad\n译者：邵晨峰\n","description":"","id":20,"section":"blog","tags":["RPM","翻译"],"title":"RPM封装：创建一个RPM包的简化指南","uri":"https://shaochenfeng.com/blog/rpm%E5%B0%81%E8%A3%85%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AArpm%E5%8C%85%E7%9A%84%E7%AE%80%E5%8C%96%E6%8C%87%E5%8D%97/"},{"content":"一. 设置firewall规则 例1：对外暴露8080端口\nfirewall-cmd --permanent --add-port=8080/tcp\r例2：使mysql服务的3306端口只允许192.168.1.1/24网段的服务器能访问\n#添加规则\rfirewall-cmd --permanent --add-rich-rule=\u0026quot;rule family=\u0026quot;ipv4\u0026quot; source address=\u0026quot;192.168.1.1/24\u0026quot; port protocol=\u0026quot;tcp\u0026quot; port=\u0026quot;3306\u0026quot; accept\u0026quot;\r#reload使生效\rfirewall-cmd --reload\r例3：端口转发，将到本机的3306端口的访问转发到192.168.1.1服务器的3306端口\n# 开启伪装IP\rfirewall-cmd --permanent --add-masquerade\r# 配置端口转发\rfirewall-cmd --permanent --add-forward-port=port=3306:proto=tcp:toaddr=192.168.1.2:toport=13306\r注意：如果不开启伪装IP，端口转发会失败；其次，要确保源服务器上的端口（3306）和目标服务器上的端口（13306）是开启的。\n二. firewall命令 1.启动, 停止, 重启firewalld  停止  systemctl stop firewalld.service 启动  systemctl start firewalld.service 重启  systemctl restart firewalld.service\r查看状态  systemctl status firewalld 禁止firewall开机启动  systemctl disable firewalld\r设置开机启用防火墙\nsystemctl enable firewalld.service  2.查看firewall规则与状态  查看默认防火墙状态（关闭后显示notrunning，开启后显示running）  firewall-cmd --state 查看防火墙规则（只显示/etc/firewalld/zones/public.xml中防火墙策略）  firewall-cmd --list-all 查看所有的防火墙策略（即显示/etc/firewalld/zones/下的所有策略）  firewall-cmd --list-all-zones 重新加载配置文件  firewall-cmd --reload 配置firewalld-cmd  查看版本： firewall-cmd --version\r查看帮助： firewall-cmd --help\r显示状态： firewall-cmd --state\r查看所有打开的端口： firewall-cmd --zone=public --list-ports\r更新防火墙规则： firewall-cmd --reload\r查看区域信息: firewall-cmd --get-active-zones\r查看指定接口所属区域： firewall-cmd --get-zone-of-interface=eth0\r拒绝所有包：firewall-cmd --panic-on\r取消拒绝状态： firewall-cmd --panic-off\r查看是否拒绝： firewall-cmd --query-panic\r4. 开启一个端口  添加（\u0026ndash;permanent永久生效，没有此参数重启后失效）  firewall-cmd --zone=public --add-port=80/tcp --permanent\r重新载入(修改规则后使其生效)  firewall-cmd --reload\r查看  firewall-cmd --zone=public --query-port=80/tcp\r删除  firewall-cmd --zone=public --remove-port=80/tcp --permanent\r因为在/usr/lib/firewalld/services/中事先定义了ssh.xml等相应的规则，所以可以直接运用规则\nfirewall-com --zone=public --add-server=ssh --permanent\rsystemctl是CentOS7的服务管理工具中主要的工具，它融合之前service和chkconfig的功能于一体。  启动一个服务：systemctl start firewalld.service\r关闭一个服务：systemctl stop firewalld.service\r重启一个服务：systemctl restart firewalld.service\r显示一个服务的状态：systemctl status firewalld.service\r在开机时启用一个服务：systemctl enable firewalld.service\r在开机时禁用一个服务：systemctl disable firewalld.service\r查看服务是否开机启动：systemctl is-enabled firewalld.service\r查看已启动的服务列表：systemctl list-unit-files|grep enabled\r查看启动失败的服务列表：systemctl --failed\r原文链接：https://www.jianshu.com/p/4a9958d2e859\n","description":"","id":21,"section":"blog","tags":["Firewall","centos8"],"title":"Firewall常用规则设置【转发】","uri":"https://shaochenfeng.com/blog/firewall%E5%B8%B8%E7%94%A8%E8%A7%84%E5%88%99%E8%AE%BE%E7%BD%AE/"},{"content":"从可配置性到安全性，从Web应用程序到大数据开发，无论您的应用程序需要什么样的基础框架，都有一个 Spring项目 可以帮助您构建它。从小着手并按需使用，因为Spring是为模块化设计的。\n——来自官网\n文章主要翻译自spring官方的项目介绍 https://spring.io/projects\n其中没翻译的就是我不知道怎么翻译比较好，看英文吧\n积极开发的项目 Spring Boot 以最通用的配置，以最快的速度让应用尽快可以运行\nSpring Framework 为依赖注入、事务管理、web应用、数据访问、消息传递等功能提供核心支持\nSpring Data 提供一致的接口去访问数据库——关系型、非关系型、map-reduce等\nSpring Cloud 提供一组用于分布式系统的常用工具，对于构建和部署微服务很有用\nSpring Cloud Data Flow An orchestration service for composable data microservice applications on modern runtimes.\nSpring Security 通过全面且可扩展的身份验证和授权支持保护您的应用程序\nSpring Session 提供了用于管理用户会话信息的API和实现。\nSpring Integration 通过轻量级消息传递和声明性适配器支持了著名的企业集成模式\nSpring HATEOAS 轻松创建遵循HATEOAS规则的REST\nSpring REST Docs 将手写文档与Spring MVC Test、REST Assured生成的自动文档结合起来，生成RESTful服务文档。\nSpring Batch 简化和优化处理批量生产的工作。\nSpring AMQP 将Spring核心理念应用于基于AMQP的消息传递应用的开发中\nSpring for Android 提供用于开发Android应用程序的关键Spring组件\nSpring Cloud Skipper 一个软件包管理器，可在多个云平台上安装，升级和回滚Spring Boot应用程序\nSpring CredHub 为Spring应用程序提供了CredHub上安全存储，生成，检索和删除各种类型凭据的API\nSpring Flo 一个JavaScript库，\nA JavaScript library that offers a basic embeddable HTML5 visual builder for pipelines and simple graphs.\nSpring for Apache Kafka Provides Familiar Spring Abstractions for Apache Kafka.\nSpring LDAP 使用Spring基于模板的方法简化使用LDAP的应用程序开发。\nSpring Mobile 通过设备检测和渐进式渲染简化移动Web应用程序的开发。\nSpring Roo 使您可以在几分钟内快速轻松地构建完整的Java应用程序\nSpring Shell 通过CLI交互，使编写和测试RESTful应用程序更加容易。\nSpring Statemachine 应用程序开发人员可以在Spring应用程序中使用状态机概念的框架\nSpring Vault Provides familiar Spring abstractions for HashiCorp Vault\nSpring Web Flow 用于构建有可控导航功能的web应用程序，如办理登机手续、申请贷款等\nSpring Web Services 用于创建文档驱动的SOAP服务\n束之高阁的项目 下面是已经推出但不再被官方维护的项目，就不翻译了\nSpring IO Platform Provides a cohesive, versioned platform for building modern applications. It is a modular, enterprise-grade distribution that delivers a curated set of dependencies.\nSpring Flex A project to make it easier to build Spring-powered Rich Internet Applications using Adobe Flex as the front-end client.\nSpring Integration Groovy DSL A Groovy based DSL for developing Spring Integration applications.\nSpring Integration Scala DSL A Scala based DSL for developing Spring Integration applications.\nSpring Scala A community run project that provides support for Spring framework development in Scala\nSpring Social Easily connects your applications with third-party APIs such as Facebook, Twitter, LinkedIn, and more.\nSpring XD Simplifies the development of big data applications by addressing ingestion, analytics, batch jobs and data export.\n","description":"","id":22,"section":"blog","tags":["java","web开发"],"title":"2020年Spring所有官方项目介绍","uri":"https://shaochenfeng.com/blog/2020%E5%B9%B4spring%E6%89%80%E6%9C%89%E5%AE%98%E6%96%B9%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D/"},{"content":"nginx Rtmp Module 是一个nginx插件，需要在在编译时和nginx一起编译安装，就可以利用nginx的转发能力进行直播了\n下载源码 首先准备好源码和常用编译工具（gcc之类的）\n1 2 3 4 5 6 7 8 9 10 11  mkdir /opt/git # 这里我偷懒直接把源码下载到这了，大家自行找地方 cd /opt/git git clone https://github.com/arut/nginx-rtmp-module.git # 下载 nginx-rtmp-module wget http://nginx.org/download/nginx-1.17.7.tar.gz # 下载nginx，这里用的最新测试版，推荐大家用稳定版 tar -zxvf nginx-1.17.7.tar.gz cd nginx-1.17.7/ ./configure --prefix=/opt/nginx1.17 --add-module=/opt/git/nginx-rtmp-module # 这里是重点，添加了一个mod make \u0026amp;\u0026amp; make install # 编译安装 cd /opt/nginx1.17/ vim /opt/nginx1.17/conf/nginx.conf # 开始配置 # 全部注释或删除 /opt/nginx1.17/conf/nginx.conf 中的配置   # 在配置的最高层，可以是开头或结尾，添加下面的包含\rinclude rtmp.conf\r编辑rtmp配置文件 1  vim /opt/nginx1.17/conf/rtmp.conf   添加如下配置\nrtmp {\rserver {\rlisten 8883; # 我使用的自定义端口，而不是标准的1935\rapplication vod {\rplay /opt/nginx1.17/video;\r}\rapplication live{ #第一处添加的直播字段，添加了一个live应用，里面可以有很多直播间\rlive on;\r}\r}\r}\rhttp {\r#include mime.types;\r#default_type application/octet-stream;\r#sendfile on;\r#keepalive_timeout 65;\rserver {\rlisten 8884; #用于查看直播状态和观看直播的web页面\rserver_name localhost;\rlocation /stat { # 状态查看页面实例\rrtmp_stat all;\rrtmp_stat_stylesheet stat.xsl;\r}\rlocation /stat.xsl {\rroot /opt/git/nginx-rtmp-module/;\r}\rlocation /control {\rrtmp_control all;\r}\rlocation /rtmp-publisher {\rroot /opt/git/nginx-rtmp-module/test;\r}\rlocation / { # 直播观看页面实例\rroot /opt/git/nginx-rtmp-module/test/www;\r}\rerror_page 500 502 503 504 /50x.html;\rlocation = /50x.html {\rroot html;\r}\r}\r}\r开启防火墙 1 2 3 4  firewall-cmd --add-port=8883/tcp firewall-cmd --add-port=8883/udp firewall-cmd --add-port=8884/tcp firewall-cmd --add-port=8884/udp   至此服务器搭建完成\n使用 obs推流到\nrtmp://【ip地址】:8883/live\n在网页上查看推流情况\nhttp://【ip地址】:8884/stat\n点播视频放在服务器的\n/opt/nginx1.17/video 中\nvnc查看流，打开网络URL\nrtmp://【ip地址】:8883/live\n网页查看推流和点播视频，但是不会用\nhttp://【ip地址】:8884\n","description":"","id":23,"section":"blog","tags":["nginx","直播"],"title":"初探用nginx Rtmp Module自建直播服务器","uri":"https://shaochenfeng.com/blog/%E5%88%9D%E6%8E%A2%E7%94%A8nginx-rtmp-module%E8%87%AA%E5%BB%BA%E7%9B%B4%E6%92%AD%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"content":"前言 手头上的服务器程序1.0版本终于要进入线上测试阶段了😮。兴致冲冲的分了一台公司的系统为CentOS7.+的服务器。1、部署上环境。2、打开终端开始跑程序 \u0026ldquo;nohup dotnet XXX.dll \u0026amp;\u0026quot;。3、关闭终端。。。4、卧槽😮,我的后台运行的程序呢!?\n本人Linux小白,又尝试了几种后台运行程序的方案，全部以失败告终😭😭😭。\n然后在搜索解决方案的过程中发现了很多守护进程工具的东西,最终找到了一个最简单的工具并学习使用了它, Supervisor 。\n进程管理工具(Supervisor) 简介 Supervisor是用Python开发的一个client/server服务，是Linux/Unix系统下的一个进程管理工具，不支持Windows系统。它可以很方便的监听、启动、停止、重启一个或多个进程。用Supervisor管理的进程，当一个进程意外被杀死，supervisort监听到进程死后，会自动将它重新拉起，很方便的做到进程自动恢复的功能，不再需要自己写shell脚本来控制。\n不使用守护进程会出现的三个问题：\n ASP.NET Core应用程序运行在shell之中，如果关闭shell则会发现 ASP.NET Core程序被关闭，从而导致应用无法访问，这种情况当然是我们不想遇到的，而且生产环境对这种情况是零容忍的。 如果 ASP.NET Core进程意外终止那么需要人为连进shell进行再次启动，往往这种操作都不够及时。 如果服务器宕机或需要重启，我们则还是需要连入shell进行启动。  为了解决这些问题，我们需要有一个程序来监听 ASP.NET Core 应用程序的状况。并在应用程序停止运行的时候立即重新启动。\nSupervisor安装与配置 1、安装Python包管理工具(easy_install)\nyum install python-setuptools\n2、安装Supervisor\neasy_install supervisor\n3、配置Supervisor应用守护\na) 通过运行echo_supervisord_conf程序生成supervisor的初始化配置文件，如下所示：\nmkdir /etc/supervisor\necho_supervisord_conf \u0026gt; /etc/supervisor/supervisord.conf\n然后查看路径下的supervisord.conf。在文件尾部添加如下配置。\n;conf.d 为配置表目录的文件夹，需要手动创建\r[include]\rfiles = conf.d/*.conf\rb) 为你的程序创建一个.conf文件，放在目录\u0026rdquo;/etc/supervisor/conf.d/\u0026ldquo;下。\n1 2 3 4 5 6 7 8 9  [program:MGToastServer] ;程序名称，终端控制时需要的标识 command=dotnet MGToastServer.dll ; 运行程序的命令 directory=/root/文档/toastServer/ ; 命令执行的目录 autorestart=true ; 程序意外退出是否自动重启 stderr_logfile=/var/log/MGToastServer.err.log ; 错误日志文件 stdout_logfile=/var/log/MGToastServer.out.log ; 输出日志文件 environment=ASPNETCORE_ENVIRONMENT=Production ; 进程环境变量 user=root ; 进程执行的用户身份 stopsignal=INT   c) 运行supervisord，查看是否生效\nsupervisord -c /etc/supervisor/supervisord.conf\rps -ef | grep MGToastServer\r ps: 如果服务已启动，修改配置文件可用“supervisorctl reload”命令来使其生效\n 4、配置Supervisor开机启动 a) 新建一个“supervisord.service”文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  # dservice for systemd (CentOS 7.0+) # by ET-CS (https://github.com/ET-CS) [Unit] Description=Supervisor daemon [Service] Type=forking ExecStart=/usr/bin/supervisord -c /etc/supervisor/supervisord.conf ExecStop=/usr/bin/supervisorctl shutdown ExecReload=/usr/bin/supervisorctl reload KillMode=process Restart=on-failure RestartSec=42s [Install] WantedBy=multi-user.target   b) 将文件拷贝至\u0026rdquo;/usr/lib/systemd/system/supervisord.service\u0026quot;\nc) 执行命令\n1  systemctl enable supervisord   d) 执行命令来验证是否为开机启动\n1  systemctl is-enabled supervisord   配置完成啦.\n常用的相关管理命令\n1 2 3 4 5 6  supervisorctl restart \u0026lt;application name\u0026gt; ;重启指定应用 supervisorctl stop \u0026lt;application name\u0026gt; ;停止指定应用 supervisorctl start \u0026lt;application name\u0026gt; ;启动指定应用 supervisorctl restart all ;重启所有应用 supervisorctl stop all ;停止所有应用 supervisorctl start all ;启动所有应用   来源：https://www.jianshu.com/p/39b476e808d8\n","description":"","id":24,"section":"blog","tags":["转载","Supervisor"],"title":"Supervisor-守护进程工具【转载】","uri":"https://shaochenfeng.com/blog/supervisor-%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B%E5%B7%A5%E5%85%B7%E8%BD%AC%E8%BD%BD/"},{"content":"Apache httpd和php的结合方式有两种：\n DSO方式，php作为httpd的模块 FCGI方式，使用php-fpm单独管理php进程池  yum方式安装httpd和php centos8\n1 2  dnf install httpd dnf install php   默认是php7.2版本\ncentos7\n1 2  yum install httpd yum install php   默认是php5.4版本\n这会自动为httpd安装php插件，并启用，使用OSO方式运行php，也就是php作为httpd的模块\n默认为每个网站都配置了php的支持，直接就能可以使用\n测试一下 创建测试文件\n1 2  echo -e \u0026#34;\u0026lt;?php\\nphpinfo();\\n?\u0026gt;\u0026#34;\u0026gt; /var/www/html/index.php echo -e \u0026#34;\u0026lt;?php\\nphpinfo();\\n?\u0026gt;\u0026#34;\u0026gt; /usr/share/nginx/html/index.php   这样就可以通过 http://\u0026lt;你的服务器ip\u0026gt; 访问下\n源码方式安装php7.3 环境 centos8\n1.首先安装 httpd 和 httpd-devel 这里安装httpd-devel是为了使用apxs动态加载插件\n1  dnf install httpd httpd-devel   2.安装必要的依赖 1  dnf install libxml2-devel openssl-devel libcurl libcurl-devel libjpeg-turbo-devel libpng-devel freetype-devel libzip-devel gcc make   3.下载php源码包 1  wget https://www.php.net/distributions/php-7.3.13.tar.xz   4.解压、编译、安装 1 2 3 4  cd php-7.3.13 tar xvf php-7.3.13.tar.xz ./configure --prefix=/opt/php7.3 --with-apxs2=/usr/bin/apxs --with-config-file-path=/opt/php7.3/usr --enable-mbstring --with-openssl --enable-ftp --with-gd --with-jpeg-dir=/opt/php7.3/usr --with-png-dir=/opt/php7.3/usr --with-mysqli=mysqlnd --with-pdo-mysql=mysqlnd --with-pear --enable-sockets --with-freetype-dir=/opt/php7.3/usr --with-zlib --with-libxml-dir=/opt/php7.3/usr --with-xmlrpc --enable-zip --enable-fpm --enable-xml --enable-sockets --with-gd --with-zlib --with-iconv --enable-zip --with-freetype-dir=/opt/php7.3/usr/lib --enable-soap --enable-pcntl --enable-cli --with-curl --enable-bcmath --with-gettext make \u0026amp;\u0026amp; make install    这里使用 --prefix=/opt/php7.3 安装在 /opt/php7.3 ，可以自定义安装位置\n  这里使用 --with-apxs2=/usr/bin/apxs 指出了apxs的位置，如果是源码安装的httpd，则在安装目录下的 ./sbin/apxs\n 5.复制配置文件 cp php.ini-development /opt/php7.3/php.ini\n6.配置httpd使用php cd httpd.conf\nLoadModule php7_module\tmodules/libphp7.so # 有可能已经自动添加了\r","description":"","id":25,"section":"blog","tags":["php","httpd","centos8"],"title":"Apache httpd结合php，yum方式和源码方式","uri":"https://shaochenfeng.com/blog/apache_httpd%E5%92%8Cphp/"},{"content":"1.安装jdk tomcat9可以工作在jdk8及之后的版本\n所以可以安装jdk8或是jdk11\ndnf install java-11-openjdk # centos8\ryum install java-11-openjdk # centos7\r2.下载最新的tomcat二进制包 打开网站 https://mirrors.tuna.tsinghua.edu.cn/apache/tomcat/tomcat-9/\n在这里找到最新版本，进入后进入bin目录\n里面有名为 apache-tomcat-XXXX.tar.gz 的文件，右键复制地址\n下载并解压\nwget https://mirrors.tuna.tsinghua.edu.cn/apache/tomcat/tomcat-9/v9.0.31/bin/apache-tomcat-9.0.31.tar.gz\rtar xvf apache-tomcat-9.0.31.tar.gz\r移动到安装目录\nmv apache-tomcat-9.0.31 /opt/tomcat9\r3.常见命令和目录    命令或目录 作用     /opt/tomcat9/bin/startup.sh 启动tomcat   /opt/tomcat9/bin/shutdown.sh 关闭tomcat   /opt/tomcat9/conf/ 配置   /opt/tomcat9/logs/ 日志   /opt/tomcat9/webapps/ 默认应用目录    4.如何选择tomcat版本 下面表格来自tomcat官网\n   Servlet 规范 JSP 规范 EL 规范 WebSocket 规范 JASPIC 规范 Apache Tomcat 版本 最新版本（2020.2.19） 支持的 Java 版本     4.0 2.3 3.0 1.1 1.1 9.0.x 9.0.31 8 and later   3.1 2.3 3.0 1.1 1.1 8.5.x 8.5.51 7 and later   3.1 2.3 3.0 1.1 N/A 8.0.x (superseded) 8.0.53 (superseded) 7 and later   3.0 2.2 2.2 1.1 N/A 7.0.x 7.0.100 6 and later (7 and later for WebSocket)   2.5 2.1 2.1 N/A N/A 6.0.x (archived) 6.0.53 (archived) 5 and later   2.4 2.0 N/A N/A N/A 5.5.x (archived) 5.5.36 (archived) 1.4 and later   2.3 1.2 N/A N/A N/A 4.1.x (archived) 4.1.40 (archived) 1.3 and later   2.2 1.1 N/A N/A N/A 3.3.x (archived) 3.3.2 (archived) 1.1 and later    ","description":"","id":26,"section":"blog","tags":["java","tomcat"],"title":"Centos8(7)安装tomcat9和常见用法","uri":"https://shaochenfeng.com/blog/centos87%E5%AE%89%E8%A3%85tomcat9%E5%92%8C%E5%B8%B8%E8%A7%81%E7%94%A8%E6%B3%95/"},{"content":"httpd(apache)以其功能丰富，安全稳定，广为使用\n安装httpd 对于CentOS8:\ndnf -y install httpd\r对于CentOS7:\nyum -y install httpd\r如果出错检查检查一下网络和yum源，如何更换yum源到阿里源\n下面设置两个虚拟主机 虚拟主机可以让一个web服务器服务多个网站，每个网站可以有不同的设置，不同的语言，并且有独立的日志\n这里假设两个主机分别为\n game.shaochenfeng.com map.shaochenfeng.com  新建配置文件 注意要以conf为扩展名\n1  vim /etc/httpd/conf.d/virtual.conf   内容为\n\u0026lt;VirtualHost *:80\u0026gt;\rServerName game.shaochenfeng.com\rDocumentRoot /var/www/game.shaochenfeng.com\rDirectoryIndex index.html\rErrorLog logs/game.shaochenfeng.com.error.log\rTransferLog logs/game.shaochenfeng.com.log\r\u0026lt;/VirtualHost\u0026gt;\r\u0026lt;Directory \u0026quot;/var/www/game.shaochenfeng.com\u0026quot;\u0026gt;\rRequire all granted\r\u0026lt;/Directory\u0026gt;\r\u0026lt;VirtualHost *:80\u0026gt;\rServerName map.shaochenfeng.com\rDocumentRoot /var/www/map.shaochenfeng.com\rDirectoryIndex index.html\rErrorLog logs/map.shaochenfeng.com.error.log\rTransferLog logs/map.shaochenfeng.com.log\r\u0026lt;/VirtualHost\u0026gt;\r\u0026lt;Directory \u0026quot;/var/www/map.shaochenfeng.com\u0026quot;\u0026gt;\rRequire all granted\r\u0026lt;/Directory\u0026gt;\r其中第一行中的 \u0026lt;VirtualHost *:80\u0026gt; 指定了监听的端口和主机范围\n ServerName 监听的域名 DocumentRoot 网站根目录 DirectoryIndex 网站默认文档 ErrorLog 错误日志 TransferLog 访问日志  后面一部分 \u0026lt;Directory \u0026quot;/var/www/game.shaochenfeng.com\u0026quot;\u0026gt; 对网站目录进行设置\n保存并退出\n创建虚拟主机的主目录和日志目录 1 2 3 4 5  mkdir /var/www/game.shaochenfeng.com mkdir /var/www/map.shaochenfeng.com #将你的网站文件复制到上面对应的目录 chown apache:apache -R /var/www/game.shaochenfeng.com # httpd运行在apache用户下，所以要给网站文件授予权限 chown apache:apache -R /var/www/map.shaochenfeng.com   启动并开机启动httpd 1 2 3  systemctl enable httpd # 设置httpd开机启动 systemctl start httpd # 启动httpd systemctl status httpd # 查看httpd状态   ","description":"","id":27,"section":"blog","tags":["apache","httpd","yum","centos"],"title":"Yum安装httpd(apache)并设置虚拟主机","uri":"https://shaochenfeng.com/blog/yum%E5%AE%89%E8%A3%85httpdapache%E5%B9%B6%E8%AE%BE%E7%BD%AE%E8%99%9A%E6%8B%9F%E4%B8%BB%E6%9C%BA/"},{"content":"首先是全部步骤概括 1 2 3 4 5 6 7 8 9 10 11 12 13 14  yum install -y libaio ncurses gcc gcc-c++ cmake ncurses-devel wget yum install -y pcre-devel zlib-devel wget http://nginx.org/download/nginx-1.16.1.tar.gz # 下载源码包 tar -zxvf nginx-1.16.1.tar.gz cd nginx-1.16.1 ./configure --prefix=/opt/nginx1.16 # 这里指定安装目录 make \u0026amp;\u0026amp; make install useradd www -s /bin/false vi /opt/nginx1.16/conf/nginx.conf # 修改配置文件 # 第一行去掉前面井号并改为 user www; /opt/nginx1.16/sbin/nginx #启动nginx #以下为可选 /opt/nginx1.16/sbin/nginx -s stop #停止 /opt/nginx1.16/sbin/nginx -s reload #重新载入配置   1.安装编译器和依赖 1 2  yum install libaio ncurses gcc gcc-c++ cmake ncurses-devel wget yum install pcre-devel zlib-devel   这些依赖是编译nginx需要的，否则无法完成编译\n2.下载源码包并解压 1 2 3  wget http://nginx.org/download/nginx-1.16.1.tar.gz # 下载源码包 tar -zxvf nginx-1.16.1.tar.gz cd nginx-1.16.1   3.编译安装 1 2  ./configure --prefix=/opt/nginx1.16 # 这里指定安装目录 make \u0026amp;\u0026amp; make install   在编译之前可以制定安装目录，这样所有的数据、配置、程序都会放到这个目录下\n也可以不指定，如下所示\n1 2  ./configure make \u0026amp;\u0026amp; make install   这样会安装到默认位置\n4.添加nginx使用的用户 1 2 3  useradd www -s /bin/false vi /opt/nginx1.16/conf/nginx.conf # 修改配置文件 # 第一行去掉前面井号并改为 user www;   nginx默认不使用root用户运行网站的脚本，而是使用nobody，因为一旦执行恶意脚本，后果很严重\n但是nobidy的权限很小，我们通常会新建一个nginx用户或是www用户，当作nginx使用的用户\n5.启动和重启 1 2 3  /opt/nginx1.16/sbin/nginx #启动nginx /opt/nginx1.16/sbin/nginx -s stop #停止 /opt/nginx1.16/sbin/nginx -s reload #重新载入配置   ","description":"","id":28,"section":"blog","tags":["nginx"],"title":"源码安装nginx到指定目录","uri":"https://shaochenfeng.com/blog/%E6%BA%90%E7%A0%81%E5%AE%89%E8%A3%85nginx%E5%88%B0%E6%8C%87%E5%AE%9A%E7%9B%AE%E5%BD%95/"},{"content":"https是加密的http协议，现在以谷歌浏览器为首的很多浏览器开始将仅支持http的网站标识为不安全\n所以全站https就成为了现代网站的标配，本文介绍ngnix如何配置ssl证书，以支持https\n首先在准备申请来的证书文件如何申请?\n这里假设ssl证书放在\n /usr/share/nginx/ssl/www.shaochenfeng.com.cer; /usr/share/nginx/ssl/www.shaochenfeng.com.key;  编辑nginx配置文件\n1  vim /etc/nginx/nginx.conf   找到下面被注释的ssl配置，全部取消注释\n开始可能是这样\n改成这样\n主要就是改了红框中的两个参数\n ssl_certificate 证书 ssl_certificate_key 证书密钥  然后重启nginx生效\n如果不想在主配置中添加，可以在虚拟主机配置中为每个网站单独配置\n实例文件如下\nserver {\rlisten 80;\rlisten 443 ssl;\rserver_name www.shaochenfeng.com;\rroot /usr/share/nginx/www.shaochenfeng.com;\rssl on;\rssl_certificate /usr/share/nginx/ssl/www.shaochenfeng.com.cer;\rssl_certificate_key /usr/share/nginx/ssl/www.shaochenfeng.com.key;\rlocation / {\r}\r}\r","description":"","id":29,"section":"blog","tags":["https","nginx"],"title":"Nginx配置ssl证书，支持https","uri":"https://shaochenfeng.com/blog/nginx%E9%85%8D%E7%BD%AEssl%E8%AF%81%E4%B9%A6%E6%94%AF%E6%8C%81htts/"},{"content":"CentOS7默认安装MariaDB，安装mysql5.7就需要添加mysql官方yum源\n1. 下载官方yum源 首先需要下载官方yum源\n1  wget https://repo.mysql.com/mysql57-community-release-el7.rpm   2.安装yum源 1  yum -y install mysql57-community-release-el7.rpm   3.安装mysql服务器 一切准备就绪，现在可以安装mysql服务器了\n1  yum -y install mysql-community-server   4. 启动服务 现在使用 systemctl 启动mysql守护进程\n1  systemctl start mysqld   第一次启动mysql会初始化数据库，所以需要点时间\n5. 查看root密码 初始化数据库的时候会为root设置一个默认密码，这个密码在log文件中可以找到\n1 2  less /var/log/mysqld.log # 查看日志查看密码 # 会有一行 password is generated XXXXX   或者可以使用下面语句直接提取出密码\n1  grep \u0026#34;password is generated\u0026#34; /var/log/mysqld.log | awk \u0026#39;{print $NF}\u0026#39;   找到密码后可以用以下命令输入密码进入数据库\n1  mysql -uroot -p   第一次进入数据库只能修改密码，不能做任何事\n1  mysql\u0026gt; ALTER USER \u0026#39;root\u0026#39;@\u0026#39;localhost\u0026#39; IDENTIFIED BY \u0026#39;new password\u0026#39;;   这里的新密码不能太简单，因为mysql默认对密码有复杂度要求\n可以通过下面命令关闭复杂度要求\n1 2  mysql\u0026gt; set global validate_password_policy=0; # 关闭密码复杂性策略 mysql\u0026gt; set global validate_password_length=4; # 设置密码最低长度为4   ","description":"","id":30,"section":"blog","tags":["mysql5.7","CentOS7"],"title":"yum安装mysql5.7，查看默认root密码","uri":"https://shaochenfeng.com/blog/yum%E5%AE%89%E8%A3%85mysql5.7%E6%9F%A5%E7%9C%8B%E9%BB%98%E8%AE%A4root%E5%AF%86%E7%A0%81/"},{"content":"1. 下载官方yum源 CentOS8默认源安装的就是mysql8 跳过这一步，去第三步\nCentOS7默认安装MariaDB，安装mysql8就需要添加mysql官方yum源\n首先需要下载官方yum源\n1  wget https://repo.mysql.com/mysql80-community-release-el7.rpm # 仅CentOS7   2.安装yum源 1  yum -y install mysql80-community-release-el7.rpm # 仅CentOS7   3.安装mysql服务器 一切准备就绪，现在可以安装mysql服务器了\n对于CentOS8:\n1  dnf -y install mysql-server   对于CentOS7:\n1  yum -y install mysql-community-server   4. 启动服务 现在使用 systemctl 启动mysql守护进程\n1  systemctl start mysqld   第一次启动mysql会初始化数据库，所以需要点时间\n对于CentOS8，从默认源安装mysql8没有密码，可以直接mysql进入使用\n对于CentOS7,从官方源安装会生成默认密码，可以通过后面的步骤查看密码并修改\n5. 查看root密码 初始化数据库的时候会为root设置一个默认密码，这个密码在log文件中可以找到\n1 2  less /var/log/mysqld.log # 查看日志查看密码 # 会有一行 password is generated XXXXX   或者可以使用下面语句直接提取出密码\n1  grep \u0026#34;password is generated\u0026#34; /var/log/mysqld.log | awk \u0026#39;{print $NF}\u0026#39;   找到密码后可以用以下命令输入密码进入数据库\n1  mysql -uroot -p   第一次进入数据库只能修改密码，不能做任何事\n1  mysql\u0026gt; ALTER USER \u0026#39;root\u0026#39;@\u0026#39;localhost\u0026#39; IDENTIFIED BY \u0026#39;new password\u0026#39;;   这里的新密码不能太简单，因为mysql默认对密码有复杂度要求\n可以通过下面命令关闭复杂度要求\n1 2 3  show global variables like \u0026#39;%validate_password%\u0026#39;; mysql\u0026gt; set global validate_password.policy=0; # 关闭密码复杂性策略 mysql\u0026gt; set global validate_password.length=4; # 设置密码最低长度为4   ","description":"","id":31,"section":"blog","tags":["mysql8","CentOS"],"title":"yum安装mysql8，查看默认root密码","uri":"https://shaochenfeng.com/blog/yum%E5%AE%89%E8%A3%85mysql8%E6%9F%A5%E7%9C%8B%E9%BB%98%E8%AE%A4root%E5%AF%86%E7%A0%81/"},{"content":"sed可以按照指令或脚本编辑文本的linux工具，文本处理功能非常强大，本文总结一些工作中常用的sed模板，方便大家使用\n替换 1. 替换文件中所有的 aaa 到 bbb 1  sed -i \u0026#39;s/aaa/bbb/g\u0026#39; /path/to/file   2. 找到文件的修改日期 1 2  stat deploy | sed -n \u0026#39;/^Modify.*/p\u0026#39; # 找到 stat deploy | sed -n \u0026#39;/^Modify.*/p\u0026#39; | grep -Eo \u0026#34;....-..-.. ..:..:..\u0026#34; # 提取出修改起义   2. 找到 aaa 参数，并设置为off 1  sed -i \u0026#39;/^aaa/s/on/off/\u0026#39; /path/to/file   可以配合grep使用，完成自动设置参数\n1 2 3 4 5 6 7  have_aaa=$(grep aaa /path/to/file | sed \u0026#39;/^#.*/d\u0026#39;) # 寻找是否以存在aaa参数 if [ ! -z $have_aaa ];then # 如果存在 sed -i \u0026#39;/^aaa/s/on/off/\u0026#39; /path/to/file # 则修改为off else # 如果不存在 sed -i \u0026#39;/ccc/a aaa off\u0026#39; /path/to/file # 则在ccc参数下新增 aaa off # sed -i \u0026#39;$a/aaa off\u0026#39; /path/to/file # 则在最后新增 aaa off fi   滤掉所有注释行 1  cat /etc/my.cnf | sed \u0026#39;/^#.*/d\u0026#39;   找到并删除 找到包含aaa的行并删除\n1  sed -i \u0026#39;/aaa/d\u0026#39; /path/to/file   插入追加  a/ 在当前行下面插入; i/ 在当前行上面插入; c/ 把当前行改为新的;  在ccc开头的行下面插入 something\n1  sed -i \u0026#39;/^ccc/a something\u0026#39; /path/to/file   在ccc开头的行后追加 something\n1  sed -i \u0026#39;/^ccc/s/$/something/\u0026#39; /path/to/file   在ccc后紧接着追加something\n1  sed -i \u0026#39;s/ccc/\u0026amp;something/\u0026#39; /path/to/file   ","description":"","id":32,"section":"blog","tags":["sed","linux命令"],"title":"sed常用模板整理","uri":"https://shaochenfeng.com/blog/sed%E5%B8%B8%E7%94%A8%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/"},{"content":"有时我们会使用一些java或node应用，但又不想让他们直接监听80端口，这时就需要用到端口转发\n本文中，我们介绍Nginx如何做端口转发，还有各种转发规则\n将域名转发到本地端口 首先介绍最常用的，将域名转发到本地另一个端口上\nserver{\rlisten 80;\rserver_name tomcat.shaochenfeng.com;\rindex index.php index.html index.htm;\rlocation / {\rproxy_pass http://127.0.0.1:8080; # 转发规则\rproxy_set_header Host $proxy_host; # 修改转发请求头，让8080端口的应用可以受到真实的请求\rproxy_set_header X-Real-IP $remote_addr;\rproxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\r}\r}\r这样访问 http://tomcat.shaochenfeng.com 时就会转发到本地的 8080 端口\n将域名转发到另一个域名 server{\rlisten 80;\rserver_name baidu.shaochenfeng.com;\rindex index.php index.html index.htm;\rlocation / {\rproxy_pass http://www.baidu.com;\rproxy_set_header Host $proxy_host;\rproxy_set_header X-Real-IP $remote_addr;\rproxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\r}\r}\r这样访问 http://baidu.shaochenfeng.com 时就会转发到 http://www.baidu.com\n本地一个端口转发到另一个端口或另一个域名 server{\rlisten 80;\rserver_name 127.0.0.1; # 公网ip\rindex index.php index.html index.htm;\rlocation / {\rproxy_pass http://127.0.0.1:8080; # 或 http://www.baidu.com\rproxy_set_header Host $proxy_host;\rproxy_set_header X-Real-IP $remote_addr;\rproxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\r}\r}\r这样访问 http://127.0.0.1 时就会转发到本地的 8080 端口或 http://www.baidu.com\n加 / 与不加 / 在配置proxy_pass代理转发时，如果后面的url加/，表示绝对根路径；如果没有/，表示相对路径\n例如\n 加 /  server_name shaochenfeng.com\rlocation /data/ {\rproxy_pass http://127.0.0.1/;\r}\r访问 http://shaochenfeng.com/data/index.html 会转发到 http://127.0.0.1/index.html\n不加 /  server_name shaochenfeng.com\rlocation /data/ {\rproxy_pass http://127.0.0.1;\r}\r访问 http://shaochenfeng.com/data/index.html 会转发到 http://127.0.0.1/data/index.html\n","description":"","id":33,"section":"blog","tags":["端口转发","nginx"],"title":"Nginx端口转发（反向代理）","uri":"https://shaochenfeng.com/blog/nginx%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/"},{"content":"整个网站通常会很大，尤其的其中静态的图片视频之类，但我们通常不会修改他们，平常只会修改几个文件，如果每次更新都将整个网站从本地上传到服务器，无疑很费时间，如果要找到修改的文件，并只上传这些文件，甚至只上传这些文件修改的部分，无疑会方便很多。\n这就要用的到今天的主角Rsync，Rsync 可以执行增量备份，它只传输源文件和目标文件之间不一致的部分\n环境：\nweb服务器root目录 /usr/share/nginx/game.shaochenfeng.com\n本地项目目录 /git/game.shaochenfeng.com/public\n首先建议配置好本地到web服务器的ssh免密码登陆如何？，不配置需要以后每次同步时输入密码\n1.在web服务器端安装rsync 直接yum或apt安装就可以，在服务器端和本地都安装\n1 2  yum install rsync # 红帽系 apt install rsync # Debian系   为什么要在服务器也安装rsync呢？因为虽然是通过ssh建立链接，但rsync使用的是自己的传输规则，而不是scp\n2.向服务器推送 在本地执行，同步 本地项目目录 到 web服务器root目录\n1 2  rsync -avz --delete \u0026lt;本地路径\u0026gt; www@192.168.56.10:\u0026lt;远程路径\u0026gt; rsync -avz --delete /git/game.shaochenfeng.com/public www@192.168.56.10:/usr/share/nginx/game.shaochenfeng.com   其中参数\n -a 是递归传输并保持文件属性，在传输带有文件夹时使用，并保留文件的属性 -v 显示传输过程 -z 进行压缩传输，提高效率 \u0026ndash;delete 本地删除的文件，在服务器也会被删除  附上rsync常用选项 -a 包含-rtplgoD\n-r 递归传输 同步有文件夹时使用\n-v 显示传输过程\n-l 保留软连接\n-p 保持权限属性\n-o 保持属主\n-g 保持属组\n-D 保持设备文件信息\n-t 保持文件的时间属性，这个一定要有，不然下次同步不能判断那些文件发生了修改\n\u0026ndash;backup 对服务器已存在的文件做一个备份，备份的文件名后默认使用\u0026quot;~\u0026ldquo;做后缀\n\u0026ndash;delete 本地删除的文件，在服务器也会被删除\n\u0026ndash;exclude 过滤指定文件，如\u0026ndash;exclude “logs”会把文件名包含logs的文件或者目录过滤掉，不同步\n-P 显示同步过程，比如速率，比-v更加详细\n-u 加上该选项后，如果DEST中的文件比SRC新，则不同步\n\u0026ndash;size-only 默认算法会检查修改时间和文件大小，加上这个只检查文件大小\n-z 进行压缩传输，提高效率\n-h \u0026ndash;progress 同步了那些文件和进度过程\n","description":"","id":34,"section":"blog","tags":["部署","Rsync"],"title":"用Rsync,实现网站的增量部署","uri":"https://shaochenfeng.com/blog/%E7%94%A8rsync%E5%AE%9E%E7%8E%B0%E7%BD%91%E7%AB%99%E7%9A%84%E5%A2%9E%E9%87%8F%E9%83%A8%E7%BD%B2/"},{"content":"点击打开PDF,有书签\n","description":"","id":35,"section":"blog","tags":["官方文档","转载"],"title":"红帽8发行版说明PDF","uri":"https://shaochenfeng.com/blog/%E7%BA%A2%E5%B8%BD8%E5%8F%91%E8%A1%8C%E7%89%88%E8%AF%B4%E6%98%8Epdf/"},{"content":"1.首先备份当前配置文件 1 2  mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup   2.下载新的 CentOS-Base.repo 到 /etc/yum.repos.d 对于CentOS8\n1 2  wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-8.repo   对于CentOS7\n1 2  wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo   3. 运行 yum makecache 生成缓存 1  yum makecache   ","description":"","id":36,"section":"blog","tags":["centos","yum"],"title":"2020年CentOS8(7)更换yum源为阿里源","uri":"https://shaochenfeng.com/blog/2020%E5%B9%B4centos87%E6%9B%B4%E6%8D%A2yum%E6%BA%90%E4%B8%BA%E9%98%BF%E9%87%8C%E6%BA%90/"},{"content":"nginx是最近非常火的web服务器，这次CentOS8也在yum官方源中新增了nginx 1.14\n与Apache相比可以承担更大的并发，并占用更少的内存\nCentOS8使用了新一代的yum，使用dnf作为命令（原来的yum以dnf的软链接形式存在）\n安装只需要一句 1  dnf install nginx -y   如果出错检查检查一下网络和yum源，如何更换yum源到阿里源\n下面设置两个虚拟主机 虚拟主机可以让一个web服务器服务多个网站，每个网站可以有不同的设置，不同的语言，并且有独立的日志\n这里假设两个主机分别为\n game.shaochenfeng.com map.shaochenfeng.com  首先编辑nginx的主配置文件，如果虚拟主机很多的话，应该写到多个配置文件中(如何？)\n1  vim /etc/nginx/nginx.conf   可以看到里面有个默认网站，不用管它，在红色箭头处插入两个网站的配置\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  server { listen 80; listen [::]:80; access_log /usr/share/nginx/log/game.shaochenfeng.com; error_log /usr/share/nginx/log/game.shaochenfeng.com.err error; server_name game.shaochenfeng.com; root /usr/share/nginx/game.shaochenfeng.com; location / { } } server { listen 80; listen [::]:80; access_log /usr/share/nginx/log/map.shaochenfeng.com; error_log /usr/share/nginx/log/map.shaochenfeng.com.err error; server_name map.shaochenfeng.com; root /usr/share/nginx/map.shaochenfeng.com; location / { } }   保存并退出\n下面创建虚拟主机的主目录和日志目录\n1 2 3 4 5 6  mkdir /usr/share/nginx/game.shaochenfeng.com # 创建虚拟主机的主目录和日志目录 mkdir /usr/share/nginx/map.shaochenfeng.com #将你的网站文件复制到上面对应的目录 mkdir /usr/share/nginx/log chown nginx:nginx -R /usr/share/nginx/game.shaochenfeng.com # nginx运行在nginx用户下，所以要给网站文件授予权限 chown nginx:nginx -R /usr/share/nginx/map.shaochenfeng.com   启动并开机启动nginx\n1 2 3  systemctl enable nginx # 设置nginx开机启动 systemctl start nginx # 启动nginx systemctl status nginx # 查看nginx状态   这样，\n当访问game.shaochenfeng.com时就会得到/usr/share/nginx/game.shaochenfeng.com/index.html\n当访问map.shaochenfeng.com时就会得到/usr/share/nginx/map.shaochenfeng.com/index.html\n","description":"","id":37,"section":"blog","tags":["虚拟主机","nginx","Centos8"],"title":"Centos8 Yum安装nginx并设置虚拟主机","uri":"https://shaochenfeng.com/blog/centos8yum%E5%AE%89%E8%A3%85nginx%E5%B9%B6%E8%AE%BE%E7%BD%AE%E8%99%9A%E6%8B%9F%E4%B8%BB%E6%9C%BA/"},{"content":"本文将介绍 C语言标准库\u0026lt;stdlib.h\u0026gt; 中的 宏、函数、数据类型\n在最后给出一个实例程序，尽可能运用到所有函数\n宏 EXIT_SUCCESS 和 EXIT_FAILURE exit函数成功退出和失败的返回值\n1 2  #define EXIT_SUCCESS\t0 #define EXIT_FAILURE\t1   RAND_MAX rand 函数返回的最大的数 1  #define RAND_MAX\t0x7FFF   MB_CUR_MAX 一个多字节字符的最大字节数 源码处理的比较复杂\n函数 将字符串转换为 double 1  double atof (const char *);   将字符串转换为 int 1  int atoi (const char *);   将字符串转换为 long int 1  long atol (const char *);   将以数字开头的字符串转换为 double str 是一个以数字开头的字符串，\n返回把 str 转换后的 double ， endptr 指向第一个不是数字的字符\n1  double strtod(const char *str, char **endptr)   将以数字开头的字符串转换为 long int str 是一个以数字开头的字符串，\n返回把 str 以 base 为基数（进制）转换后的 long int ，\nendptr 指向第一个不是数字的字符\n1  long int strtol(const char *str, char **endptr, int base)   str 是一个以数字开头的字符串， 返回把 str 以 base 为基数 转换后的 unsigned long int ，\nendptr 指向第一个不是数字的字符\n1  unsigned long int strtoul(const char *str, char **endptr, int base)   分配请求的内存大小(nitems * size)并返回指向它的指针 1  void *calloc(size_t nitems, size_t size)   分配请求的内存(size)并返回指向它的指针 1  void *malloc(size_t size)   调整之前分配的内存块大小  ptr 执行要调整的内存块 size 要调整到的字节数  1  void *realloc(void *ptr, size_t size)   回收先前分配的内存 1  void free(void *ptr)   搜索环境变量并返回字符串 1  char *getenv(const char *name)   把命令(string)传递给主机由主机执行 1  int system(const char *string)   快速排序  base是数组的基地址 nitems是数组的元素个数 size是数组元素大小 compar是比较函数，靠返回值正负来比较，为0的情况未定义  1 2  void qsort(void *base, size_t nitems, size_t size, int (*compar)(const void *, const void*))   二分查找  key是要查找的元素 base是数组的基地址 num是数组的元素个数 size数组元素大小 cmp是比较函数，靠返回值正负来比较，数组必须是排好序的 返回找到的元素的指针  1 2  void *bsearch(const void *key, const void *base, size_t num, size_t size, int (*cmp)(const void *, const void *));   返回x的绝对值 1 2  int abs(int x) long int labs(long int x)   做除法，分别得到除数和被除数 1 2  div_t div(int numer, int denom) ldiv_t ldiv(long int numer, long int denom)   返回一个随机数，范围(0~RAND_MAX) 1  int rand(void)   对随机函数设置种子 1  void srand(unsigned int seed)   计算一个多字节字符的长度  n 是多字节字符的长度的最大值  1  int mblen(const char *str, size_t n)   多字节字符串转换为数组 将由参数str指向的多字节字符串转换为由pwcs指向的数组\n n 是多字节字符的长度的最大值  1  size_t mbstowcs(schar_t *pwcs, const char *str, size_t n)   在程序正常退出时执行  func 要执行的函数  1  int atexit(void (*func)(void))   程序异常退出 1  void abort(void)   程序正常退出 ,返回给操作系统 status 1  void exit(int status)   数据类型 size_t是sizeof关键词的值，无符号整形 wchar_t 宽字符类型 div_t与ldiv_t结构体 作为 div 的返回值 1 2 3 4 5 6 7 8 9  typedef struct { int quot; // 商  int rem; // 余数 } div_t; //------------------------------- typedef struct { long int quot; // 商  long int rem; // 余数 } ldiv_t;   示例文件 Github\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;string.h\u0026gt;void test(){ printf(\u0026#34;do this at exit\\n\u0026#34;); } int cmptest(const void * a, const void * b){ return (int)( *(char*)a - *(char*)b ); } int main (){ /// /// ## 数据类型 ///  /// ### size_t是sizeof关键词的值，无符号整形  printf(\u0026#34;size_t %d\\n\u0026#34;,sizeof(size_t)); /// ### wchar_t 宽字符类型  printf(\u0026#34;wchar_t %d\\n\u0026#34;,sizeof(wchar_t)); /// ### div_t与ldiv_t结构体 作为 div 的返回值 /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c /// typedef struct { /// int quot; // 商 /// int rem; // 余数 /// } div_t;  div_t div_t_timp; printf(\u0026#34;div_t %d div_t.quot %d div_t.rem %d\\n\u0026#34;, sizeof(div_t),sizeof(div_t_timp.quot),sizeof(div_t_timp.rem)); /// //------------------------------- /// typedef struct { /// long int quot; // 商 /// long int rem; // 余数 /// } ldiv_t; /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  ldiv_t ldiv_t_timp; printf(\u0026#34;ldiv_t %d ldiv_t.quot %d ldiv_t.rem %d\\n\u0026#34;, sizeof(ldiv_t),sizeof(ldiv_t_timp.quot),sizeof(ldiv_t_timp.rem)); /// /// ## 宏 ///  /// ### EXIT_SUCCESS 和 EXIT_FAILURE /// exit函数成功退出和失败的返回值 /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c /// #define EXIT_SUCCESS\t0 /// #define EXIT_FAILURE\t1 /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  printf(\u0026#34;EXIT_SUCCESS %d\\nEXIT_FAILURE %d\\n\u0026#34;,EXIT_SUCCESS,EXIT_FAILURE); /// ### RAND_MAX rand 函数返回的最大的数 /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c /// #define RAND_MAX\t0x7FFF /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  printf(\u0026#34;RAND_MAX %d\\n\u0026#34;,RAND_MAX); /// ### MB_CUR_MAX 一个多字节字符的最大字节数 /// 头文件中的处理比较复杂  printf(\u0026#34;MB_CUR_MAX %d\\n\u0026#34;,MB_CUR_MAX); /// /// ## 函数 ///  /// ### 将字符串转换为 double /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c /// double atof (const char *); /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  printf(\u0026#34;atof(\\\u0026#34;12.3\\\u0026#34;) %f\\n\u0026#34;,atof(\u0026#34;12.3\u0026#34;)); /// ### 将字符串转换为 int /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c /// int atoi (const char *); /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  printf(\u0026#34;atoi(\\\u0026#34;12\\\u0026#34;) %d\\n\u0026#34;,atoi(\u0026#34;12\u0026#34;)); /// ### 将字符串转换为 long int /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c /// long atol (const char *); /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  printf(\u0026#34;atol(\\\u0026#34;123456789\\\u0026#34;) %ld\\n\u0026#34;,atol(\u0026#34;123456789\u0026#34;)); /// ### 将以数字开头的字符串转换为 double /// str 是一个以数字开头的字符串， /// 返回把 str 转换后的 double ， endptr 指向第一个不是数字的字符 /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c /// double strtod(const char *str, char **endptr) /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  char *p; printf(\u0026#34;strtod(\\\u0026#34;12.030 hello\\\u0026#34;,\u0026amp;p) %f\u0026#34;,strtod(\u0026#34;12.030hello\u0026#34;,\u0026amp;p)); printf(\u0026#34; %s\\n\u0026#34;,p); /// ### 将以数字开头的字符串转换为 long int /// str 是一个以数字开头的字符串， /// 返回把 str 以 base 为基数（进制）转换后的 long int ， /// endptr 指向第一个不是数字的字符 /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c /// long int strtol(const char *str, char **endptr, int base) /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  printf(\u0026#34;strtol(\\\u0026#34;ffhello\\\u0026#34;,\u0026amp;p,16) %ld\u0026#34;,strtol(\u0026#34;ffhello\u0026#34;,\u0026amp;p,16)); printf(\u0026#34; %s\\n\u0026#34;,p); /// ### str 是一个以数字开头的字符串， /// 返回把 str 以 base 为基数 转换后的 unsigned long int ， /// endptr 指向第一个不是数字的字符 /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c /// unsigned long int strtoul(const char *str, char **endptr, int base) /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  printf(\u0026#34;strtoul(\\\u0026#34;ffhello\\\u0026#34;,\u0026amp;p,16) %uld\u0026#34;,strtoul(\u0026#34;ffhello\u0026#34;,\u0026amp;p,16)); printf(\u0026#34; %s\\n\u0026#34;,p); /// ### 分配请求的内存大小(nitems * size)并返回指向它的指针 /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c /// void *calloc(size_t nitems, size_t size) /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  p = (char *)calloc(5, sizeof(char)); printf(\u0026#34;calloc(5, sizeof(char)) %p\\n\u0026#34;,p); /// ### 分配请求的内存(size)并返回指向它的指针 /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c /// void *malloc(size_t size) /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  /* p = (char *)calloc(5 * sizeof(char)); */ /// ### 调整之前分配的内存块大小 /// * ptr 执行要调整的内存块 /// * size 要调整到的字节数 /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c /// void *realloc(void *ptr, size_t size) /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  p = realloc(p,10*sizeof(char)); printf(\u0026#34;realloc(p,10*sizeof(char)) %p\\n\u0026#34;,p); p = realloc(p,10000*sizeof(char)); printf(\u0026#34;realloc(p,10000*sizeof(char)) %p\\n\u0026#34;,p); /// ### 回收先前分配的内存 /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c /// void free(void *ptr) /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  free(p); /// ### 搜索环境变量并返回字符串 /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c /// char *getenv(const char *name) /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  printf(\u0026#34;getenv(\\\u0026#34;PATH\\\u0026#34;) %.30s ...\\n\u0026#34;, getenv(\u0026#34;PATH\u0026#34;)); /// ### 把命令(string)传递给主机由主机执行 /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c /// int system(const char *string) /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  printf(\u0026#34;system(\\\u0026#34;echo ok\\\u0026#34;)\\n\u0026#34;); system(\u0026#34;echo ok\u0026#34;); /// ### 快速排序 /// * base是数组的基地址 /// * nitems是数组的元素个数 /// * size是数组元素大小 /// * compar是比较函数，靠返回值正负来比较，为0的情况未定义 /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c /// void qsort(void *base, size_t nitems, size_t size, /// int (*compar)(const void *, const void*)) /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  p = (char *)calloc(11, sizeof(char)); strcpy(p,\u0026#34;5147096382\u0026#34;); qsort(p,10,sizeof(char),cmptest); printf(\u0026#34;qsort \u0026#34;); printf(p); putchar(\u0026#39;\\n\u0026#39;); /// ### 二分查找 /// * key是要查找的元素 /// * base是数组的基地址 /// * num是数组的元素个数 /// * size数组元素大小 /// * cmp是比较函数，靠返回值正负来比较，数组必须是排好序的 /// * 返回找到的元素的指针 /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c /// void *bsearch(const void *key, const void *base, size_t num, size_t size, /// int (*cmp)(const void *, const void *)); /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  char a = \u0026#39;3\u0026#39;; /* 搜索a */ printf(\u0026#34;bsearch \u0026#34;); printf((char *)bsearch(\u0026amp;a,p,10,sizeof(char),cmptest)); free(p); putchar(\u0026#39;\\n\u0026#39;); /// ### 返回x的绝对值 /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c /// int abs(int x) /// long int labs(long int x) /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  printf(\u0026#34;abs(-5) %d\\n\u0026#34;,abs(-5)); /// ### 做除法，分别得到除数和被除数 /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c /// div_t div(int numer, int denom) /// ldiv_t ldiv(long int numer, long int denom) /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  div_t div_out = div(7,2); printf(\u0026#34;div(7,2)={%d,%d}\\n\u0026#34;,div_out.quot,div_out.rem); /// ### 返回一个随机数，范围(0~RAND_MAX) /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c /// int rand(void) /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  printf(\u0026#34;rand() = %d\\n\u0026#34;,rand()); /// ### 对随机函数设置种子 /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c /// void srand(unsigned int seed) /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  srand(15); /// ### 计算一个多字节字符的长度 /// * n 是多字节字符的长度的最大值 /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c /// int mblen(const char *str, size_t n) /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  wchar_t mywchar = L\u0026#39;汉\u0026#39;; /* 换成\u0026#39;国\u0026#39;就不行了，不知道为什么 */ printf(\u0026#34;mblen(\u0026#39;%x\u0026#39;,MB_CUR_MAX) %u\\n\u0026#34;,L\u0026#39;汉\u0026#39;,mblen((char *)\u0026amp;mywchar,MB_CUR_MAX)); /// ### 多字节字符串转换为数组 /// 将由参数str指向的多字节字符串转换为由pwcs指向的数组 /// * n 是多字节字符的长度的最大值 /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c /// size_t mbstowcs(schar_t *pwcs, const char *str, size_t n) /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  /* todu 宽字符处理看不懂 int mbtowc(whcar_t *pwc, const char *str, size_t n) Examines the multibyte character pointed to by the argument str. size_t wcstombs(char *str, const wchar_t *pwcs, size_t n) Converts the codes stored in the array pwcs to multibyte characters and stores them in the string str. int wctomb(char *str, wchar_t wchar) Examines the code which corresponds to a multibyte character given by the argument wchar. */ /// ### 在程序正常退出时执行 /// * func 要执行的函数 /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c /// int atexit(void (*func)(void)) /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  atexit(test); /// ### 程序异常退出 /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c /// void abort(void) /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  /* abort(); */ /// ### 程序正常退出 ,返回给操作系统 status /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c /// void exit(int status) /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  exit(0); }   ","description":"","id":39,"section":"blog","tags":["标准库","c/c++"],"title":"C语言标准库stdlib","uri":"https://shaochenfeng.com/blog/c%E8%AF%AD%E8%A8%80%E6%A0%87%E5%87%86%E5%BA%93stdlib.h%E5%AD%A6%E4%B9%A0/"},{"content":"我是邵晨峰，这是我的网站 我是一个小火苗\n我很小，经不住风吹雨打\n我很弱，经不起狂风大浪\n但是\n我不会停止追求伟大的脚步\n因为\n爱你，世界\n我是邵晨峰\n","description":"","id":40,"section":"blog","tags":["纪念碑"],"title":"关于我","uri":"https://shaochenfeng.com/blog/%E5%85%B3%E4%BA%8E%E6%88%91/"},{"content":"本文以demo.example.com为例，详细介绍了使用acme.sh进行ssl申请和自动续约的方法\n安装 只需要用任意用户执行\n1  curl https://get.acme.sh | sh   acme.sh 会安装到 ~/.acme.sh/目录下，并创建新的自动计划（cronjob）在凌晨0点检查所有证书\n生成证书的方式主要有三种  网站文件方式，适合于已经部署好apache或是nginx服务器的情况 临时监听80端口方式，适合于没有部署好服务的服务器 手动配置DNS，需要有手动配置DNS的权限，适合没有服务器或是不想更改服务器的情况  1.文件认证 1 2  acme.sh --issue -d \u0026lt;域名\u0026gt; --webroot \u0026lt;网站根目录\u0026gt; acme.sh --issue -d demo.example.com --webroot /home/wwwroot/demo.example.com/   2.暂时监听80端口 1 2  yum install socat acme.sh --issue -d demo.example.com --standalone   3. DNS方式 手动方式 首先获得认证需要的解析记录\n1  acme.sh --issue --dns -d demo.example.com   然后在DNS服务商中添加记录\n最后重新生成证书\n1  acme.sh --renew -d demo.example.com   使用这种方式 acme.sh 将无法自动更新证书，每次都需要手动再次重新解析验证域名所有权。\n自动方式 dns 方式的真正强大之处在于可以使用域名解析商提供的 api 自动添加 txt 记录完成验证\n首先需要在云上申请有DNS配置权限的账号密码\n腾讯云 参考：\n操作方法\n在dnspod官网上申请 https://www.dnspod.cn/Login?r=/console\n然后登录远程服务器\nexport DP_Id=\u0026quot;1234\u0026quot;\rexport DP_Key=\u0026quot;sADDsdasdgdsf\u0026quot;\racme.sh --issue --dns dns_dp -d demo.example.com\r阿里云 参考：\n操作方法\n在阿里云官网登录添加拥有DNS配置权限的子账户 https://ram.console.aliyun.com/overview\n然后登录远程服务器\nexport Ali_Key=\u0026quot;AccessKeyId\u0026quot;\rexport Ali_Secret=\u0026quot;AccessKeySecret\u0026quot;\racme.sh --issue --dns dns_ali -d demo.example.com\r证书的安装 默认生成的证书都放在安装目录下: ~/.acme.sh/\n需要将证书“拷贝”到自定义位置，方便配置，这里的复制需要用acme.sh的自带工具用于日后自动更新\n1 2 3 4  acme.sh --installcert -d demo.example.com \\  --key-file /usr/local/nginx/ssl/demo_example_com.key \\  --fullchain-file /usr/local/nginx/ssl/demo_example_com.cer \\  --reloadcmd \u0026#34;/usr/local/nginx/sbin/nginx -s reload\u0026#34;   apache服务器的配置 暂无\nnginx服务器的配置 nginx 设置类似如下\n server {\rlisten 443 ssl;\rssl on;\rssl_certificate /usr/local/nginx/ssl/demo_example_com.cer; # 这里指向证书安装的位置\rssl_certificate_key /usr/local/nginx/ssl/demo_example_com.key;\r}\r让你的SSL更安全 参考：https://mikemiao111.com/nginx%E5%A2%9E%E5%BC%BAhttps%E5%AE%89%E5%85%A8%E9%85%8D%E7%BD%AE/\nnginx默认采用1024位的加密算法，如果需要的话可以使用2048位的代替，这样可以让加密更安全\n首先生成 zjk_zoollcar_top.pem 文件到指定目录\n1  openssl dhparam -out /usr/local/nginx/ssl/demo_example_com.pem 2048   然后在nginx配置文件中设置\n server {\rlisten 443 ssl;\rssl on;\rssl_certificate /usr/local/nginx/ssl/demo_example_com.cer;\rssl_certificate_key /usr/local/nginx/ssl/demo_example_com.key;\rssl_dhparam /usr/local/nginx/ssl/demo_example_com.pem; #新增\r}\r可以用下面的网站测试SSL安全性\nhttps://www.ssllabs.com/ssltest/\n更新 acme.sh 目前由于 acme 协议和 letsencrypt CA 都在频繁的更新, 因此 acme.sh 也经常更新以保持同步.\n升级 acme.sh 到最新版 :\n1  acme.sh --upgrade   如果不想手动升级, 可以开启自动升级:\n1  acme.sh --upgrade --auto-upgrade   之后, acme.sh 就会自动保持更新了.\n你也可以随时关闭自动更新:\n1  acme.sh --upgrade --auto-upgrade 0   ","description":"","id":41,"section":"blog","tags":["https","ssl"],"title":"使用acme.sh进行ssl申请和自动续约","uri":"https://shaochenfeng.com/blog/acme.sh/"},{"content":"Lorem est tota propiore conpellat pectoribus de\npectora summo. Redit teque digerit hominumque toris verebor lumina non cervice\nsubde tollit usus habet Arctonque, furores quas nec ferunt. Quoque montibus nunc\ncaluere tempus\nThis article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\n\rHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution  Tiam, ad mint andaepu dandae nostion secatur sequo quae.\nNote that you can use Markdown syntax within a blockquote.\n Blockquote with attribution  Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\n Tables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\n   Name Age     Bob 27   Alice 23    Inline Markdown within tables    Inline  Markdown  In  Table     italics bold strikethrough  code    Code Blocks Code block with backticks html\r\u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt;\r\u0026lt;head\u0026gt;\r\u0026lt;meta charset=\u0026quot;UTF-8\u0026quot;\u0026gt;\r\u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt;\r\u0026lt;/head\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\rCode block indented with four spaces \u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt;\r\u0026lt;head\u0026gt;\r\u0026lt;meta charset=\u0026quot;UTF-8\u0026quot;\u0026gt;\r\u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt;\r\u0026lt;/head\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\r Code block with Hugo\u0026rsquo;s internal highlight shortcode 1 2 3 4 5 6 7 8 9 10  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;   List Types Ordered List  First item Second item Third item  Unordered List  List item Another item And another item  Nested list  Item  First Sub-item Second Sub-item    Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL+ALT+Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\n The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015. \u0026#x21a9;\u0026#xfe0e;\n  ","description":"","id":42,"section":"blog","tags":["markdown","css","html","themes"],"title":"Markdown Syntax Guide","uri":"https://shaochenfeng.com/blog/markdown-syntax/"},{"content":"Lorem est tota propiore conpellat pectoribus de\npectora summo. Redit teque digerit hominumque toris verebor lumina non cervice\nsubde tollit usus habet Arctonque, furores quas nec ferunt. Quoque montibus nunc\ncaluere tempus\ninhospita parcite confusaque translucet patri vestro qui optatis\nlumine cognoscere flos nubis! Fronde ipsamque patulos Dryopen deorum.\n Exierant elisi ambit vivere dedere Duce pollice Eris modo Spargitque ferrea quos palude  Rursus nulli murmur; hastile inridet ut ab gravi sententia! Nomine potitus\nsilentia flumen, sustinet placuit petis in dilapsa erat sunt. Atria\ntractus malis.\n Comas hunc haec pietate fetum procerum dixit Post torum vates letum Tiresia Flumen querellas Arcanaque montibus omnes Quidem et  Vagus elidunt \nThe Van de Graaf Canon\nMane refeci capiebant unda mulcebat Victa caducifer, malo vulnere contra\ndicere aurato, ludit regale, voca! Retorsit colit est profanae esse virescere\nfurit nec; iaculi matertera et visa est, viribus. Divesque creatis, tecta novat collumque vulnus est, parvas. Faces illo pepulere tempus adest. Tendit flamma, ab opes virum sustinet, sidus sequendo urbis.\nIubar proles corpore raptos vero auctor imperium; sed et huic: manus caeli\nLelegas tu lux. Verbis obstitit intus oblectamina fixis linguisque ausus sperare\nEchionides cornuaque tenent clausit possit. Omnia putatur. Praeteritae refert\nausus; ferebant e primus lora nutat, vici quae mea ipse. Et iter nil spectatae\nvulnus haerentia iuste et exercebat, sui et.\nEurytus Hector, materna ipsumque ut Politen, nec, nate, ignari, vernum cohaesit sequitur. Vel mitis temploque vocatus, inque alis, oculos nomen non silvis corpore coniunx ne displicet illa. Crescunt non unus, vidit visa quantum inmiti flumina mortis facto sic: undique a alios vincula sunt iactata abdita! Suspenderat ego fuit tendit: luna, ante urbem\nPropoetides parte.\n","description":"","id":43,"section":"blog","tags":["markdown","text"],"title":"Placeholder Text","uri":"https://shaochenfeng.com/blog/placeholder-text/"},{"content":"Lorem est tota propiore conpellat pectoribus de\npectora summo. Redit teque digerit hominumque toris verebor lumina non cervice\nsubde tollit usus habet Arctonque, furores quas nec ferunt. Quoque montibus nunc\ncaluere tempus\nEmoji can be enabled in a Hugo project in a number of ways.\n\rThe emojify function can be called directly in templates or Inline Shortcodes.\nTo enable emoji globally, set enableEmoji to true in your site’s configuration and then you can type emoji shorthand codes directly in content files; e.g.\n🙈 🙈 🙉 🙉 🙊 🙊\nThe Emoji cheat sheet is a useful reference for emoji shorthand codes.\nN.B. The above steps enable Unicode Standard emoji characters and sequences in Hugo, however the rendering of these glyphs depends on the browser and the platform. To style the emoji you can either use a third party emoji font or a font stack; e.g.\n1 2 3  .emoji { font-family: Apple Color Emoji,Segoe UI Emoji,NotoColorEmoji,Segoe UI Symbol,Android Emoji,EmojiSymbols; }  ","description":"","id":44,"section":"blog","tags":["emoji"],"title":"Emoji Support","uri":"https://shaochenfeng.com/blog/emoji-support/"},{"content":"更新于 2020年2月 源作者已不再维护，请谨慎选择 最近在逛Github时发现了一个单文件跨平台零依赖的图形库nuklear，这使我产生了兴趣，一个大约两万行的程序，实现了很不错的效果，更神奇的是它是零依赖的，这意味着可以运用到类似单片机等特殊环境，于是我果断Fork了它开始了学习之路zoollcar/nuklear，下面我们分析下nuklear图形库的源代码\n综述 首先看一下官方提供的demo（win gui版），后面会一部分一部分的分析\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  /* win32 实现细节*/ while (running) { /* 输入部分 */ /* win32 实现细节 */ nk_input_begin(ctx); /* input 细节 */ nk_input_end(ctx); /* GUI 部分 */ if (nk_begin(ctx, \u0026#34;Demo\u0026#34;, nk_rect(50, 50, 200, 200), NK_WINDOW_BORDER|NK_WINDOW_MOVABLE|NK_WINDOW_SCALABLE| NK_WINDOW_CLOSABLE|NK_WINDOW_MINIMIZABLE|NK_WINDOW_TITLE)) { enum {EASY, HARD}; static int op = EASY; static int property = 20; /* 固定小部件像素宽度（纵向布局） */ /* 创建小部件之前使用 nk_layout_xxx 来说明后面的小部件布局 */ nk_layout_row_static(ctx, 30/* 高度 */, 80/* 元素宽度 */, 1/* 个数 */); if (nk_button_label(ctx, \u0026#34;button\u0026#34;)){ /* 点击事件 */ fprintf(stdout, \u0026#34;button pressed\\n\u0026#34;); } /* 小部件横向动态布局（默认是纵向） */ nk_layout_row_dynamic(ctx, 30, 2); if (nk_option_label(ctx, \u0026#34;easy\u0026#34;, op == EASY)) op = EASY; if (nk_option_label(ctx, \u0026#34;hard\u0026#34;, op == HARD)) op = HARD; nk_layout_row_dynamic(ctx, 22, 1); nk_property_int(ctx, \u0026#34;Compression:\u0026#34;, 0, \u0026amp;property, 100, 10, 1); } nk_end(ctx); /* 绘制部分 */ nk_gdi_render(nk_rgb(30,30,30)); /* 平台专用渲染 */ }   这里去除了win32实现细节，因为它本身虽然是跨平台的，但并不是所有部分都跨平台\n整个程序可以分为三个输入部分，GUI部分，绘制部分，他们的关系是这样的：\ngraph TD;\r输入部分--输入信息--\u0026gt;GUI部分;\rGUI部分--绘制命令--\u0026gt;绘制部分;\r在 nuklear 中一个称为上下文的变量会贯穿整个程序，其类型为nk_context，其中记录了这个程序几乎所有的信息，包括输入结构体、整体样式、个个窗口、渲染命令缓冲区，它起着连接 nuklear 所有部分的功能\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  /* 上下文 */ struct nk_context { struct nk_input input; /* 输入 */ struct nk_style style; /* 样式 */ struct nk_buffer memory; /* 缓冲区 */ struct nk_clipboard clip; /* 剪切板 */ nk_flags last_widget_state; /* 最近一个小部件状态 */ enum nk_button_behavior button_behavior; /* 按钮行为是默认还是被替换的 */ struct nk_configuration_stacks stacks; float delta_time_seconds; /* 时间（秒） */ /* 其他细节 */ /* 窗口 */ int build; int use_pool; struct nk_pool pool; struct nk_window *begin; /* 窗口链表 */ struct nk_window *end; struct nk_window *active; /* 激活窗口 */ struct nk_window *current; /* 当前窗口 */ struct nk_page_element *freelist; unsigned int count; unsigned int seq; };   输入部分 input API 负责组织一个由当前鼠标、按键和文本输入所组成的输入状态（nk_input结构体）。 nuklear 并没有直接与系统通信，有输入状态都必须由特定于平台的代码提供的。\nnk_input_begin 会清空当前的状态，然后就可以使用nk_input_motion、nk_input_key、nk_input_button、nk_input_scroll、nk_input_char 等 这些输入函数将消息提供给nuklear，nuklear会将这些信息记录在nk_input结构体中。nk_input结构体 在 nk_context 主上下文中。\n下面是nk_input的数据结构\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  /* nk_input结构体，分为键盘和鼠标 */ struct nk_input { struct nk_keyboard keyboard; struct nk_mouse mouse; }; /* 鼠标结构体 */ struct nk_mouse { struct nk_mouse_button buttons[NK_BUTTON_MAX]; struct nk_vec2 pos; struct nk_vec2 prev; struct nk_vec2 delta; struct nk_vec2 scroll_delta; unsigned char grab; unsigned char grabbed; unsigned char ungrab; }; /* 键盘结构体 */ struct nk_keyboard { struct nk_key keys[NK_KEY_MAX]; char text[NK_INPUT_MAX]; int text_len; };   最后使用 nk_input_end 结束输入过程，这会固定下输入信息，知道下一帧中执行 nk_input_begin 。\nGUI部分 这部分是 nuklear 中最精彩的部分，这部分是跨平台的，它会将这部分中注册的小部件（按钮，单选，文字等）转换为渲染部分需要的简单命令\n总的来说，它的作用就是用尽可能简单的命令制作出美观的 UI 。\n建立一个新窗口的方法是 使用 nk_begin 它会在上下文中新建一个窗口，然后的操作就都在这个窗口进行了\n在向窗口加入小部件前需要先设定布局， nuklear 使用的是基于行的布局，使用 nk_layout_xxx 来为当前行设置布局，后面再加入的小部件就使用这个布局提供的位置和大小了。\n放置小部件可以调用 nk_button_xxx 、 nk_option_xxx 等函数创建，他们会使用 nk_widget 从窗口的 layout 中得到下一个小部件的位置大小信息，然后将渲染信息加入到渲染命令缓冲区\n最后使用 nk_end 结束建立这个窗口，可以建立下一个窗口了\n具体来说， nk_begin 建立了一个新窗口， nk_layout_xxx 设置这个窗口的 layout 属性来控制下面小部件的位置和大小， nk_button 等建立小部件的函数使用从窗口中得到位置大小信息，然后处理加入到缓冲区\n下面结合代码看一遍：\n新建窗口 （为了效果进行了削减，突出重点）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55  /* 建立一个新窗口，分离的标题和标识符的窗口，允许出现具有相同名称但不同标题的多个窗口 */ NK_API int nk_begin_titled(struct nk_context *ctx, const char *name, const char *title, struct nk_rect bounds, nk_flags flags) { struct nk_window *win; struct nk_style *style; /* 此处省略对参数进行可行性检验的代码 */ /* 下面判断这个名字是否已经存在相同的窗口 */ /* 如果有更新窗口，否则新建窗口 */ style = \u0026amp;ctx-\u0026gt;style; title_len = (int)nk_strlen(name); /* 将窗口名字计算为一个哈希值，比较哈希值比字符串比较快 */ title_hash = nk_murmur_hash(name, (int)title_len, NK_WINDOW_TITLE); /* 寻找窗口，返回值为0表示没找到，返回值为一个nk_window指针说明找到了 */ win = nk_find_window(ctx, title_hash, name); /* 下面创建或更新窗口 */ if (!win) { /* 创建一个新窗口 create new window */ nk_size name_length = (nk_size)nk_strlen(name); win = (struct nk_window*)nk_create_window(ctx); NK_ASSERT(win); if (!win) return 0; /* 将窗口添加到 ctx */ if (flags \u0026amp; NK_WINDOW_BACKGROUND) nk_insert_window(ctx, win, NK_INSERT_FRONT);/* 顶部添加 */ else nk_insert_window(ctx, win, NK_INSERT_BACK);/* 尾部添加 */ /* 初始化命令缓冲区 */ nk_command_buffer_init(\u0026amp;win-\u0026gt;buffer, \u0026amp;ctx-\u0026gt;memory, NK_CLIPPING_ON); win-\u0026gt;flags = flags; win-\u0026gt;bounds = bounds; win-\u0026gt;name = title_hash; /* 如果窗口名字比最大长度长，会被截断 */ name_length = NK_MIN(name_length, NK_WINDOW_MAX_NAME-1); NK_MEMCPY(win-\u0026gt;name_string, name, name_length); win-\u0026gt;name_string[name_length] = 0; /* 不是弹出式窗口 */ win-\u0026gt;popup.win = 0; if (!ctx-\u0026gt;active) ctx-\u0026gt;active = win; } else { /* 省略更新窗口的代码 */ } /* 省略后面会对鼠标点击后窗口的排列进行控制，大致就是点哪个哪个放到窗口链表顶端 */ win-\u0026gt;layout = (struct nk_panel*)nk_create_panel(ctx); ctx-\u0026gt;current = win; ret = nk_panel_begin(ctx, title, NK_PANEL_WINDOW); win-\u0026gt;layout-\u0026gt;offset_x = \u0026amp;win-\u0026gt;scrollbar.x; win-\u0026gt;layout-\u0026gt;offset_y = \u0026amp;win-\u0026gt;scrollbar.y; return ret; }   设置布局函数： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64  NK_LIB void nk_row_layout(struct nk_context *ctx, enum nk_layout_format fmt,/* fmt 布局类型 */ float height, int cols, int width) { /* 更新当前行并设置当前行的布局 */ struct nk_window *win; NK_ASSERT(ctx); NK_ASSERT(ctx-\u0026gt;current); NK_ASSERT(ctx-\u0026gt;current-\u0026gt;layout); if (!ctx || !ctx-\u0026gt;current || !ctx-\u0026gt;current-\u0026gt;layout) return; win = ctx-\u0026gt;current; /* 创建横向 cols 个面板 高度是 height */ nk_panel_layout(ctx, win, height, cols); /* 在下面 */ /* 根据布局类型设置 */ if (fmt == NK_DYNAMIC) win-\u0026gt;layout-\u0026gt;row.type = NK_LAYOUT_DYNAMIC_FIXED;/* 固定宽度 */ else win-\u0026gt;layout-\u0026gt;row.type = NK_LAYOUT_STATIC_FIXED;/* 动态宽度 */ win-\u0026gt;layout-\u0026gt;row.ratio = 0; win-\u0026gt;layout-\u0026gt;row.filled = 0; win-\u0026gt;layout-\u0026gt;row.item_offset = 0; win-\u0026gt;layout-\u0026gt;row.item_width = (float)width; } NK_LIB void nk_panel_layout(const struct nk_context *ctx, struct nk_window *win, float height, int cols) { struct nk_panel *layout; const struct nk_style *style; struct nk_command_buffer *out; struct nk_vec2 item_spacing; struct nk_color color; /* 省略对参数可行性检验 */ /* 先获得一些预设的配置数据 prefetch some configuration data */ layout = win-\u0026gt;layout; style = \u0026amp;ctx-\u0026gt;style; out = \u0026amp;win-\u0026gt;buffer; color = style-\u0026gt;window.background; item_spacing = style-\u0026gt;window.spacing; /* 更新当前行并设置当前行布局 update the current row and set the current row layout */ /* 通过前面获得的 layout 指针更改后面的小部件都会使用的 win-\u0026gt;layout */ layout-\u0026gt;row.index = 0; layout-\u0026gt;at_y += layout-\u0026gt;row.height; layout-\u0026gt;row.columns = cols; if (height == 0.0f) layout-\u0026gt;row.height = NK_MAX(height, layout-\u0026gt;row.min_height) + item_spacing.y; else layout-\u0026gt;row.height = height + item_spacing.y; layout-\u0026gt;row.item_offset = 0; if (layout-\u0026gt;flags \u0026amp; NK_WINDOW_DYNAMIC) { /* 为动态区域设置背景 draw background for dynamic panels */ struct nk_rect background; background.x = win-\u0026gt;bounds.x; background.w = win-\u0026gt;bounds.w; background.y = layout-\u0026gt;at_y - 1.0f; background.h = layout-\u0026gt;row.height + 1.0f; nk_fill_rect(out, background, 0, color); } }   创建小部件： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125  /* 创建按钮 */ NK_API int nk_button_text_styled(struct nk_context *ctx, const struct nk_style_button *style, const char *title, int len) { struct nk_window *win; struct nk_panel *layout; const struct nk_input *in; struct nk_rect bounds; enum nk_widget_layout_states state; /* 省略对参数可行性检验 */ /* 从 nk_context 中得到位置和大小的 nk_rect */ win = ctx-\u0026gt;current; layout = win-\u0026gt;layout; state = nk_widget(\u0026amp;bounds, ctx); if (!state) return 0; /* 生成按钮 */ in = (state == NK_WIDGET_ROM || layout-\u0026gt;flags \u0026amp; NK_WINDOW_ROM) ? 0 : \u0026amp;ctx-\u0026gt;input; return nk_do_button_text(\u0026amp;ctx-\u0026gt;last_widget_state, \u0026amp;win-\u0026gt;buffer, bounds, title, len, style-\u0026gt;text_alignment, ctx-\u0026gt;button_behavior, style, in, ctx-\u0026gt;style.font); } /* 生成按钮函数 */ NK_LIB int nk_do_button_text(nk_flags *state, struct nk_command_buffer *out, struct nk_rect bounds, const char *string, int len, nk_flags align, enum nk_button_behavior behavior, const struct nk_style_button *style, const struct nk_input *in, const struct nk_user_font *font) { struct nk_rect content; int ret = nk_false; /* 省略对参数可行性检验 */ /* 计算和返回按钮点击事件 */ /* 这里的使用 nk_input 结构中的鼠标点击位置计算是否点击到按钮 */ /* 如果点击到按钮，会返回相应的点击事件，这个时间会一路返回到用户代码中的if判断 */ ret = nk_do_button(state, out, bounds, style, in, behavior, \u0026amp;content); if (style-\u0026gt;draw_begin) style-\u0026gt;draw_begin(out, style-\u0026gt;userdata);/* 绘制开始的回调 */ /* 绘制按钮，生成按钮文字 */ nk_draw_button_text(out, \u0026amp;bounds, \u0026amp;content, *state, style, string, len, align, font); if (style-\u0026gt;draw_end) style-\u0026gt;draw_end(out, style-\u0026gt;userdata);/* 绘制完成的回调 */ return ret; } /* 真正绘制按钮 外观 */ NK_LIB const struct nk_style_item* nk_draw_button(struct nk_command_buffer *out, const struct nk_rect *bounds, nk_flags state, const struct nk_style_button *style) { const struct nk_style_item *background; if (state \u0026amp; NK_WIDGET_STATE_HOVER) background = \u0026amp;style-\u0026gt;hover; else if (state \u0026amp; NK_WIDGET_STATE_ACTIVED) background = \u0026amp;style-\u0026gt;active; else background = \u0026amp;style-\u0026gt;normal; if (background-\u0026gt;type == NK_STYLE_ITEM_IMAGE) { /* 如果是图片背景，就绘制图片 */ nk_draw_image(out, *bounds, \u0026amp;background-\u0026gt;data.image, nk_white); } else { /* 否则绘制矩形 */ nk_fill_rect(out, *bounds, style-\u0026gt;rounding, background-\u0026gt;data.color); nk_stroke_rect(out, *bounds, style-\u0026gt;rounding, style-\u0026gt;border, style-\u0026gt;border_color); } return background; } /* 绘制矩形 */ NK_API void nk_fill_rect(struct nk_command_buffer *b, struct nk_rect rect, float rounding, struct nk_color c) { struct nk_command_rect_filled *cmd; /* 省略对参数可行性检验 */ /* 将绘制命令放入命令缓冲区中，先放入再设置属性 */ cmd = (struct nk_command_rect_filled*) nk_command_buffer_push(b, NK_COMMAND_RECT_FILLED, sizeof(*cmd)); if (!cmd) return; cmd-\u0026gt;rounding = (unsigned short)rounding; cmd-\u0026gt;x = (short)rect.x; cmd-\u0026gt;y = (short)rect.y; cmd-\u0026gt;w = (unsigned short)NK_MAX(0, rect.w); cmd-\u0026gt;h = (unsigned short)NK_MAX(0, rect.h); cmd-\u0026gt;color = c; } /* 将命令加入到命令缓冲 所有的绘制命令都用这个 */ NK_LIB void* nk_command_buffer_push(struct nk_command_buffer* b, enum nk_command_type t, nk_size size) { NK_STORAGE const nk_size align = NK_ALIGNOF(struct nk_command); struct nk_command *cmd; nk_size alignment; void *unaligned; void *memory; NK_ASSERT(b); NK_ASSERT(b-\u0026gt;base); if (!b) return 0; /* 新建一块缓冲区区域，用来将命令加入缓冲区 */ cmd = (struct nk_command*)nk_buffer_alloc(b-\u0026gt;base,NK_BUFFER_FRONT,size,align); if (!cmd) return 0; /* 确保下一命令的偏移量是对齐的 make sure the offset to the next command is aligned */ b-\u0026gt;last = (nk_size)((nk_byte*)cmd - (nk_byte*)b-\u0026gt;base-\u0026gt;memory.ptr); unaligned = (nk_byte*)cmd + size; memory = NK_ALIGN_PTR(unaligned, align); alignment = (nk_size)((nk_byte*)memory - (nk_byte*)unaligned); #ifdef NK_ZERO_COMMAND_MEMORY  NK_MEMSET(cmd, 0, size + alignment); #endif  cmd-\u0026gt;type = t; cmd-\u0026gt;next = b-\u0026gt;base-\u0026gt;allocated + alignment; #ifdef NK_INCLUDE_COMMAND_USERDATA  cmd-\u0026gt;userdata = b-\u0026gt;userdata; #endif  b-\u0026gt;end = cmd-\u0026gt;next; /* 返回建好的新命令指针 */ return cmd; }   渲染部分 这个库被设计为推给后端绘制 所以它不会直接在屏幕上绘制任何图形. 而是绘制形状、小部件等。 这会缓冲进内存并组成命令队列。 每一帧会有一个带有绘制命令的命令缓冲区，提供给后端 这些绘制命令需要用户在他们自己的后端绘制中实现 之后，命令缓冲区会被清除，并且开始启动一个新帧。\n后端是用户编写的在自己设备上可以执行 nuklear 需要的最小命令集的一组函数\n其中重点在于遍历GUI部分提供的命令队列，然后根据命令类型执行相应操作\n下面看一下 nuklear 自带的在win32 GUI上的实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  NK_API void nk_gdi_render(struct nk_color clear) { const struct nk_command *cmd; HDC memory_dc = gdi.memory_dc; SelectObject(memory_dc, GetStockObject(DC_PEN)); SelectObject(memory_dc, GetStockObject(DC_BRUSH)); nk_gdi_clear(memory_dc, clear); nk_foreach(cmd, \u0026amp;gdi.ctx) { switch (cmd-\u0026gt;type) { case NK_COMMAND_NOP: break; case NK_COMMAND_SCISSOR: { const struct nk_command_scissor *s =(const struct nk_command_scissor*)cmd; nk_gdi_scissor(memory_dc, s-\u0026gt;x, s-\u0026gt;y, s-\u0026gt;w, s-\u0026gt;h); } break; case NK_COMMAND_LINE: { const struct nk_command_line *l = (const struct nk_command_line *)cmd; nk_gdi_stroke_line(memory_dc, l-\u0026gt;begin.x, l-\u0026gt;begin.y, l-\u0026gt;end.x, l-\u0026gt;end.y, l-\u0026gt;line_thickness, l-\u0026gt;color); } break; /* 省略类似的处理 */ } nk_gdi_blit(gdi.window_dc); nk_clear(\u0026amp;gdi.ctx); }   ","description":"","id":45,"section":"blog","tags":["nuklear"],"title":"nuklear的设计与源码分析","uri":"https://shaochenfeng.com/blog/nuklear%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"}]